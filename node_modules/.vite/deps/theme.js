import {
  require_crypto
} from "./chunk-MGALNVIV.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-GFT2G5UO.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/underscore/modules/_setup.js
var VERSION, root, ArrayProto, ObjProto, SymbolProto, push, slice, toString, hasOwnProperty, supportsArrayBuffer, supportsDataView, nativeIsArray, nativeKeys, nativeCreate, nativeIsView, _isNaN, _isFinite, hasEnumBug, nonEnumerableProps, MAX_ARRAY_INDEX;
var init_setup = __esm({
  "node_modules/underscore/modules/_setup.js"() {
    VERSION = "1.13.6";
    root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
    ArrayProto = Array.prototype;
    ObjProto = Object.prototype;
    SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
    push = ArrayProto.push;
    slice = ArrayProto.slice;
    toString = ObjProto.toString;
    hasOwnProperty = ObjProto.hasOwnProperty;
    supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
    supportsDataView = typeof DataView !== "undefined";
    nativeIsArray = Array.isArray;
    nativeKeys = Object.keys;
    nativeCreate = Object.create;
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
    _isNaN = isNaN;
    _isFinite = isFinite;
    hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
    nonEnumerableProps = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString"
    ];
    MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  }
});

// node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
    for (; index < length; index++) {
      rest2[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}
var init_restArguments = __esm({
  "node_modules/underscore/modules/restArguments.js"() {
  }
});

// node_modules/underscore/modules/isObject.js
function isObject2(obj2) {
  var type = typeof obj2;
  return type === "function" || type === "object" && !!obj2;
}
var init_isObject = __esm({
  "node_modules/underscore/modules/isObject.js"() {
  }
});

// node_modules/underscore/modules/isNull.js
function isNull(obj2) {
  return obj2 === null;
}
var init_isNull = __esm({
  "node_modules/underscore/modules/isNull.js"() {
  }
});

// node_modules/underscore/modules/isUndefined.js
function isUndefined(obj2) {
  return obj2 === void 0;
}
var init_isUndefined = __esm({
  "node_modules/underscore/modules/isUndefined.js"() {
  }
});

// node_modules/underscore/modules/isBoolean.js
function isBoolean(obj2) {
  return obj2 === true || obj2 === false || toString.call(obj2) === "[object Boolean]";
}
var init_isBoolean = __esm({
  "node_modules/underscore/modules/isBoolean.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/isElement.js
function isElement(obj2) {
  return !!(obj2 && obj2.nodeType === 1);
}
var init_isElement = __esm({
  "node_modules/underscore/modules/isElement.js"() {
  }
});

// node_modules/underscore/modules/_tagTester.js
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj2) {
    return toString.call(obj2) === tag;
  };
}
var init_tagTester = __esm({
  "node_modules/underscore/modules/_tagTester.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/isString.js
var isString_default;
var init_isString = __esm({
  "node_modules/underscore/modules/isString.js"() {
    init_tagTester();
    isString_default = tagTester("String");
  }
});

// node_modules/underscore/modules/isNumber.js
var isNumber_default;
var init_isNumber = __esm({
  "node_modules/underscore/modules/isNumber.js"() {
    init_tagTester();
    isNumber_default = tagTester("Number");
  }
});

// node_modules/underscore/modules/isDate.js
var isDate_default;
var init_isDate = __esm({
  "node_modules/underscore/modules/isDate.js"() {
    init_tagTester();
    isDate_default = tagTester("Date");
  }
});

// node_modules/underscore/modules/isRegExp.js
var isRegExp_default;
var init_isRegExp = __esm({
  "node_modules/underscore/modules/isRegExp.js"() {
    init_tagTester();
    isRegExp_default = tagTester("RegExp");
  }
});

// node_modules/underscore/modules/isError.js
var isError_default;
var init_isError = __esm({
  "node_modules/underscore/modules/isError.js"() {
    init_tagTester();
    isError_default = tagTester("Error");
  }
});

// node_modules/underscore/modules/isSymbol.js
var isSymbol_default;
var init_isSymbol = __esm({
  "node_modules/underscore/modules/isSymbol.js"() {
    init_tagTester();
    isSymbol_default = tagTester("Symbol");
  }
});

// node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default;
var init_isArrayBuffer = __esm({
  "node_modules/underscore/modules/isArrayBuffer.js"() {
    init_tagTester();
    isArrayBuffer_default = tagTester("ArrayBuffer");
  }
});

// node_modules/underscore/modules/isFunction.js
var isFunction, nodelist, isFunction_default;
var init_isFunction = __esm({
  "node_modules/underscore/modules/isFunction.js"() {
    init_tagTester();
    init_setup();
    isFunction = tagTester("Function");
    nodelist = root.document && root.document.childNodes;
    if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
      isFunction = function(obj2) {
        return typeof obj2 == "function" || false;
      };
    }
    isFunction_default = isFunction;
  }
});

// node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default;
var init_hasObjectTag = __esm({
  "node_modules/underscore/modules/_hasObjectTag.js"() {
    init_tagTester();
    hasObjectTag_default = tagTester("Object");
  }
});

// node_modules/underscore/modules/_stringTagBug.js
var hasStringTagBug, isIE11;
var init_stringTagBug = __esm({
  "node_modules/underscore/modules/_stringTagBug.js"() {
    init_setup();
    init_hasObjectTag();
    hasStringTagBug = supportsDataView && hasObjectTag_default(new DataView(new ArrayBuffer(8)));
    isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());
  }
});

// node_modules/underscore/modules/isDataView.js
function ie10IsDataView(obj2) {
  return obj2 != null && isFunction_default(obj2.getInt8) && isArrayBuffer_default(obj2.buffer);
}
var isDataView, isDataView_default;
var init_isDataView = __esm({
  "node_modules/underscore/modules/isDataView.js"() {
    init_tagTester();
    init_isFunction();
    init_isArrayBuffer();
    init_stringTagBug();
    isDataView = tagTester("DataView");
    isDataView_default = hasStringTagBug ? ie10IsDataView : isDataView;
  }
});

// node_modules/underscore/modules/isArray.js
var isArray_default;
var init_isArray = __esm({
  "node_modules/underscore/modules/isArray.js"() {
    init_setup();
    init_tagTester();
    isArray_default = nativeIsArray || tagTester("Array");
  }
});

// node_modules/underscore/modules/_has.js
function has(obj2, key) {
  return obj2 != null && hasOwnProperty.call(obj2, key);
}
var init_has = __esm({
  "node_modules/underscore/modules/_has.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/isArguments.js
var isArguments, isArguments_default;
var init_isArguments = __esm({
  "node_modules/underscore/modules/isArguments.js"() {
    init_tagTester();
    init_has();
    isArguments = tagTester("Arguments");
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj2) {
          return has(obj2, "callee");
        };
      }
    })();
    isArguments_default = isArguments;
  }
});

// node_modules/underscore/modules/isFinite.js
function isFinite2(obj2) {
  return !isSymbol_default(obj2) && _isFinite(obj2) && !isNaN(parseFloat(obj2));
}
var init_isFinite = __esm({
  "node_modules/underscore/modules/isFinite.js"() {
    init_setup();
    init_isSymbol();
  }
});

// node_modules/underscore/modules/isNaN.js
function isNaN2(obj2) {
  return isNumber_default(obj2) && _isNaN(obj2);
}
var init_isNaN = __esm({
  "node_modules/underscore/modules/isNaN.js"() {
    init_setup();
    init_isNumber();
  }
});

// node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var init_constant = __esm({
  "node_modules/underscore/modules/constant.js"() {
  }
});

// node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
var init_createSizePropertyCheck = __esm({
  "node_modules/underscore/modules/_createSizePropertyCheck.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj2) {
    return obj2 == null ? void 0 : obj2[key];
  };
}
var init_shallowProperty = __esm({
  "node_modules/underscore/modules/_shallowProperty.js"() {
  }
});

// node_modules/underscore/modules/_getByteLength.js
var getByteLength_default;
var init_getByteLength = __esm({
  "node_modules/underscore/modules/_getByteLength.js"() {
    init_shallowProperty();
    getByteLength_default = shallowProperty("byteLength");
  }
});

// node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default;
var init_isBufferLike = __esm({
  "node_modules/underscore/modules/_isBufferLike.js"() {
    init_createSizePropertyCheck();
    init_getByteLength();
    isBufferLike_default = createSizePropertyCheck(getByteLength_default);
  }
});

// node_modules/underscore/modules/isTypedArray.js
function isTypedArray(obj2) {
  return nativeIsView ? nativeIsView(obj2) && !isDataView_default(obj2) : isBufferLike_default(obj2) && typedArrayPattern.test(toString.call(obj2));
}
var typedArrayPattern, isTypedArray_default;
var init_isTypedArray = __esm({
  "node_modules/underscore/modules/isTypedArray.js"() {
    init_setup();
    init_isDataView();
    init_constant();
    init_isBufferLike();
    typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);
  }
});

// node_modules/underscore/modules/_getLength.js
var getLength_default;
var init_getLength = __esm({
  "node_modules/underscore/modules/_getLength.js"() {
    init_shallowProperty();
    getLength_default = shallowProperty("length");
  }
});

// node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys2) {
  var hash = {};
  for (var l2 = keys2.length, i = 0; i < l2; ++i)
    hash[keys2[i]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj2, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj2.constructor;
  var proto = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has(obj2, prop) && !keys2.contains(prop))
    keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj2 && obj2[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
var init_collectNonEnumProps = __esm({
  "node_modules/underscore/modules/_collectNonEnumProps.js"() {
    init_setup();
    init_isFunction();
    init_has();
  }
});

// node_modules/underscore/modules/keys.js
function keys(obj2) {
  if (!isObject2(obj2))
    return [];
  if (nativeKeys)
    return nativeKeys(obj2);
  var keys2 = [];
  for (var key in obj2)
    if (has(obj2, key))
      keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj2, keys2);
  return keys2;
}
var init_keys = __esm({
  "node_modules/underscore/modules/keys.js"() {
    init_isObject();
    init_setup();
    init_has();
    init_collectNonEnumProps();
  }
});

// node_modules/underscore/modules/isEmpty.js
function isEmpty(obj2) {
  if (obj2 == null)
    return true;
  var length = getLength_default(obj2);
  if (typeof length == "number" && (isArray_default(obj2) || isString_default(obj2) || isArguments_default(obj2)))
    return length === 0;
  return getLength_default(keys(obj2)) === 0;
}
var init_isEmpty = __esm({
  "node_modules/underscore/modules/isEmpty.js"() {
    init_getLength();
    init_isArray();
    init_isString();
    init_isArguments();
    init_keys();
  }
});

// node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null)
    return !length;
  var obj2 = Object(object2);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj2[key] || !(key in obj2))
      return false;
  }
  return true;
}
var init_isMatch = __esm({
  "node_modules/underscore/modules/isMatch.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/underscore.js
function _(obj2) {
  if (obj2 instanceof _)
    return obj2;
  if (!(this instanceof _))
    return new _(obj2);
  this._wrapped = obj2;
}
var init_underscore = __esm({
  "node_modules/underscore/modules/underscore.js"() {
    init_setup();
    _.VERSION = VERSION;
    _.prototype.value = function() {
      return this._wrapped;
    };
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    _.prototype.toString = function() {
      return String(this._wrapped);
    };
  }
});

// node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}
var init_toBufferView = __esm({
  "node_modules/underscore/modules/_toBufferView.js"() {
    init_getByteLength();
  }
});

// node_modules/underscore/modules/isEqual.js
function eq(a, b, aStack, bStack) {
  if (a === b)
    return a !== 0 || 1 / a === 1 / b;
  if (a == null || b == null)
    return false;
  if (a !== a)
    return b !== b;
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object")
    return false;
  return deepEq(a, b, aStack, bStack);
}
function deepEq(a, b, aStack, bStack) {
  if (a instanceof _)
    a = a._wrapped;
  if (b instanceof _)
    b = b._wrapped;
  var className = toString.call(a);
  if (className !== toString.call(b))
    return false;
  if (hasStringTagBug && className == "[object Object]" && isDataView_default(a)) {
    if (!isDataView_default(b))
      return false;
    className = tagDataView;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a)
        return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a)) {
    var byteLength = getByteLength_default(a);
    if (byteLength !== getByteLength_default(b))
      return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset)
      return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object")
      return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a)
      return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length)
      return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack))
        return false;
    }
  } else {
    var _keys = keys(a), key;
    length = _keys.length;
    if (keys(b).length !== length)
      return false;
    while (length--) {
      key = _keys[length];
      if (!(has(b, key) && eq(a[key], b[key], aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual(a, b) {
  return eq(a, b);
}
var tagDataView;
var init_isEqual = __esm({
  "node_modules/underscore/modules/isEqual.js"() {
    init_underscore();
    init_setup();
    init_getByteLength();
    init_isTypedArray();
    init_isFunction();
    init_stringTagBug();
    init_isDataView();
    init_keys();
    init_has();
    init_toBufferView();
    tagDataView = "[object DataView]";
  }
});

// node_modules/underscore/modules/allKeys.js
function allKeys(obj2) {
  if (!isObject2(obj2))
    return [];
  var keys2 = [];
  for (var key in obj2)
    keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj2, keys2);
  return keys2;
}
var init_allKeys = __esm({
  "node_modules/underscore/modules/allKeys.js"() {
    init_isObject();
    init_setup();
    init_collectNonEnumProps();
  }
});

// node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj2) {
    if (obj2 == null)
      return false;
    var keys2 = allKeys(obj2);
    if (getLength_default(keys2))
      return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction_default(obj2[methods[i]]))
        return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj2[forEachName]);
  };
}
var forEachName, hasName, commonInit, mapTail, mapMethods, weakMapMethods, setMethods;
var init_methodFingerprint = __esm({
  "node_modules/underscore/modules/_methodFingerprint.js"() {
    init_getLength();
    init_isFunction();
    init_allKeys();
    forEachName = "forEach";
    hasName = "has";
    commonInit = ["clear", "delete"];
    mapTail = ["get", hasName, "set"];
    mapMethods = commonInit.concat(forEachName, mapTail);
    weakMapMethods = commonInit.concat(mapTail);
    setMethods = ["add"].concat(commonInit, forEachName, hasName);
  }
});

// node_modules/underscore/modules/isMap.js
var isMap_default;
var init_isMap = __esm({
  "node_modules/underscore/modules/isMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
  }
});

// node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default;
var init_isWeakMap = __esm({
  "node_modules/underscore/modules/isWeakMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
  }
});

// node_modules/underscore/modules/isSet.js
var isSet_default;
var init_isSet = __esm({
  "node_modules/underscore/modules/isSet.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
  }
});

// node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default;
var init_isWeakSet = __esm({
  "node_modules/underscore/modules/isWeakSet.js"() {
    init_tagTester();
    isWeakSet_default = tagTester("WeakSet");
  }
});

// node_modules/underscore/modules/values.js
function values(obj2) {
  var _keys = keys(obj2);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i = 0; i < length; i++) {
    values2[i] = obj2[_keys[i]];
  }
  return values2;
}
var init_values = __esm({
  "node_modules/underscore/modules/values.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/pairs.js
function pairs(obj2) {
  var _keys = keys(obj2);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i = 0; i < length; i++) {
    pairs2[i] = [_keys[i], obj2[_keys[i]]];
  }
  return pairs2;
}
var init_pairs = __esm({
  "node_modules/underscore/modules/pairs.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/invert.js
function invert(obj2) {
  var result2 = {};
  var _keys = keys(obj2);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result2[obj2[_keys[i]]] = _keys[i];
  }
  return result2;
}
var init_invert = __esm({
  "node_modules/underscore/modules/invert.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/functions.js
function functions(obj2) {
  var names = [];
  for (var key in obj2) {
    if (isFunction_default(obj2[key]))
      names.push(key);
  }
  return names.sort();
}
var init_functions = __esm({
  "node_modules/underscore/modules/functions.js"() {
    init_isFunction();
  }
});

// node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults) {
  return function(obj2) {
    var length = arguments.length;
    if (defaults)
      obj2 = Object(obj2);
    if (length < 2 || obj2 == null)
      return obj2;
    for (var index = 1; index < length; index++) {
      var source = arguments[index], keys2 = keysFunc(source), l2 = keys2.length;
      for (var i = 0; i < l2; i++) {
        var key = keys2[i];
        if (!defaults || obj2[key] === void 0)
          obj2[key] = source[key];
      }
    }
    return obj2;
  };
}
var init_createAssigner = __esm({
  "node_modules/underscore/modules/_createAssigner.js"() {
  }
});

// node_modules/underscore/modules/extend.js
var extend_default;
var init_extend = __esm({
  "node_modules/underscore/modules/extend.js"() {
    init_createAssigner();
    init_allKeys();
    extend_default = createAssigner(allKeys);
  }
});

// node_modules/underscore/modules/extendOwn.js
var extendOwn_default;
var init_extendOwn = __esm({
  "node_modules/underscore/modules/extendOwn.js"() {
    init_createAssigner();
    init_keys();
    extendOwn_default = createAssigner(keys);
  }
});

// node_modules/underscore/modules/defaults.js
var defaults_default;
var init_defaults = __esm({
  "node_modules/underscore/modules/defaults.js"() {
    init_createAssigner();
    init_allKeys();
    defaults_default = createAssigner(allKeys, true);
  }
});

// node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject2(prototype))
    return {};
  if (nativeCreate)
    return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
var init_baseCreate = __esm({
  "node_modules/underscore/modules/_baseCreate.js"() {
    init_isObject();
    init_setup();
  }
});

// node_modules/underscore/modules/create.js
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props)
    extendOwn_default(result2, props);
  return result2;
}
var init_create = __esm({
  "node_modules/underscore/modules/create.js"() {
    init_baseCreate();
    init_extendOwn();
  }
});

// node_modules/underscore/modules/clone.js
function clone(obj2) {
  if (!isObject2(obj2))
    return obj2;
  return isArray_default(obj2) ? obj2.slice() : extend_default({}, obj2);
}
var init_clone = __esm({
  "node_modules/underscore/modules/clone.js"() {
    init_isObject();
    init_isArray();
    init_extend();
  }
});

// node_modules/underscore/modules/tap.js
function tap(obj2, interceptor) {
  interceptor(obj2);
  return obj2;
}
var init_tap = __esm({
  "node_modules/underscore/modules/tap.js"() {
  }
});

// node_modules/underscore/modules/toPath.js
function toPath(path) {
  return isArray_default(path) ? path : [path];
}
var init_toPath = __esm({
  "node_modules/underscore/modules/toPath.js"() {
    init_underscore();
    init_isArray();
    _.toPath = toPath;
  }
});

// node_modules/underscore/modules/_toPath.js
function toPath2(path) {
  return _.toPath(path);
}
var init_toPath2 = __esm({
  "node_modules/underscore/modules/_toPath.js"() {
    init_underscore();
    init_toPath();
  }
});

// node_modules/underscore/modules/_deepGet.js
function deepGet(obj2, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj2 == null)
      return void 0;
    obj2 = obj2[path[i]];
  }
  return length ? obj2 : void 0;
}
var init_deepGet = __esm({
  "node_modules/underscore/modules/_deepGet.js"() {
  }
});

// node_modules/underscore/modules/get.js
function get(object2, path, defaultValue) {
  var value = deepGet(object2, toPath2(path));
  return isUndefined(value) ? defaultValue : value;
}
var init_get = __esm({
  "node_modules/underscore/modules/get.js"() {
    init_toPath2();
    init_deepGet();
    init_isUndefined();
  }
});

// node_modules/underscore/modules/has.js
function has2(obj2, path) {
  path = toPath2(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!has(obj2, key))
      return false;
    obj2 = obj2[key];
  }
  return !!length;
}
var init_has2 = __esm({
  "node_modules/underscore/modules/has.js"() {
    init_has();
    init_toPath2();
  }
});

// node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}
var init_identity = __esm({
  "node_modules/underscore/modules/identity.js"() {
  }
});

// node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj2) {
    return isMatch(obj2, attrs);
  };
}
var init_matcher = __esm({
  "node_modules/underscore/modules/matcher.js"() {
    init_extendOwn();
    init_isMatch();
  }
});

// node_modules/underscore/modules/property.js
function property(path) {
  path = toPath2(path);
  return function(obj2) {
    return deepGet(obj2, path);
  };
}
var init_property = __esm({
  "node_modules/underscore/modules/property.js"() {
    init_deepGet();
    init_toPath2();
  }
});

// node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0)
    return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    case 3:
      return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}
var init_optimizeCb = __esm({
  "node_modules/underscore/modules/_optimizeCb.js"() {
  }
});

// node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null)
    return identity;
  if (isFunction_default(value))
    return optimizeCb(value, context, argCount);
  if (isObject2(value) && !isArray_default(value))
    return matcher(value);
  return property(value);
}
var init_baseIteratee = __esm({
  "node_modules/underscore/modules/_baseIteratee.js"() {
    init_identity();
    init_isFunction();
    init_isObject();
    init_isArray();
    init_matcher();
    init_property();
    init_optimizeCb();
  }
});

// node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
var init_iteratee = __esm({
  "node_modules/underscore/modules/iteratee.js"() {
    init_underscore();
    init_baseIteratee();
    _.iteratee = iteratee;
  }
});

// node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee)
    return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}
var init_cb = __esm({
  "node_modules/underscore/modules/_cb.js"() {
    init_underscore();
    init_baseIteratee();
    init_iteratee();
  }
});

// node_modules/underscore/modules/mapObject.js
function mapObject(obj2, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj2), length = _keys.length, results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee2(obj2[currentKey], currentKey, obj2);
  }
  return results;
}
var init_mapObject = __esm({
  "node_modules/underscore/modules/mapObject.js"() {
    init_cb();
    init_keys();
  }
});

// node_modules/underscore/modules/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/underscore/modules/noop.js"() {
  }
});

// node_modules/underscore/modules/propertyOf.js
function propertyOf(obj2) {
  if (obj2 == null)
    return noop;
  return function(path) {
    return get(obj2, path);
  };
}
var init_propertyOf = __esm({
  "node_modules/underscore/modules/propertyOf.js"() {
    init_noop();
    init_get();
  }
});

// node_modules/underscore/modules/times.js
function times(n, iteratee2, context) {
  var accum = Array(Math.max(0, n));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i = 0; i < n; i++)
    accum[i] = iteratee2(i);
  return accum;
}
var init_times = __esm({
  "node_modules/underscore/modules/times.js"() {
    init_optimizeCb();
  }
});

// node_modules/underscore/modules/random.js
function random(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
}
var init_random = __esm({
  "node_modules/underscore/modules/random.js"() {
  }
});

// node_modules/underscore/modules/now.js
var now_default;
var init_now = __esm({
  "node_modules/underscore/modules/now.js"() {
    now_default = Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }
});

// node_modules/underscore/modules/_createEscaper.js
function createEscaper(map2) {
  var escaper = function(match) {
    return map2[match];
  };
  var source = "(?:" + keys(map2).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
var init_createEscaper = __esm({
  "node_modules/underscore/modules/_createEscaper.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/_escapeMap.js
var escapeMap_default;
var init_escapeMap = __esm({
  "node_modules/underscore/modules/_escapeMap.js"() {
    escapeMap_default = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
  }
});

// node_modules/underscore/modules/escape.js
var escape_default;
var init_escape = __esm({
  "node_modules/underscore/modules/escape.js"() {
    init_createEscaper();
    init_escapeMap();
    escape_default = createEscaper(escapeMap_default);
  }
});

// node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default;
var init_unescapeMap = __esm({
  "node_modules/underscore/modules/_unescapeMap.js"() {
    init_invert();
    init_escapeMap();
    unescapeMap_default = invert(escapeMap_default);
  }
});

// node_modules/underscore/modules/unescape.js
var unescape_default;
var init_unescape = __esm({
  "node_modules/underscore/modules/unescape.js"() {
    init_createEscaper();
    init_unescapeMap();
    unescape_default = createEscaper(unescapeMap_default);
  }
});

// node_modules/underscore/modules/templateSettings.js
var templateSettings_default;
var init_templateSettings = __esm({
  "node_modules/underscore/modules/templateSettings.js"() {
    init_underscore();
    templateSettings_default = _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
  }
});

// node_modules/underscore/modules/template.js
function escapeChar(match) {
  return "\\" + escapes[match];
}
function template(text, settings, oldSettings) {
  if (!settings && oldSettings)
    settings = oldSettings;
  settings = defaults_default({}, settings, _.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;
    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument))
      throw new Error(
        "variable is not a bare identifier: " + argument
      );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template2 = function(data) {
    return render.call(this, data, _);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
var noMatch, escapes, escapeRegExp, bareIdentifier;
var init_template = __esm({
  "node_modules/underscore/modules/template.js"() {
    init_defaults();
    init_underscore();
    init_templateSettings();
    noMatch = /(.)^/;
    escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    bareIdentifier = /^\s*(\w|\$)+\s*$/;
  }
});

// node_modules/underscore/modules/result.js
function result(obj2, path, fallback) {
  path = toPath2(path);
  var length = path.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj2) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj2 == null ? void 0 : obj2[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length;
    }
    obj2 = isFunction_default(prop) ? prop.call(obj2) : prop;
  }
  return obj2;
}
var init_result = __esm({
  "node_modules/underscore/modules/result.js"() {
    init_isFunction();
    init_toPath2();
  }
});

// node_modules/underscore/modules/uniqueId.js
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}
var idCounter;
var init_uniqueId = __esm({
  "node_modules/underscore/modules/uniqueId.js"() {
    idCounter = 0;
  }
});

// node_modules/underscore/modules/chain.js
function chain(obj2) {
  var instance = _(obj2);
  instance._chain = true;
  return instance;
}
var init_chain = __esm({
  "node_modules/underscore/modules/chain.js"() {
    init_underscore();
  }
});

// node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc))
    return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject2(result2))
    return result2;
  return self2;
}
var init_executeBound = __esm({
  "node_modules/underscore/modules/_executeBound.js"() {
    init_baseCreate();
    init_isObject();
  }
});

// node_modules/underscore/modules/partial.js
var partial, partial_default;
var init_partial = __esm({
  "node_modules/underscore/modules/partial.js"() {
    init_restArguments();
    init_executeBound();
    init_underscore();
    partial = restArguments(function(func, boundArgs) {
      var placeholder = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length)
          args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });
    partial.placeholder = _;
    partial_default = partial;
  }
});

// node_modules/underscore/modules/bind.js
var bind_default;
var init_bind = __esm({
  "node_modules/underscore/modules/bind.js"() {
    init_restArguments();
    init_isFunction();
    init_executeBound();
    bind_default = restArguments(function(func, context, args) {
      if (!isFunction_default(func))
        throw new TypeError("Bind must be called on a function");
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });
  }
});

// node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default;
var init_isArrayLike = __esm({
  "node_modules/underscore/modules/_isArrayLike.js"() {
    init_createSizePropertyCheck();
    init_getLength();
    isArrayLike_default = createSizePropertyCheck(getLength_default);
  }
});

// node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength_default(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len)
          output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
var init_flatten = __esm({
  "node_modules/underscore/modules/_flatten.js"() {
    init_getLength();
    init_isArrayLike();
    init_isArray();
    init_isArguments();
  }
});

// node_modules/underscore/modules/bindAll.js
var bindAll_default;
var init_bindAll = __esm({
  "node_modules/underscore/modules/bindAll.js"() {
    init_restArguments();
    init_flatten();
    init_bind();
    bindAll_default = restArguments(function(obj2, keys2) {
      keys2 = flatten(keys2, false, false);
      var index = keys2.length;
      if (index < 1)
        throw new Error("bindAll must be passed function names");
      while (index--) {
        var key = keys2[index];
        obj2[key] = bind_default(obj2[key], obj2);
      }
      return obj2;
    });
  }
});

// node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache, address))
      cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}
var init_memoize = __esm({
  "node_modules/underscore/modules/memoize.js"() {
    init_has();
  }
});

// node_modules/underscore/modules/delay.js
var delay_default;
var init_delay = __esm({
  "node_modules/underscore/modules/delay.js"() {
    init_restArguments();
    delay_default = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });
  }
});

// node_modules/underscore/modules/defer.js
var defer_default;
var init_defer = __esm({
  "node_modules/underscore/modules/defer.js"() {
    init_partial();
    init_delay();
    init_underscore();
    defer_default = partial_default(delay_default, _, 1);
  }
});

// node_modules/underscore/modules/throttle.js
function throttle(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function() {
    var _now = now_default();
    if (!previous && options.leading === false)
      previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
var init_throttle = __esm({
  "node_modules/underscore/modules/throttle.js"() {
    init_now();
  }
});

// node_modules/underscore/modules/debounce.js
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate)
        result2 = func.apply(context, args);
      if (!timeout)
        args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate)
        result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}
var init_debounce = __esm({
  "node_modules/underscore/modules/debounce.js"() {
    init_restArguments();
    init_now();
  }
});

// node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}
var init_wrap = __esm({
  "node_modules/underscore/modules/wrap.js"() {
    init_partial();
  }
});

// node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
var init_negate = __esm({
  "node_modules/underscore/modules/negate.js"() {
  }
});

// node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result2 = args[start].apply(this, arguments);
    while (i--)
      result2 = args[i].call(this, result2);
    return result2;
  };
}
var init_compose = __esm({
  "node_modules/underscore/modules/compose.js"() {
  }
});

// node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var init_after = __esm({
  "node_modules/underscore/modules/after.js"() {
  }
});

// node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1)
      func = null;
    return memo;
  };
}
var init_before = __esm({
  "node_modules/underscore/modules/before.js"() {
  }
});

// node_modules/underscore/modules/once.js
var once_default;
var init_once = __esm({
  "node_modules/underscore/modules/once.js"() {
    init_partial();
    init_before();
    once_default = partial_default(before, 2);
  }
});

// node_modules/underscore/modules/findKey.js
function findKey(obj2, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj2), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj2[key], key, obj2))
      return key;
  }
}
var init_findKey = __esm({
  "node_modules/underscore/modules/findKey.js"() {
    init_cb();
    init_keys();
  }
});

// node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array))
        return index;
    }
    return -1;
  };
}
var init_createPredicateIndexFinder = __esm({
  "node_modules/underscore/modules/_createPredicateIndexFinder.js"() {
    init_cb();
    init_getLength();
  }
});

// node_modules/underscore/modules/findIndex.js
var findIndex_default;
var init_findIndex = __esm({
  "node_modules/underscore/modules/findIndex.js"() {
    init_createPredicateIndexFinder();
    findIndex_default = createPredicateIndexFinder(1);
  }
});

// node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default;
var init_findLastIndex = __esm({
  "node_modules/underscore/modules/findLastIndex.js"() {
    init_createPredicateIndexFinder();
    findLastIndex_default = createPredicateIndexFinder(-1);
  }
});

// node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj2, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj2);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value)
      low = mid + 1;
    else
      high = mid;
  }
  return low;
}
var init_sortedIndex = __esm({
  "node_modules/underscore/modules/sortedIndex.js"() {
    init_cb();
    init_getLength();
  }
});

// node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN2);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item)
        return idx;
    }
    return -1;
  };
}
var init_createIndexFinder = __esm({
  "node_modules/underscore/modules/_createIndexFinder.js"() {
    init_getLength();
    init_setup();
    init_isNaN();
  }
});

// node_modules/underscore/modules/indexOf.js
var indexOf_default;
var init_indexOf = __esm({
  "node_modules/underscore/modules/indexOf.js"() {
    init_sortedIndex();
    init_findIndex();
    init_createIndexFinder();
    indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);
  }
});

// node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default;
var init_lastIndexOf = __esm({
  "node_modules/underscore/modules/lastIndexOf.js"() {
    init_findLastIndex();
    init_createIndexFinder();
    lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);
  }
});

// node_modules/underscore/modules/find.js
function find(obj2, predicate, context) {
  var keyFinder = isArrayLike_default(obj2) ? findIndex_default : findKey;
  var key = keyFinder(obj2, predicate, context);
  if (key !== void 0 && key !== -1)
    return obj2[key];
}
var init_find = __esm({
  "node_modules/underscore/modules/find.js"() {
    init_isArrayLike();
    init_findIndex();
    init_findKey();
  }
});

// node_modules/underscore/modules/findWhere.js
function findWhere(obj2, attrs) {
  return find(obj2, matcher(attrs));
}
var init_findWhere = __esm({
  "node_modules/underscore/modules/findWhere.js"() {
    init_find();
    init_matcher();
  }
});

// node_modules/underscore/modules/each.js
function each(obj2, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i, length;
  if (isArrayLike_default(obj2)) {
    for (i = 0, length = obj2.length; i < length; i++) {
      iteratee2(obj2[i], i, obj2);
    }
  } else {
    var _keys = keys(obj2);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee2(obj2[_keys[i]], _keys[i], obj2);
    }
  }
  return obj2;
}
var init_each = __esm({
  "node_modules/underscore/modules/each.js"() {
    init_optimizeCb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/map.js
function map(obj2, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj2) && keys(obj2), length = (_keys || obj2).length, results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee2(obj2[currentKey], currentKey, obj2);
  }
  return results;
}
var init_map = __esm({
  "node_modules/underscore/modules/map.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer = function(obj2, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj2) && keys(obj2), length = (_keys || obj2).length, index = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj2[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee2(memo, obj2[currentKey], currentKey, obj2);
    }
    return memo;
  };
  return function(obj2, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer(obj2, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}
var init_createReduce = __esm({
  "node_modules/underscore/modules/_createReduce.js"() {
    init_isArrayLike();
    init_keys();
    init_optimizeCb();
  }
});

// node_modules/underscore/modules/reduce.js
var reduce_default;
var init_reduce = __esm({
  "node_modules/underscore/modules/reduce.js"() {
    init_createReduce();
    reduce_default = createReduce(1);
  }
});

// node_modules/underscore/modules/reduceRight.js
var reduceRight_default;
var init_reduceRight = __esm({
  "node_modules/underscore/modules/reduceRight.js"() {
    init_createReduce();
    reduceRight_default = createReduce(-1);
  }
});

// node_modules/underscore/modules/filter.js
function filter(obj2, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj2, function(value, index, list) {
    if (predicate(value, index, list))
      results.push(value);
  });
  return results;
}
var init_filter = __esm({
  "node_modules/underscore/modules/filter.js"() {
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/reject.js
function reject(obj2, predicate, context) {
  return filter(obj2, negate(cb(predicate)), context);
}
var init_reject = __esm({
  "node_modules/underscore/modules/reject.js"() {
    init_filter();
    init_negate();
    init_cb();
  }
});

// node_modules/underscore/modules/every.js
function every(obj2, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj2) && keys(obj2), length = (_keys || obj2).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj2[currentKey], currentKey, obj2))
      return false;
  }
  return true;
}
var init_every = __esm({
  "node_modules/underscore/modules/every.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/some.js
function some(obj2, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj2) && keys(obj2), length = (_keys || obj2).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj2[currentKey], currentKey, obj2))
      return true;
  }
  return false;
}
var init_some = __esm({
  "node_modules/underscore/modules/some.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/contains.js
function contains(obj2, item, fromIndex, guard) {
  if (!isArrayLike_default(obj2))
    obj2 = values(obj2);
  if (typeof fromIndex != "number" || guard)
    fromIndex = 0;
  return indexOf_default(obj2, item, fromIndex) >= 0;
}
var init_contains = __esm({
  "node_modules/underscore/modules/contains.js"() {
    init_isArrayLike();
    init_values();
    init_indexOf();
  }
});

// node_modules/underscore/modules/invoke.js
var invoke_default;
var init_invoke = __esm({
  "node_modules/underscore/modules/invoke.js"() {
    init_restArguments();
    init_isFunction();
    init_map();
    init_deepGet();
    init_toPath2();
    invoke_default = restArguments(function(obj2, path, args) {
      var contextPath, func;
      if (isFunction_default(path)) {
        func = path;
      } else {
        path = toPath2(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return map(obj2, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null)
            return void 0;
          method = context[path];
        }
        return method == null ? method : method.apply(context, args);
      });
    });
  }
});

// node_modules/underscore/modules/pluck.js
function pluck(obj2, key) {
  return map(obj2, property(key));
}
var init_pluck = __esm({
  "node_modules/underscore/modules/pluck.js"() {
    init_map();
    init_property();
  }
});

// node_modules/underscore/modules/where.js
function where(obj2, attrs) {
  return filter(obj2, matcher(attrs));
}
var init_where = __esm({
  "node_modules/underscore/modules/where.js"() {
    init_filter();
    init_matcher();
  }
});

// node_modules/underscore/modules/max.js
function max(obj2, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj2[0] != "object" && obj2 != null) {
    obj2 = isArrayLike_default(obj2) ? obj2 : values(obj2);
    for (var i = 0, length = obj2.length; i < length; i++) {
      value = obj2[i];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj2, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_max = __esm({
  "node_modules/underscore/modules/max.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/min.js
function min(obj2, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj2[0] != "object" && obj2 != null) {
    obj2 = isArrayLike_default(obj2) ? obj2 : values(obj2);
    for (var i = 0, length = obj2.length; i < length; i++) {
      value = obj2[i];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj2, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_min = __esm({
  "node_modules/underscore/modules/min.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/toArray.js
function toArray(obj2) {
  if (!obj2)
    return [];
  if (isArray_default(obj2))
    return slice.call(obj2);
  if (isString_default(obj2)) {
    return obj2.match(reStrSymbol);
  }
  if (isArrayLike_default(obj2))
    return map(obj2, identity);
  return values(obj2);
}
var reStrSymbol;
var init_toArray = __esm({
  "node_modules/underscore/modules/toArray.js"() {
    init_isArray();
    init_setup();
    init_isString();
    init_isArrayLike();
    init_map();
    init_identity();
    init_values();
    reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  }
});

// node_modules/underscore/modules/sample.js
function sample(obj2, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike_default(obj2))
      obj2 = values(obj2);
    return obj2[random(obj2.length - 1)];
  }
  var sample2 = toArray(obj2);
  var length = getLength_default(sample2);
  n = Math.max(Math.min(n, length), 0);
  var last2 = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last2);
    var temp = sample2[index];
    sample2[index] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n);
}
var init_sample = __esm({
  "node_modules/underscore/modules/sample.js"() {
    init_isArrayLike();
    init_values();
    init_getLength();
    init_random();
    init_toArray();
  }
});

// node_modules/underscore/modules/shuffle.js
function shuffle(obj2) {
  return sample(obj2, Infinity);
}
var init_shuffle = __esm({
  "node_modules/underscore/modules/shuffle.js"() {
    init_sample();
  }
});

// node_modules/underscore/modules/sortBy.js
function sortBy(obj2, iteratee2, context) {
  var index = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map(obj2, function(value, key, list) {
    return {
      value,
      index: index++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0)
        return 1;
      if (a < b || b === void 0)
        return -1;
    }
    return left.index - right.index;
  }), "value");
}
var init_sortBy = __esm({
  "node_modules/underscore/modules/sortBy.js"() {
    init_cb();
    init_pluck();
    init_map();
  }
});

// node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj2, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each(obj2, function(value, index) {
      var key = iteratee2(value, index, obj2);
      behavior(result2, value, key);
    });
    return result2;
  };
}
var init_group = __esm({
  "node_modules/underscore/modules/_group.js"() {
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/groupBy.js
var groupBy_default;
var init_groupBy = __esm({
  "node_modules/underscore/modules/groupBy.js"() {
    init_group();
    init_has();
    groupBy_default = group(function(result2, value, key) {
      if (has(result2, key))
        result2[key].push(value);
      else
        result2[key] = [value];
    });
  }
});

// node_modules/underscore/modules/indexBy.js
var indexBy_default;
var init_indexBy = __esm({
  "node_modules/underscore/modules/indexBy.js"() {
    init_group();
    indexBy_default = group(function(result2, value, key) {
      result2[key] = value;
    });
  }
});

// node_modules/underscore/modules/countBy.js
var countBy_default;
var init_countBy = __esm({
  "node_modules/underscore/modules/countBy.js"() {
    init_group();
    init_has();
    countBy_default = group(function(result2, value, key) {
      if (has(result2, key))
        result2[key]++;
      else
        result2[key] = 1;
    });
  }
});

// node_modules/underscore/modules/partition.js
var partition_default;
var init_partition = __esm({
  "node_modules/underscore/modules/partition.js"() {
    init_group();
    partition_default = group(function(result2, value, pass) {
      result2[pass ? 0 : 1].push(value);
    }, true);
  }
});

// node_modules/underscore/modules/size.js
function size(obj2) {
  if (obj2 == null)
    return 0;
  return isArrayLike_default(obj2) ? obj2.length : keys(obj2).length;
}
var init_size = __esm({
  "node_modules/underscore/modules/size.js"() {
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj2) {
  return key in obj2;
}
var init_keyInObj = __esm({
  "node_modules/underscore/modules/_keyInObj.js"() {
  }
});

// node_modules/underscore/modules/pick.js
var pick_default;
var init_pick = __esm({
  "node_modules/underscore/modules/pick.js"() {
    init_restArguments();
    init_isFunction();
    init_optimizeCb();
    init_allKeys();
    init_keyInObj();
    init_flatten();
    pick_default = restArguments(function(obj2, keys2) {
      var result2 = {}, iteratee2 = keys2[0];
      if (obj2 == null)
        return result2;
      if (isFunction_default(iteratee2)) {
        if (keys2.length > 1)
          iteratee2 = optimizeCb(iteratee2, keys2[1]);
        keys2 = allKeys(obj2);
      } else {
        iteratee2 = keyInObj;
        keys2 = flatten(keys2, false, false);
        obj2 = Object(obj2);
      }
      for (var i = 0, length = keys2.length; i < length; i++) {
        var key = keys2[i];
        var value = obj2[key];
        if (iteratee2(value, key, obj2))
          result2[key] = value;
      }
      return result2;
    });
  }
});

// node_modules/underscore/modules/omit.js
var omit_default;
var init_omit = __esm({
  "node_modules/underscore/modules/omit.js"() {
    init_restArguments();
    init_isFunction();
    init_negate();
    init_map();
    init_flatten();
    init_contains();
    init_pick();
    omit_default = restArguments(function(obj2, keys2) {
      var iteratee2 = keys2[0], context;
      if (isFunction_default(iteratee2)) {
        iteratee2 = negate(iteratee2);
        if (keys2.length > 1)
          context = keys2[1];
      } else {
        keys2 = map(flatten(keys2, false, false), String);
        iteratee2 = function(value, key) {
          return !contains(keys2, key);
        };
      }
      return pick_default(obj2, iteratee2, context);
    });
  }
});

// node_modules/underscore/modules/initial.js
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}
var init_initial = __esm({
  "node_modules/underscore/modules/initial.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/first.js
function first(array, n, guard) {
  if (array == null || array.length < 1)
    return n == null || guard ? void 0 : [];
  if (n == null || guard)
    return array[0];
  return initial(array, array.length - n);
}
var init_first = __esm({
  "node_modules/underscore/modules/first.js"() {
    init_initial();
  }
});

// node_modules/underscore/modules/rest.js
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}
var init_rest = __esm({
  "node_modules/underscore/modules/rest.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/last.js
function last(array, n, guard) {
  if (array == null || array.length < 1)
    return n == null || guard ? void 0 : [];
  if (n == null || guard)
    return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}
var init_last = __esm({
  "node_modules/underscore/modules/last.js"() {
    init_rest();
  }
});

// node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}
var init_compact = __esm({
  "node_modules/underscore/modules/compact.js"() {
    init_filter();
  }
});

// node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}
var init_flatten2 = __esm({
  "node_modules/underscore/modules/flatten.js"() {
    init_flatten();
  }
});

// node_modules/underscore/modules/difference.js
var difference_default;
var init_difference = __esm({
  "node_modules/underscore/modules/difference.js"() {
    init_restArguments();
    init_flatten();
    init_filter();
    init_contains();
    difference_default = restArguments(function(array, rest2) {
      rest2 = flatten(rest2, true, true);
      return filter(array, function(value) {
        return !contains(rest2, value);
      });
    });
  }
});

// node_modules/underscore/modules/without.js
var without_default;
var init_without = __esm({
  "node_modules/underscore/modules/without.js"() {
    init_restArguments();
    init_difference();
    without_default = restArguments(function(array, otherArrays) {
      return difference_default(array, otherArrays);
    });
  }
});

// node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null)
    iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var value = array[i], computed = iteratee2 ? iteratee2(value, i, array) : value;
    if (isSorted && !iteratee2) {
      if (!i || seen !== computed)
        result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
var init_uniq = __esm({
  "node_modules/underscore/modules/uniq.js"() {
    init_isBoolean();
    init_cb();
    init_getLength();
    init_contains();
  }
});

// node_modules/underscore/modules/union.js
var union_default;
var init_union = __esm({
  "node_modules/underscore/modules/union.js"() {
    init_restArguments();
    init_uniq();
    init_flatten();
    union_default = restArguments(function(arrays) {
      return uniq(flatten(arrays, true, true));
    });
  }
});

// node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var item = array[i];
    if (contains(result2, item))
      continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item))
        break;
    }
    if (j === argsLength)
      result2.push(item);
  }
  return result2;
}
var init_intersection = __esm({
  "node_modules/underscore/modules/intersection.js"() {
    init_getLength();
    init_contains();
  }
});

// node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index = 0; index < length; index++) {
    result2[index] = pluck(array, index);
  }
  return result2;
}
var init_unzip = __esm({
  "node_modules/underscore/modules/unzip.js"() {
    init_max();
    init_getLength();
    init_pluck();
  }
});

// node_modules/underscore/modules/zip.js
var zip_default;
var init_zip = __esm({
  "node_modules/underscore/modules/zip.js"() {
    init_restArguments();
    init_unzip();
    zip_default = restArguments(unzip);
  }
});

// node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i = 0, length = getLength_default(list); i < length; i++) {
    if (values2) {
      result2[list[i]] = values2[i];
    } else {
      result2[list[i][0]] = list[i][1];
    }
  }
  return result2;
}
var init_object = __esm({
  "node_modules/underscore/modules/object.js"() {
    init_getLength();
  }
});

// node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
var init_range = __esm({
  "node_modules/underscore/modules/range.js"() {
  }
});

// node_modules/underscore/modules/chunk.js
function chunk(array, count) {
  if (count == null || count < 1)
    return [];
  var result2 = [];
  var i = 0, length = array.length;
  while (i < length) {
    result2.push(slice.call(array, i, i += count));
  }
  return result2;
}
var init_chunk = __esm({
  "node_modules/underscore/modules/chunk.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj2) {
  return instance._chain ? _(obj2).chain() : obj2;
}
var init_chainResult = __esm({
  "node_modules/underscore/modules/_chainResult.js"() {
    init_underscore();
  }
});

// node_modules/underscore/modules/mixin.js
function mixin(obj2) {
  each(functions(obj2), function(name) {
    var func = _[name] = obj2[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}
var init_mixin = __esm({
  "node_modules/underscore/modules/mixin.js"() {
    init_underscore();
    init_each();
    init_functions();
    init_setup();
    init_chainResult();
  }
});

// node_modules/underscore/modules/underscore-array-methods.js
var underscore_array_methods_default;
var init_underscore_array_methods = __esm({
  "node_modules/underscore/modules/underscore-array-methods.js"() {
    init_underscore();
    init_each();
    init_setup();
    init_chainResult();
    each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj2 = this._wrapped;
        if (obj2 != null) {
          method.apply(obj2, arguments);
          if ((name === "shift" || name === "splice") && obj2.length === 0) {
            delete obj2[0];
          }
        }
        return chainResult(this, obj2);
      };
    });
    each(["concat", "join", "slice"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj2 = this._wrapped;
        if (obj2 != null)
          obj2 = method.apply(obj2, arguments);
        return chainResult(this, obj2);
      };
    });
    underscore_array_methods_default = _;
  }
});

// node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject2,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_modules = __esm({
  "node_modules/underscore/modules/index.js"() {
    init_setup();
    init_restArguments();
    init_isObject();
    init_isNull();
    init_isUndefined();
    init_isBoolean();
    init_isElement();
    init_isString();
    init_isNumber();
    init_isDate();
    init_isRegExp();
    init_isError();
    init_isSymbol();
    init_isArrayBuffer();
    init_isDataView();
    init_isArray();
    init_isFunction();
    init_isArguments();
    init_isFinite();
    init_isNaN();
    init_isTypedArray();
    init_isEmpty();
    init_isMatch();
    init_isEqual();
    init_isMap();
    init_isWeakMap();
    init_isSet();
    init_isWeakSet();
    init_keys();
    init_allKeys();
    init_values();
    init_pairs();
    init_invert();
    init_functions();
    init_extend();
    init_extendOwn();
    init_defaults();
    init_create();
    init_clone();
    init_tap();
    init_get();
    init_has2();
    init_mapObject();
    init_identity();
    init_constant();
    init_noop();
    init_toPath();
    init_property();
    init_propertyOf();
    init_matcher();
    init_times();
    init_random();
    init_now();
    init_escape();
    init_unescape();
    init_templateSettings();
    init_template();
    init_result();
    init_uniqueId();
    init_chain();
    init_iteratee();
    init_partial();
    init_bind();
    init_bindAll();
    init_memoize();
    init_delay();
    init_defer();
    init_throttle();
    init_debounce();
    init_wrap();
    init_negate();
    init_compose();
    init_after();
    init_before();
    init_once();
    init_findKey();
    init_findIndex();
    init_findLastIndex();
    init_sortedIndex();
    init_indexOf();
    init_lastIndexOf();
    init_find();
    init_findWhere();
    init_each();
    init_map();
    init_reduce();
    init_reduceRight();
    init_filter();
    init_reject();
    init_every();
    init_some();
    init_contains();
    init_invoke();
    init_pluck();
    init_where();
    init_max();
    init_min();
    init_shuffle();
    init_sample();
    init_sortBy();
    init_groupBy();
    init_indexBy();
    init_countBy();
    init_partition();
    init_toArray();
    init_size();
    init_pick();
    init_omit();
    init_first();
    init_initial();
    init_last();
    init_rest();
    init_compact();
    init_flatten2();
    init_without();
    init_uniq();
    init_union();
    init_intersection();
    init_difference();
    init_unzip();
    init_zip();
    init_object();
    init_range();
    init_chunk();
    init_mixin();
    init_underscore_array_methods();
  }
});

// node_modules/underscore/modules/index-default.js
var _2, index_default_default;
var init_index_default = __esm({
  "node_modules/underscore/modules/index-default.js"() {
    init_modules();
    init_modules();
    _2 = mixin(modules_exports);
    _2._ = _2;
    index_default_default = _2;
  }
});

// node_modules/underscore/modules/index-all.js
var index_all_exports = {};
__export(index_all_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => index_default_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject2,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_index_all = __esm({
  "node_modules/underscore/modules/index-all.js"() {
    init_index_default();
    init_modules();
  }
});

// node_modules/pkghub/node_modules/bluebird/js/browser/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/pkghub/node_modules/bluebird/js/browser/bluebird.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f2;
        "undefined" != typeof window ? f2 = window : "undefined" != typeof global ? f2 = global : "undefined" != typeof self && (f2 = self), f2.Promise = e();
      }
    }(function() {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f2 = new Error("Cannot find module '" + o2 + "'");
              throw f2.code = "MODULE_NOT_FOUND", f2;
            }
            var l2 = n[o2] = { exports: {} };
            t[o2][0].call(l2.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l2, l2.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var SomePromiseArray = Promise2._SomePromiseArray;
          function any(promises) {
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(1);
            ret2.setUnwrap();
            ret2.init();
            return promise;
          }
          Promise2.any = function(promises) {
            return any(promises);
          };
          Promise2.prototype.any = function() {
            return any(this);
          };
        };
      }, {}], 2: [function(_dereq_2, module2, exports2) {
        "use strict";
        var firstLineError;
        try {
          throw new Error();
        } catch (e) {
          firstLineError = e;
        }
        var schedule = _dereq_2("./schedule.js");
        var Queue = _dereq_2("./queue.js");
        var util = _dereq_2("./util.js");
        function Async() {
          this._isTickUsed = false;
          this._lateQueue = new Queue(16);
          this._normalQueue = new Queue(16);
          this._trampolineEnabled = true;
          var self2 = this;
          this.drainQueues = function() {
            self2._drainQueues();
          };
          this._schedule = schedule.isStatic ? schedule(this.drainQueues) : schedule;
        }
        Async.prototype.disableTrampolineIfNecessary = function() {
          if (util.hasDevTools) {
            this._trampolineEnabled = false;
          }
        };
        Async.prototype.enableTrampoline = function() {
          if (!this._trampolineEnabled) {
            this._trampolineEnabled = true;
            this._schedule = function(fn) {
              setTimeout(fn, 0);
            };
          }
        };
        Async.prototype.haveItemsQueued = function() {
          return this._normalQueue.length() > 0;
        };
        Async.prototype.throwLater = function(fn, arg) {
          if (arguments.length === 1) {
            arg = fn;
            fn = function() {
              throw arg;
            };
          }
          if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
              fn(arg);
            }, 0);
          } else
            try {
              this._schedule(function() {
                fn(arg);
              });
            } catch (e) {
              throw new Error("No async scheduler available\n\n    See http://goo.gl/m3OTXk\n");
            }
        };
        function AsyncInvokeLater(fn, receiver, arg) {
          this._lateQueue.push(fn, receiver, arg);
          this._queueTick();
        }
        function AsyncInvoke(fn, receiver, arg) {
          this._normalQueue.push(fn, receiver, arg);
          this._queueTick();
        }
        function AsyncSettlePromises(promise) {
          this._normalQueue._pushOne(promise);
          this._queueTick();
        }
        if (!util.hasDevTools) {
          Async.prototype.invokeLater = AsyncInvokeLater;
          Async.prototype.invoke = AsyncInvoke;
          Async.prototype.settlePromises = AsyncSettlePromises;
        } else {
          if (schedule.isStatic) {
            schedule = function(fn) {
              setTimeout(fn, 0);
            };
          }
          Async.prototype.invokeLater = function(fn, receiver, arg) {
            if (this._trampolineEnabled) {
              AsyncInvokeLater.call(this, fn, receiver, arg);
            } else {
              this._schedule(function() {
                setTimeout(function() {
                  fn.call(receiver, arg);
                }, 100);
              });
            }
          };
          Async.prototype.invoke = function(fn, receiver, arg) {
            if (this._trampolineEnabled) {
              AsyncInvoke.call(this, fn, receiver, arg);
            } else {
              this._schedule(function() {
                fn.call(receiver, arg);
              });
            }
          };
          Async.prototype.settlePromises = function(promise) {
            if (this._trampolineEnabled) {
              AsyncSettlePromises.call(this, promise);
            } else {
              this._schedule(function() {
                promise._settlePromises();
              });
            }
          };
        }
        Async.prototype.invokeFirst = function(fn, receiver, arg) {
          this._normalQueue.unshift(fn, receiver, arg);
          this._queueTick();
        };
        Async.prototype._drainQueue = function(queue) {
          while (queue.length() > 0) {
            var fn = queue.shift();
            if (typeof fn !== "function") {
              fn._settlePromises();
              continue;
            }
            var receiver = queue.shift();
            var arg = queue.shift();
            fn.call(receiver, arg);
          }
        };
        Async.prototype._drainQueues = function() {
          this._drainQueue(this._normalQueue);
          this._reset();
          this._drainQueue(this._lateQueue);
        };
        Async.prototype._queueTick = function() {
          if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
          }
        };
        Async.prototype._reset = function() {
          this._isTickUsed = false;
        };
        module2.exports = new Async();
        module2.exports.firstLineError = firstLineError;
      }, { "./queue.js": 28, "./schedule.js": 31, "./util.js": 38 }], 3: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise) {
          var rejectThis = function(_3, e) {
            this._reject(e);
          };
          var targetRejected = function(e, context) {
            context.promiseRejectionQueued = true;
            context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
          };
          var bindingResolved = function(thisArg, context) {
            if (this._isPending()) {
              this._resolveCallback(context.target);
            }
          };
          var bindingRejected = function(e, context) {
            if (!context.promiseRejectionQueued)
              this._reject(e);
          };
          Promise2.prototype.bind = function(thisArg) {
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._propagateFrom(this, 1);
            var target = this._target();
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              var context = {
                promiseRejectionQueued: false,
                promise: ret2,
                target,
                bindingPromise: maybePromise
              };
              target._then(INTERNAL, targetRejected, ret2._progress, ret2, context);
              maybePromise._then(
                bindingResolved,
                bindingRejected,
                ret2._progress,
                ret2,
                context
              );
            } else {
              ret2._resolveCallback(target);
            }
            return ret2;
          };
          Promise2.prototype._setBoundTo = function(obj2) {
            if (obj2 !== void 0) {
              this._bitField = this._bitField | 131072;
              this._boundTo = obj2;
            } else {
              this._bitField = this._bitField & ~131072;
            }
          };
          Promise2.prototype._isBound = function() {
            return (this._bitField & 131072) === 131072;
          };
          Promise2.bind = function(thisArg, value) {
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              maybePromise._then(function() {
                ret2._resolveCallback(value);
              }, ret2._reject, ret2._progress, ret2, null);
            } else {
              ret2._resolveCallback(value);
            }
            return ret2;
          };
        };
      }, {}], 4: [function(_dereq_2, module2, exports2) {
        "use strict";
        var old;
        if (typeof Promise !== "undefined")
          old = Promise;
        function noConflict() {
          try {
            if (Promise === bluebird)
              Promise = old;
          } catch (e) {
          }
          return bluebird;
        }
        var bluebird = _dereq_2("./promise.js")();
        bluebird.noConflict = noConflict;
        module2.exports = bluebird;
      }, { "./promise.js": 23 }], 5: [function(_dereq_2, module2, exports2) {
        "use strict";
        var cr = Object.create;
        if (cr) {
          var callerCache = cr(null);
          var getterCache = cr(null);
          callerCache[" size"] = getterCache[" size"] = 0;
        }
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util.js");
          var canEvaluate2 = util.canEvaluate;
          var isIdentifier2 = util.isIdentifier;
          var getMethodCaller;
          var getGetter;
          if (false) {
            var makeMethodCaller = function(methodName) {
              return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
            };
            var makeGetter = function(propertyName) {
              return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
            };
            var getCompiled = function(name, compiler, cache) {
              var ret2 = cache[name];
              if (typeof ret2 !== "function") {
                if (!isIdentifier2(name)) {
                  return null;
                }
                ret2 = compiler(name);
                cache[name] = ret2;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                  var keys2 = Object.keys(cache);
                  for (var i = 0; i < 256; ++i)
                    delete cache[keys2[i]];
                  cache[" size"] = keys2.length - 256;
                }
              }
              return ret2;
            };
            getMethodCaller = function(name) {
              return getCompiled(name, makeMethodCaller, callerCache);
            };
            getGetter = function(name) {
              return getCompiled(name, makeGetter, getterCache);
            };
          }
          function ensureMethod(obj2, methodName) {
            var fn;
            if (obj2 != null)
              fn = obj2[methodName];
            if (typeof fn !== "function") {
              var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
              throw new Promise2.TypeError(message);
            }
            return fn;
          }
          function caller(obj2) {
            var methodName = this.pop();
            var fn = ensureMethod(obj2, methodName);
            return fn.apply(obj2, this);
          }
          Promise2.prototype.call = function(methodName) {
            var $_len = arguments.length;
            var args = new Array($_len - 1);
            for (var $_i = 1; $_i < $_len; ++$_i) {
              args[$_i - 1] = arguments[$_i];
            }
            if (false) {
              if (canEvaluate2) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                  return this._then(
                    maybeCaller,
                    void 0,
                    void 0,
                    args,
                    void 0
                  );
                }
              }
            }
            args.push(methodName);
            return this._then(caller, void 0, void 0, args, void 0);
          };
          function namedGetter(obj2) {
            return obj2[this];
          }
          function indexedGetter(obj2) {
            var index = +this;
            if (index < 0)
              index = Math.max(0, index + obj2.length);
            return obj2[index];
          }
          Promise2.prototype.get = function(propertyName) {
            var isIndex = typeof propertyName === "number";
            var getter;
            if (!isIndex) {
              if (canEvaluate2) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
              } else {
                getter = namedGetter;
              }
            } else {
              getter = indexedGetter;
            }
            return this._then(getter, void 0, void 0, propertyName, void 0);
          };
        };
      }, { "./util.js": 38 }], 6: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var errors = _dereq_2("./errors.js");
          var async = _dereq_2("./async.js");
          var CancellationError = errors.CancellationError;
          Promise2.prototype._cancel = function(reason) {
            if (!this.isCancellable())
              return this;
            var parent;
            var promiseToReject = this;
            while ((parent = promiseToReject._cancellationParent) !== void 0 && parent.isCancellable()) {
              promiseToReject = parent;
            }
            this._unsetCancellable();
            promiseToReject._target()._rejectCallback(reason, false, true);
          };
          Promise2.prototype.cancel = function(reason) {
            if (!this.isCancellable())
              return this;
            if (reason === void 0)
              reason = new CancellationError();
            async.invokeLater(this._cancel, this, reason);
            return this;
          };
          Promise2.prototype.cancellable = function() {
            if (this._cancellable())
              return this;
            async.enableTrampoline();
            this._setCancellable();
            this._cancellationParent = void 0;
            return this;
          };
          Promise2.prototype.uncancellable = function() {
            var ret2 = this.then();
            ret2._unsetCancellable();
            return ret2;
          };
          Promise2.prototype.fork = function(didFulfill, didReject, didProgress) {
            var ret2 = this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
            ret2._setCancellable();
            ret2._cancellationParent = void 0;
            return ret2;
          };
        };
      }, { "./async.js": 2, "./errors.js": 13 }], 7: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
          var stackFramePattern = null;
          var formatStack = null;
          var indentStackFrames = false;
          var warn;
          function CapturedTrace(parent) {
            this._parent = parent;
            var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
            captureStackTrace(this, CapturedTrace);
            if (length > 32)
              this.uncycle();
          }
          util.inherits(CapturedTrace, Error);
          CapturedTrace.prototype.uncycle = function() {
            var length = this._length;
            if (length < 2)
              return;
            var nodes = [];
            var stackToIndex = {};
            for (var i = 0, node = this; node !== void 0; ++i) {
              nodes.push(node);
              node = node._parent;
            }
            length = this._length = i;
            for (var i = length - 1; i >= 0; --i) {
              var stack = nodes[i].stack;
              if (stackToIndex[stack] === void 0) {
                stackToIndex[stack] = i;
              }
            }
            for (var i = 0; i < length; ++i) {
              var currentStack = nodes[i].stack;
              var index = stackToIndex[currentStack];
              if (index !== void 0 && index !== i) {
                if (index > 0) {
                  nodes[index - 1]._parent = void 0;
                  nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = void 0;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                if (index < length - 1) {
                  cycleEdgeNode._parent = nodes[index + 1];
                  cycleEdgeNode._parent.uncycle();
                  cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                  cycleEdgeNode._parent = void 0;
                  cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                  nodes[j]._length = currentChildLength;
                  currentChildLength++;
                }
                return;
              }
            }
          };
          CapturedTrace.prototype.parent = function() {
            return this._parent;
          };
          CapturedTrace.prototype.hasParent = function() {
            return this._parent !== void 0;
          };
          CapturedTrace.prototype.attachExtraTrace = function(error) {
            if (error.__stackCleaned__)
              return;
            this.uncycle();
            var parsed = CapturedTrace.parseStackAndMessage(error);
            var message = parsed.message;
            var stacks = [parsed.stack];
            var trace = this;
            while (trace !== void 0) {
              stacks.push(cleanStack(trace.stack.split("\n")));
              trace = trace._parent;
            }
            removeCommonRoots(stacks);
            removeDuplicateOrEmptyJumps(stacks);
            util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
            util.notEnumerableProp(error, "__stackCleaned__", true);
          };
          function reconstructStack(message, stacks) {
            for (var i = 0; i < stacks.length - 1; ++i) {
              stacks[i].push("From previous event:");
              stacks[i] = stacks[i].join("\n");
            }
            if (i < stacks.length) {
              stacks[i] = stacks[i].join("\n");
            }
            return message + "\n" + stacks.join("\n");
          }
          function removeDuplicateOrEmptyJumps(stacks) {
            for (var i = 0; i < stacks.length; ++i) {
              if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
              }
            }
          }
          function removeCommonRoots(stacks) {
            var current = stacks[0];
            for (var i = 1; i < stacks.length; ++i) {
              var prev = stacks[i];
              var currentLastIndex = current.length - 1;
              var currentLastLine = current[currentLastIndex];
              var commonRootMeetPoint = -1;
              for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                  commonRootMeetPoint = j;
                  break;
                }
              }
              for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                  current.pop();
                  currentLastIndex--;
                } else {
                  break;
                }
              }
              current = prev;
            }
          }
          function cleanStack(stack) {
            var ret2 = [];
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              var isTraceLine = stackFramePattern.test(line) || "    (No stack trace)" === line;
              var isInternalFrame = isTraceLine && shouldIgnore(line);
              if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                  line = "    " + line;
                }
                ret2.push(line);
              }
            }
            return ret2;
          }
          function stackFramesAsArray(error) {
            var stack = error.stack.replace(/\s+$/g, "").split("\n");
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
              }
            }
            if (i > 0) {
              stack = stack.slice(i);
            }
            return stack;
          }
          CapturedTrace.parseStackAndMessage = function(error) {
            var stack = error.stack;
            var message = error.toString();
            stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
            return {
              message,
              stack: cleanStack(stack)
            };
          };
          CapturedTrace.formatAndLogError = function(error, title) {
            if (typeof console !== "undefined") {
              var message;
              if (typeof error === "object" || typeof error === "function") {
                var stack = error.stack;
                message = title + formatStack(stack, error);
              } else {
                message = title + String(error);
              }
              if (typeof warn === "function") {
                warn(message);
              } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
              }
            }
          };
          CapturedTrace.unhandledRejection = function(reason) {
            CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
          };
          CapturedTrace.isSupported = function() {
            return typeof captureStackTrace === "function";
          };
          CapturedTrace.fireRejectionEvent = function(name, localHandler, reason, promise) {
            var localEventFired = false;
            try {
              if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                  localHandler(promise);
                } else {
                  localHandler(reason, promise);
                }
              }
            } catch (e) {
              async.throwLater(e);
            }
            var globalEventFired = false;
            try {
              globalEventFired = fireGlobalEvent(name, reason, promise);
            } catch (e) {
              globalEventFired = true;
              async.throwLater(e);
            }
            var domEventFired = false;
            if (fireDomEvent) {
              try {
                domEventFired = fireDomEvent(name.toLowerCase(), {
                  reason,
                  promise
                });
              } catch (e) {
                domEventFired = true;
                async.throwLater(e);
              }
            }
            if (!globalEventFired && !localEventFired && !domEventFired && name === "unhandledRejection") {
              CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
            }
          };
          function formatNonError(obj2) {
            var str;
            if (typeof obj2 === "function") {
              str = "[function " + (obj2.name || "anonymous") + "]";
            } else {
              str = obj2.toString();
              var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
              if (ruselessToString.test(str)) {
                try {
                  var newStr = JSON.stringify(obj2);
                  str = newStr;
                } catch (e) {
                }
              }
              if (str.length === 0) {
                str = "(empty array)";
              }
            }
            return "(<" + snip(str) + ">, no stack trace)";
          }
          function snip(str) {
            var maxChars = 41;
            if (str.length < maxChars) {
              return str;
            }
            return str.substr(0, maxChars - 3) + "...";
          }
          var shouldIgnore = function() {
            return false;
          };
          var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function parseLineInfo(line) {
            var matches = line.match(parseLineInfoRegex);
            if (matches) {
              return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
              };
            }
          }
          CapturedTrace.setBounds = function(firstLineError, lastLineError) {
            if (!CapturedTrace.isSupported())
              return;
            var firstStackLines = firstLineError.stack.split("\n");
            var lastStackLines = lastLineError.stack.split("\n");
            var firstIndex = -1;
            var lastIndex = -1;
            var firstFileName;
            var lastFileName;
            for (var i = 0; i < firstStackLines.length; ++i) {
              var result2 = parseLineInfo(firstStackLines[i]);
              if (result2) {
                firstFileName = result2.fileName;
                firstIndex = result2.line;
                break;
              }
            }
            for (var i = 0; i < lastStackLines.length; ++i) {
              var result2 = parseLineInfo(lastStackLines[i]);
              if (result2) {
                lastFileName = result2.fileName;
                lastIndex = result2.line;
                break;
              }
            }
            if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
              return;
            }
            shouldIgnore = function(line) {
              if (bluebirdFramePattern.test(line))
                return true;
              var info = parseLineInfo(line);
              if (info) {
                if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                  return true;
                }
              }
              return false;
            };
          };
          var captureStackTrace = function stackDetection() {
            var v8stackFramePattern = /^\s*at\s*/;
            var v8stackFormatter = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if (error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
              Error.stackTraceLimit = Error.stackTraceLimit + 6;
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              var captureStackTrace2 = Error.captureStackTrace;
              shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
              };
              return function(receiver, ignoreUntil) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                captureStackTrace2(receiver, ignoreUntil);
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
              };
            }
            var err = new Error();
            if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
              stackFramePattern = /@/;
              formatStack = v8stackFormatter;
              indentStackFrames = true;
              return function captureStackTrace3(o) {
                o.stack = new Error().stack;
              };
            }
            var hasStackAfterThrow;
            try {
              throw new Error();
            } catch (e) {
              hasStackAfterThrow = "stack" in e;
            }
            if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              return function captureStackTrace3(o) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                try {
                  throw new Error();
                } catch (e) {
                  o.stack = e.stack;
                }
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
              };
            }
            formatStack = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            return null;
          }([]);
          var fireDomEvent;
          var fireGlobalEvent = function() {
            if (util.isNode) {
              return function(name, reason, promise) {
                if (name === "rejectionHandled") {
                  return process.emit(name, promise);
                } else {
                  return process.emit(name, reason, promise);
                }
              };
            } else {
              var customEventWorks = false;
              var anyEventWorks = true;
              try {
                var ev = new self.CustomEvent("test");
                customEventWorks = ev instanceof CustomEvent;
              } catch (e) {
              }
              if (!customEventWorks) {
                try {
                  var event = document.createEvent("CustomEvent");
                  event.initCustomEvent("testingtheevent", false, true, {});
                  self.dispatchEvent(event);
                } catch (e) {
                  anyEventWorks = false;
                }
              }
              if (anyEventWorks) {
                fireDomEvent = function(type, detail) {
                  var event2;
                  if (customEventWorks) {
                    event2 = new self.CustomEvent(type, {
                      detail,
                      bubbles: false,
                      cancelable: true
                    });
                  } else if (self.dispatchEvent) {
                    event2 = document.createEvent("CustomEvent");
                    event2.initCustomEvent(type, false, true, detail);
                  }
                  return event2 ? !self.dispatchEvent(event2) : false;
                };
              }
              var toWindowMethodNameMap = {};
              toWindowMethodNameMap["unhandledRejection"] = "onunhandledRejection".toLowerCase();
              toWindowMethodNameMap["rejectionHandled"] = "onrejectionHandled".toLowerCase();
              return function(name, reason, promise) {
                var methodName = toWindowMethodNameMap[name];
                var method = self[methodName];
                if (!method)
                  return false;
                if (name === "rejectionHandled") {
                  method.call(self, promise);
                } else {
                  method.call(self, reason, promise);
                }
                return true;
              };
            }
          }();
          if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
            warn = function(message) {
              console.warn(message);
            };
            if (util.isNode && process.stderr.isTTY) {
              warn = function(message) {
                process.stderr.write("\x1B[31m" + message + "\x1B[39m\n");
              };
            } else if (!util.isNode && typeof new Error().stack === "string") {
              warn = function(message) {
                console.warn("%c" + message, "color: red");
              };
            }
          }
          return CapturedTrace;
        };
      }, { "./async.js": 2, "./util.js": 38 }], 8: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(NEXT_FILTER) {
          var util = _dereq_2("./util.js");
          var errors = _dereq_2("./errors.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var keys2 = _dereq_2("./es5.js").keys;
          var TypeError2 = errors.TypeError;
          function CatchFilter(instances, callback, promise) {
            this._instances = instances;
            this._callback = callback;
            this._promise = promise;
          }
          function safePredicate(predicate, e) {
            var safeObject = {};
            var retfilter = tryCatch2(predicate).call(safeObject, e);
            if (retfilter === errorObj2)
              return retfilter;
            var safeKeys = keys2(safeObject);
            if (safeKeys.length) {
              errorObj2.e = new TypeError2("Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n");
              return errorObj2;
            }
            return retfilter;
          }
          CatchFilter.prototype.doFilter = function(e) {
            var cb2 = this._callback;
            var promise = this._promise;
            var boundTo = promise._boundValue();
            for (var i = 0, len = this._instances.length; i < len; ++i) {
              var item = this._instances[i];
              var itemIsErrorType = item === Error || item != null && item.prototype instanceof Error;
              if (itemIsErrorType && e instanceof item) {
                var ret2 = tryCatch2(cb2).call(boundTo, e);
                if (ret2 === errorObj2) {
                  NEXT_FILTER.e = ret2.e;
                  return NEXT_FILTER;
                }
                return ret2;
              } else if (typeof item === "function" && !itemIsErrorType) {
                var shouldHandle = safePredicate(item, e);
                if (shouldHandle === errorObj2) {
                  e = errorObj2.e;
                  break;
                } else if (shouldHandle) {
                  var ret2 = tryCatch2(cb2).call(boundTo, e);
                  if (ret2 === errorObj2) {
                    NEXT_FILTER.e = ret2.e;
                    return NEXT_FILTER;
                  }
                  return ret2;
                }
              }
            }
            NEXT_FILTER.e = e;
            return NEXT_FILTER;
          };
          return CatchFilter;
        };
      }, { "./errors.js": 13, "./es5.js": 14, "./util.js": 38 }], 9: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, CapturedTrace, isDebugging) {
          var contextStack = [];
          function Context() {
            this._trace = new CapturedTrace(peekContext());
          }
          Context.prototype._pushContext = function() {
            if (!isDebugging())
              return;
            if (this._trace !== void 0) {
              contextStack.push(this._trace);
            }
          };
          Context.prototype._popContext = function() {
            if (!isDebugging())
              return;
            if (this._trace !== void 0) {
              contextStack.pop();
            }
          };
          function createContext() {
            if (isDebugging())
              return new Context();
          }
          function peekContext() {
            var lastIndex = contextStack.length - 1;
            if (lastIndex >= 0) {
              return contextStack[lastIndex];
            }
            return void 0;
          }
          Promise2.prototype._peekContext = peekContext;
          Promise2.prototype._pushContext = Context.prototype._pushContext;
          Promise2.prototype._popContext = Context.prototype._popContext;
          return createContext;
        };
      }, {}], 10: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, CapturedTrace) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var Warning = _dereq_2("./errors.js").Warning;
          var util = _dereq_2("./util.js");
          var canAttachTrace2 = util.canAttachTrace;
          var unhandledRejectionHandled;
          var possiblyUnhandledRejection;
          var debugging = util.isNode && (!!process.env["BLUEBIRD_DEBUG"] || true);
          if (debugging) {
            async.disableTrampolineIfNecessary();
          }
          Promise2.prototype._ignoreRejections = function() {
            this._unsetRejectionIsUnhandled();
            this._bitField = this._bitField | 16777216;
          };
          Promise2.prototype._ensurePossibleRejectionHandled = function() {
            if ((this._bitField & 16777216) !== 0)
              return;
            this._setRejectionIsUnhandled();
            async.invokeLater(this._notifyUnhandledRejection, this, void 0);
          };
          Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
            CapturedTrace.fireRejectionEvent(
              "rejectionHandled",
              unhandledRejectionHandled,
              void 0,
              this
            );
          };
          Promise2.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var reason = this._getCarriedStackTrace() || this._settledValue;
              this._setUnhandledRejectionIsNotified();
              CapturedTrace.fireRejectionEvent(
                "unhandledRejection",
                possiblyUnhandledRejection,
                reason,
                this
              );
            }
          };
          Promise2.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 524288;
          };
          Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & ~524288;
          };
          Promise2.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 524288) > 0;
          };
          Promise2.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 2097152;
          };
          Promise2.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & ~2097152;
            if (this._isUnhandledRejectionNotified()) {
              this._unsetUnhandledRejectionIsNotified();
              this._notifyUnhandledRejectionIsHandled();
            }
          };
          Promise2.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 2097152) > 0;
          };
          Promise2.prototype._setCarriedStackTrace = function(capturedTrace) {
            this._bitField = this._bitField | 1048576;
            this._fulfillmentHandler0 = capturedTrace;
          };
          Promise2.prototype._isCarryingStackTrace = function() {
            return (this._bitField & 1048576) > 0;
          };
          Promise2.prototype._getCarriedStackTrace = function() {
            return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : void 0;
          };
          Promise2.prototype._captureStackTrace = function() {
            if (debugging) {
              this._trace = new CapturedTrace(this._peekContext());
            }
            return this;
          };
          Promise2.prototype._attachExtraTrace = function(error, ignoreSelf) {
            if (debugging && canAttachTrace2(error)) {
              var trace = this._trace;
              if (trace !== void 0) {
                if (ignoreSelf)
                  trace = trace._parent;
              }
              if (trace !== void 0) {
                trace.attachExtraTrace(error);
              } else if (!error.__stackCleaned__) {
                var parsed = CapturedTrace.parseStackAndMessage(error);
                util.notEnumerableProp(
                  error,
                  "stack",
                  parsed.message + "\n" + parsed.stack.join("\n")
                );
                util.notEnumerableProp(error, "__stackCleaned__", true);
              }
            }
          };
          Promise2.prototype._warn = function(message) {
            var warning = new Warning(message);
            var ctx = this._peekContext();
            if (ctx) {
              ctx.attachExtraTrace(warning);
            } else {
              var parsed = CapturedTrace.parseStackAndMessage(warning);
              warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
            }
            CapturedTrace.formatAndLogError(warning, "");
          };
          Promise2.onPossiblyUnhandledRejection = function(fn) {
            var domain = getDomain();
            possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : void 0;
          };
          Promise2.onUnhandledRejectionHandled = function(fn) {
            var domain = getDomain();
            unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : void 0;
          };
          Promise2.longStackTraces = function() {
            if (async.haveItemsQueued() && debugging === false) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n");
            }
            debugging = CapturedTrace.isSupported();
            if (debugging) {
              async.disableTrampolineIfNecessary();
            }
          };
          Promise2.hasLongStackTraces = function() {
            return debugging && CapturedTrace.isSupported();
          };
          if (!CapturedTrace.isSupported()) {
            Promise2.longStackTraces = function() {
            };
            debugging = false;
          }
          return function() {
            return debugging;
          };
        };
      }, { "./async.js": 2, "./errors.js": 13, "./util.js": 38 }], 11: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util.js");
        var isPrimitive2 = util.isPrimitive;
        module2.exports = function(Promise2) {
          var returner = function() {
            return this;
          };
          var thrower2 = function() {
            throw this;
          };
          var returnUndefined = function() {
          };
          var throwUndefined = function() {
            throw void 0;
          };
          var wrapper = function(value, action) {
            if (action === 1) {
              return function() {
                throw value;
              };
            } else if (action === 2) {
              return function() {
                return value;
              };
            }
          };
          Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
            if (value === void 0)
              return this.then(returnUndefined);
            if (isPrimitive2(value)) {
              return this._then(
                wrapper(value, 2),
                void 0,
                void 0,
                void 0,
                void 0
              );
            }
            return this._then(returner, void 0, void 0, value, void 0);
          };
          Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
            if (reason === void 0)
              return this.then(throwUndefined);
            if (isPrimitive2(reason)) {
              return this._then(
                wrapper(reason, 1),
                void 0,
                void 0,
                void 0,
                void 0
              );
            }
            return this._then(thrower2, void 0, void 0, reason, void 0);
          };
        };
      }, { "./util.js": 38 }], 12: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseReduce = Promise2.reduce;
          Promise2.prototype.each = function(fn) {
            return PromiseReduce(this, fn, null, INTERNAL);
          };
          Promise2.each = function(promises, fn) {
            return PromiseReduce(promises, fn, null, INTERNAL);
          };
        };
      }, {}], 13: [function(_dereq_2, module2, exports2) {
        "use strict";
        var es52 = _dereq_2("./es5.js");
        var Objectfreeze = es52.freeze;
        var util = _dereq_2("./util.js");
        var inherits2 = util.inherits;
        var notEnumerableProp2 = util.notEnumerableProp;
        function subError(nameProperty, defaultMessage) {
          function SubError(message) {
            if (!(this instanceof SubError))
              return new SubError(message);
            notEnumerableProp2(
              this,
              "message",
              typeof message === "string" ? message : defaultMessage
            );
            notEnumerableProp2(this, "name", nameProperty);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            } else {
              Error.call(this);
            }
          }
          inherits2(SubError, Error);
          return SubError;
        }
        var _TypeError, _RangeError;
        var Warning = subError("Warning", "warning");
        var CancellationError = subError("CancellationError", "cancellation error");
        var TimeoutError = subError("TimeoutError", "timeout error");
        var AggregateError = subError("AggregateError", "aggregate error");
        try {
          _TypeError = TypeError;
          _RangeError = RangeError;
        } catch (e) {
          _TypeError = subError("TypeError", "type error");
          _RangeError = subError("RangeError", "range error");
        }
        var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
        for (var i = 0; i < methods.length; ++i) {
          if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
          }
        }
        es52.defineProperty(AggregateError.prototype, "length", {
          value: 0,
          configurable: false,
          writable: true,
          enumerable: true
        });
        AggregateError.prototype["isOperational"] = true;
        var level = 0;
        AggregateError.prototype.toString = function() {
          var indent = Array(level * 4 + 1).join(" ");
          var ret2 = "\n" + indent + "AggregateError of:\n";
          level++;
          indent = Array(level * 4 + 1).join(" ");
          for (var i2 = 0; i2 < this.length; ++i2) {
            var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
              lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret2 += str + "\n";
          }
          level--;
          return ret2;
        };
        function OperationalError(message) {
          if (!(this instanceof OperationalError))
            return new OperationalError(message);
          notEnumerableProp2(this, "name", "OperationalError");
          notEnumerableProp2(this, "message", message);
          this.cause = message;
          this["isOperational"] = true;
          if (message instanceof Error) {
            notEnumerableProp2(this, "message", message.message);
            notEnumerableProp2(this, "stack", message.stack);
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        inherits2(OperationalError, Error);
        var errorTypes = Error["__BluebirdErrorTypes__"];
        if (!errorTypes) {
          errorTypes = Objectfreeze({
            CancellationError,
            TimeoutError,
            OperationalError,
            RejectionError: OperationalError,
            AggregateError
          });
          notEnumerableProp2(Error, "__BluebirdErrorTypes__", errorTypes);
        }
        module2.exports = {
          Error,
          TypeError: _TypeError,
          RangeError: _RangeError,
          CancellationError: errorTypes.CancellationError,
          OperationalError: errorTypes.OperationalError,
          TimeoutError: errorTypes.TimeoutError,
          AggregateError: errorTypes.AggregateError,
          Warning
        };
      }, { "./es5.js": 14, "./util.js": 38 }], 14: [function(_dereq_2, module2, exports2) {
        var isES5 = function() {
          "use strict";
          return this === void 0;
        }();
        if (isES5) {
          module2.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5,
            propertyIsWritable: function(obj2, prop) {
              var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
              return !!(!descriptor || descriptor.writable || descriptor.set);
            }
          };
        } else {
          var has3 = {}.hasOwnProperty;
          var str = {}.toString;
          var proto = {}.constructor.prototype;
          var ObjectKeys = function(o) {
            var ret2 = [];
            for (var key in o) {
              if (has3.call(o, key)) {
                ret2.push(key);
              }
            }
            return ret2;
          };
          var ObjectGetDescriptor = function(o, key) {
            return { value: o[key] };
          };
          var ObjectDefineProperty = function(o, key, desc) {
            o[key] = desc.value;
            return o;
          };
          var ObjectFreeze = function(obj2) {
            return obj2;
          };
          var ObjectGetPrototypeOf = function(obj2) {
            try {
              return Object(obj2).constructor.prototype;
            } catch (e) {
              return proto;
            }
          };
          var ArrayIsArray = function(obj2) {
            try {
              return str.call(obj2) === "[object Array]";
            } catch (e) {
              return false;
            }
          };
          module2.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5,
            propertyIsWritable: function() {
              return true;
            }
          };
        }
      }, {}], 15: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseMap = Promise2.map;
          Promise2.prototype.filter = function(fn, options) {
            return PromiseMap(this, fn, options, INTERNAL);
          };
          Promise2.filter = function(promises, fn, options) {
            return PromiseMap(promises, fn, options, INTERNAL);
          };
        };
      }, {}], 16: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, NEXT_FILTER, tryConvertToPromise) {
          var util = _dereq_2("./util.js");
          var isPrimitive2 = util.isPrimitive;
          var thrower2 = util.thrower;
          function returnThis() {
            return this;
          }
          function throwThis() {
            throw this;
          }
          function return$(r) {
            return function() {
              return r;
            };
          }
          function throw$(r) {
            return function() {
              throw r;
            };
          }
          function promisedFinally(ret2, reasonOrValue, isFulfilled) {
            var then;
            if (isPrimitive2(reasonOrValue)) {
              then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
            } else {
              then = isFulfilled ? returnThis : throwThis;
            }
            return ret2._then(then, thrower2, void 0, reasonOrValue, void 0);
          }
          function finallyHandler(reasonOrValue) {
            var promise = this.promise;
            var handler = this.handler;
            var ret2 = promise._isBound() ? handler.call(promise._boundValue()) : handler();
            if (ret2 !== void 0) {
              var maybePromise = tryConvertToPromise(ret2, promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                return promisedFinally(
                  maybePromise,
                  reasonOrValue,
                  promise.isFulfilled()
                );
              }
            }
            if (promise.isRejected()) {
              NEXT_FILTER.e = reasonOrValue;
              return NEXT_FILTER;
            } else {
              return reasonOrValue;
            }
          }
          function tapHandler(value) {
            var promise = this.promise;
            var handler = this.handler;
            var ret2 = promise._isBound() ? handler.call(promise._boundValue(), value) : handler(value);
            if (ret2 !== void 0) {
              var maybePromise = tryConvertToPromise(ret2, promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, value, true);
              }
            }
            return value;
          }
          Promise2.prototype._passThroughHandler = function(handler, isFinally) {
            if (typeof handler !== "function")
              return this.then();
            var promiseAndHandler = {
              promise: this,
              handler
            };
            return this._then(
              isFinally ? finallyHandler : tapHandler,
              isFinally ? finallyHandler : void 0,
              void 0,
              promiseAndHandler,
              void 0
            );
          };
          Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
            return this._passThroughHandler(handler, true);
          };
          Promise2.prototype.tap = function(handler) {
            return this._passThroughHandler(handler, false);
          };
        };
      }, { "./util.js": 38 }], 17: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise) {
          var errors = _dereq_2("./errors.js");
          var TypeError2 = errors.TypeError;
          var util = _dereq_2("./util.js");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var yieldHandlers = [];
          function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
            for (var i = 0; i < yieldHandlers2.length; ++i) {
              traceParent._pushContext();
              var result2 = tryCatch2(yieldHandlers2[i])(value);
              traceParent._popContext();
              if (result2 === errorObj2) {
                traceParent._pushContext();
                var ret2 = Promise2.reject(errorObj2.e);
                traceParent._popContext();
                return ret2;
              }
              var maybePromise = tryConvertToPromise(result2, traceParent);
              if (maybePromise instanceof Promise2)
                return maybePromise;
            }
            return null;
          }
          function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
            var promise = this._promise = new Promise2(INTERNAL);
            promise._captureStackTrace();
            this._stack = stack;
            this._generatorFunction = generatorFunction;
            this._receiver = receiver;
            this._generator = void 0;
            this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
          }
          PromiseSpawn.prototype.promise = function() {
            return this._promise;
          };
          PromiseSpawn.prototype._run = function() {
            this._generator = this._generatorFunction.call(this._receiver);
            this._receiver = this._generatorFunction = void 0;
            this._next(void 0);
          };
          PromiseSpawn.prototype._continue = function(result2) {
            if (result2 === errorObj2) {
              return this._promise._rejectCallback(result2.e, false, true);
            }
            var value = result2.value;
            if (result2.done === true) {
              this._promise._resolveCallback(value);
            } else {
              var maybePromise = tryConvertToPromise(value, this._promise);
              if (!(maybePromise instanceof Promise2)) {
                maybePromise = promiseFromYieldHandler(
                  maybePromise,
                  this._yieldHandlers,
                  this._promise
                );
                if (maybePromise === null) {
                  this._throw(
                    new TypeError2(
                      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                    )
                  );
                  return;
                }
              }
              maybePromise._then(
                this._next,
                this._throw,
                void 0,
                this,
                null
              );
            }
          };
          PromiseSpawn.prototype._throw = function(reason) {
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            var result2 = tryCatch2(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
            this._continue(result2);
          };
          PromiseSpawn.prototype._next = function(value) {
            this._promise._pushContext();
            var result2 = tryCatch2(this._generator.next).call(this._generator, value);
            this._promise._popContext();
            this._continue(result2);
          };
          Promise2.coroutine = function(generatorFunction, options) {
            if (typeof generatorFunction !== "function") {
              throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n");
            }
            var yieldHandler = Object(options).yieldHandler;
            var PromiseSpawn$ = PromiseSpawn;
            var stack = new Error().stack;
            return function() {
              var generator = generatorFunction.apply(this, arguments);
              var spawn = new PromiseSpawn$(
                void 0,
                void 0,
                yieldHandler,
                stack
              );
              spawn._generator = generator;
              spawn._next(void 0);
              return spawn.promise();
            };
          };
          Promise2.coroutine.addYieldHandler = function(fn) {
            if (typeof fn !== "function")
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            yieldHandlers.push(fn);
          };
          Promise2.spawn = function(generatorFunction) {
            if (typeof generatorFunction !== "function") {
              return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n");
            }
            var spawn = new PromiseSpawn(generatorFunction, this);
            var ret2 = spawn.promise();
            spawn._run(Promise2.spawn);
            return ret2;
          };
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 18: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL) {
          var util = _dereq_2("./util.js");
          var canEvaluate2 = util.canEvaluate;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var reject2;
          if (false) {
            if (canEvaluate2) {
              var thenCallback = function(i2) {
                return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
              };
              var caller = function(count) {
                var values2 = [];
                for (var i2 = 1; i2 <= count; ++i2)
                  values2.push("holder.p" + i2);
                return new Function("holder", "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ".replace(/values/g, values2.join(", ")));
              };
              var thenCallbacks = [];
              var callers = [void 0];
              for (var i = 1; i <= 5; ++i) {
                thenCallbacks.push(thenCallback(i));
                callers.push(caller(i));
              }
              var Holder = function(total, fn) {
                this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                this.fn = fn;
                this.total = total;
                this.now = 0;
              };
              Holder.prototype.callers = callers;
              Holder.prototype.checkFulfillment = function(promise) {
                var now = this.now;
                now++;
                var total = this.total;
                if (now >= total) {
                  var handler = this.callers[total];
                  promise._pushContext();
                  var ret2 = tryCatch2(handler)(this);
                  promise._popContext();
                  if (ret2 === errorObj2) {
                    promise._rejectCallback(ret2.e, false, true);
                  } else {
                    promise._resolveCallback(ret2);
                  }
                } else {
                  this.now = now;
                }
              };
              var reject2 = function(reason) {
                this._reject(reason);
              };
            }
          }
          Promise2.join = function() {
            var last2 = arguments.length - 1;
            var fn;
            if (last2 > 0 && typeof arguments[last2] === "function") {
              fn = arguments[last2];
              if (false) {
                if (last2 < 6 && canEvaluate2) {
                  var ret2 = new Promise2(INTERNAL);
                  ret2._captureStackTrace();
                  var holder = new Holder(last2, fn);
                  var callbacks = thenCallbacks;
                  for (var i2 = 0; i2 < last2; ++i2) {
                    var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                    if (maybePromise instanceof Promise2) {
                      maybePromise = maybePromise._target();
                      if (maybePromise._isPending()) {
                        maybePromise._then(
                          callbacks[i2],
                          reject2,
                          void 0,
                          ret2,
                          holder
                        );
                      } else if (maybePromise._isFulfilled()) {
                        callbacks[i2].call(
                          ret2,
                          maybePromise._value(),
                          holder
                        );
                      } else {
                        ret2._reject(maybePromise._reason());
                      }
                    } else {
                      callbacks[i2].call(ret2, maybePromise, holder);
                    }
                  }
                  return ret2;
                }
              }
            }
            var $_len = arguments.length;
            var args = new Array($_len);
            for (var $_i = 0; $_i < $_len; ++$_i) {
              args[$_i] = arguments[$_i];
            }
            if (fn)
              args.pop();
            var ret2 = new PromiseArray(args).promise();
            return fn !== void 0 ? ret2.spread(fn) : ret2;
          };
        };
      }, { "./util.js": 38 }], 19: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var PENDING = {};
          var EMPTY_ARRAY = [];
          function MappingPromiseArray(promises, fn, limit, _filter) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            var domain = getDomain();
            this._callback = domain === null ? fn : domain.bind(fn);
            this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
            this._limit = limit;
            this._inFlight = 0;
            this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
            async.invoke(init, this, void 0);
          }
          util.inherits(MappingPromiseArray, PromiseArray);
          function init() {
            this._init$(void 0, -2);
          }
          MappingPromiseArray.prototype._init = function() {
          };
          MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values2 = this._values;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var limit = this._limit;
            if (values2[index] === PENDING) {
              values2[index] = value;
              if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved())
                  return;
              }
            } else {
              if (limit >= 1 && this._inFlight >= limit) {
                values2[index] = value;
                this._queue.push(index);
                return;
              }
              if (preservedValues !== null)
                preservedValues[index] = value;
              var callback = this._callback;
              var receiver = this._promise._boundValue();
              this._promise._pushContext();
              var ret2 = tryCatch2(callback).call(receiver, value, index, length);
              this._promise._popContext();
              if (ret2 === errorObj2)
                return this._reject(ret2.e);
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  if (limit >= 1)
                    this._inFlight++;
                  values2[index] = PENDING;
                  return maybePromise._proxyPromiseArray(this, index);
                } else if (maybePromise._isFulfilled()) {
                  ret2 = maybePromise._value();
                } else {
                  return this._reject(maybePromise._reason());
                }
              }
              values2[index] = ret2;
            }
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= length) {
              if (preservedValues !== null) {
                this._filter(values2, preservedValues);
              } else {
                this._resolve(values2);
              }
            }
          };
          MappingPromiseArray.prototype._drainQueue = function() {
            var queue = this._queue;
            var limit = this._limit;
            var values2 = this._values;
            while (queue.length > 0 && this._inFlight < limit) {
              if (this._isResolved())
                return;
              var index = queue.pop();
              this._promiseFulfilled(values2[index], index);
            }
          };
          MappingPromiseArray.prototype._filter = function(booleans, values2) {
            var len = values2.length;
            var ret2 = new Array(len);
            var j = 0;
            for (var i = 0; i < len; ++i) {
              if (booleans[i])
                ret2[j++] = values2[i];
            }
            ret2.length = j;
            this._resolve(ret2);
          };
          MappingPromiseArray.prototype.preservedValues = function() {
            return this._preservedValues;
          };
          function map2(promises, fn, options, _filter) {
            var limit = typeof options === "object" && options !== null ? options.concurrency : 0;
            limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
            return new MappingPromiseArray(promises, fn, limit, _filter);
          }
          Promise2.prototype.map = function(fn, options) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            return map2(this, fn, options, null).promise();
          };
          Promise2.map = function(promises, fn, options, _filter) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            return map2(promises, fn, options, _filter).promise();
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 20: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          Promise2.method = function(fn) {
            if (typeof fn !== "function") {
              throw new Promise2.TypeError("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            return function() {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._pushContext();
              var value = tryCatch2(fn).apply(this, arguments);
              ret2._popContext();
              ret2._resolveFromSyncValue(value);
              return ret2;
            };
          };
          Promise2.attempt = Promise2["try"] = function(fn, args, ctx) {
            if (typeof fn !== "function") {
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._pushContext();
            var value = util.isArray(args) ? tryCatch2(fn).apply(ctx, args) : tryCatch2(fn).call(ctx, args);
            ret2._popContext();
            ret2._resolveFromSyncValue(value);
            return ret2;
          };
          Promise2.prototype._resolveFromSyncValue = function(value) {
            if (value === util.errorObj) {
              this._rejectCallback(value.e, false, true);
            } else {
              this._resolveCallback(value, true);
            }
          };
        };
      }, { "./util.js": 38 }], 21: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util.js");
          var async = _dereq_2("./async.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function spreadAdapter(val, nodeback) {
            var promise = this;
            if (!util.isArray(val))
              return successAdapter.call(promise, val, nodeback);
            var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function successAdapter(val, nodeback) {
            var promise = this;
            var receiver = promise._boundValue();
            var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function errorAdapter(reason, nodeback) {
            var promise = this;
            if (!reason) {
              var target = promise._target();
              var newReason = target._getCarriedStackTrace();
              newReason.cause = reason;
              reason = newReason;
            }
            var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
            if (typeof nodeback == "function") {
              var adapter = successAdapter;
              if (options !== void 0 && Object(options).spread) {
                adapter = spreadAdapter;
              }
              this._then(
                adapter,
                errorAdapter,
                void 0,
                this,
                nodeback
              );
            }
            return this;
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 22: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray) {
          var util = _dereq_2("./util.js");
          var async = _dereq_2("./async.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          Promise2.prototype.progressed = function(handler) {
            return this._then(void 0, void 0, handler, void 0, void 0);
          };
          Promise2.prototype._progress = function(progressValue) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._target()._progressUnchecked(progressValue);
          };
          Promise2.prototype._progressHandlerAt = function(index) {
            return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2];
          };
          Promise2.prototype._doProgressWith = function(progression) {
            var progressValue = progression.value;
            var handler = progression.handler;
            var promise = progression.promise;
            var receiver = progression.receiver;
            var ret2 = tryCatch2(handler).call(receiver, progressValue);
            if (ret2 === errorObj2) {
              if (ret2.e != null && ret2.e.name !== "StopProgressPropagation") {
                var trace = util.canAttachTrace(ret2.e) ? ret2.e : new Error(util.toString(ret2.e));
                promise._attachExtraTrace(trace);
                promise._progress(ret2.e);
              }
            } else if (ret2 instanceof Promise2) {
              ret2._then(promise._progress, null, null, promise, void 0);
            } else {
              promise._progress(ret2);
            }
          };
          Promise2.prototype._progressUnchecked = function(progressValue) {
            var len = this._length();
            var progress = this._progress;
            for (var i = 0; i < len; i++) {
              var handler = this._progressHandlerAt(i);
              var promise = this._promiseAt(i);
              if (!(promise instanceof Promise2)) {
                var receiver = this._receiverAt(i);
                if (typeof handler === "function") {
                  handler.call(receiver, progressValue, promise);
                } else if (receiver instanceof PromiseArray && !receiver._isResolved()) {
                  receiver._promiseProgressed(progressValue, promise);
                }
                continue;
              }
              if (typeof handler === "function") {
                async.invoke(this._doProgressWith, this, {
                  handler,
                  promise,
                  receiver: this._receiverAt(i),
                  value: progressValue
                });
              } else {
                async.invoke(progress, promise, progressValue);
              }
            }
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 23: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var makeSelfResolutionError = function() {
            return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n");
          };
          var reflect = function() {
            return new Promise2.PromiseInspection(this._target());
          };
          var apiRejection = function(msg) {
            return Promise2.reject(new TypeError2(msg));
          };
          var util = _dereq_2("./util.js");
          var getDomain;
          if (util.isNode) {
            getDomain = function() {
              var ret2 = process.domain;
              if (ret2 === void 0)
                ret2 = null;
              return ret2;
            };
          } else {
            getDomain = function() {
              return null;
            };
          }
          util.notEnumerableProp(Promise2, "_getDomain", getDomain);
          var async = _dereq_2("./async.js");
          var errors = _dereq_2("./errors.js");
          var TypeError2 = Promise2.TypeError = errors.TypeError;
          Promise2.RangeError = errors.RangeError;
          Promise2.CancellationError = errors.CancellationError;
          Promise2.TimeoutError = errors.TimeoutError;
          Promise2.OperationalError = errors.OperationalError;
          Promise2.RejectionError = errors.OperationalError;
          Promise2.AggregateError = errors.AggregateError;
          var INTERNAL = function() {
          };
          var APPLY = {};
          var NEXT_FILTER = { e: null };
          var tryConvertToPromise = _dereq_2("./thenables.js")(Promise2, INTERNAL);
          var PromiseArray = _dereq_2("./promise_array.js")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection
          );
          var CapturedTrace = _dereq_2("./captured_trace.js")();
          var isDebugging = _dereq_2("./debuggability.js")(Promise2, CapturedTrace);
          var createContext = _dereq_2("./context.js")(Promise2, CapturedTrace, isDebugging);
          var CatchFilter = _dereq_2("./catch_filter.js")(NEXT_FILTER);
          var PromiseResolver = _dereq_2("./promise_resolver.js");
          var nodebackForPromise = PromiseResolver._nodebackForPromise;
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          function Promise2(resolver) {
            if (typeof resolver !== "function") {
              throw new TypeError2("the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n");
            }
            if (this.constructor !== Promise2) {
              throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n");
            }
            this._bitField = 0;
            this._fulfillmentHandler0 = void 0;
            this._rejectionHandler0 = void 0;
            this._progressHandler0 = void 0;
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._settledValue = void 0;
            if (resolver !== INTERNAL)
              this._resolveFromResolver(resolver);
          }
          Promise2.prototype.toString = function() {
            return "[object Promise]";
          };
          Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
            var len = arguments.length;
            if (len > 1) {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (typeof item === "function") {
                  catchInstances[j++] = item;
                } else {
                  return Promise2.reject(
                    new TypeError2("Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n")
                  );
                }
              }
              catchInstances.length = j;
              fn = arguments[i];
              var catchFilter = new CatchFilter(catchInstances, fn, this);
              return this._then(
                void 0,
                catchFilter.doFilter,
                void 0,
                catchFilter,
                void 0
              );
            }
            return this._then(void 0, fn, void 0, void 0, void 0);
          };
          Promise2.prototype.reflect = function() {
            return this._then(reflect, reflect, void 0, this, void 0);
          };
          Promise2.prototype.then = function(didFulfill, didReject, didProgress) {
            if (isDebugging() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
              var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
              if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
              }
              this._warn(msg);
            }
            return this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
          };
          Promise2.prototype.done = function(didFulfill, didReject, didProgress) {
            var promise = this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
            promise._setIsFinal();
          };
          Promise2.prototype.spread = function(didFulfill, didReject) {
            return this.all()._then(didFulfill, didReject, void 0, APPLY, void 0);
          };
          Promise2.prototype.isCancellable = function() {
            return !this.isResolved() && this._cancellable();
          };
          Promise2.prototype.toJSON = function() {
            var ret2 = {
              isFulfilled: false,
              isRejected: false,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            if (this.isFulfilled()) {
              ret2.fulfillmentValue = this.value();
              ret2.isFulfilled = true;
            } else if (this.isRejected()) {
              ret2.rejectionReason = this.reason();
              ret2.isRejected = true;
            }
            return ret2;
          };
          Promise2.prototype.all = function() {
            return new PromiseArray(this).promise();
          };
          Promise2.prototype.error = function(fn) {
            return this.caught(util.originatesFromRejection, fn);
          };
          Promise2.is = function(val) {
            return val instanceof Promise2;
          };
          Promise2.fromNode = function(fn) {
            var ret2 = new Promise2(INTERNAL);
            var result2 = tryCatch2(fn)(nodebackForPromise(ret2));
            if (result2 === errorObj2) {
              ret2._rejectCallback(result2.e, true, true);
            }
            return ret2;
          };
          Promise2.all = function(promises) {
            return new PromiseArray(promises).promise();
          };
          Promise2.defer = Promise2.pending = function() {
            var promise = new Promise2(INTERNAL);
            return new PromiseResolver(promise);
          };
          Promise2.cast = function(obj2) {
            var ret2 = tryConvertToPromise(obj2);
            if (!(ret2 instanceof Promise2)) {
              var val = ret2;
              ret2 = new Promise2(INTERNAL);
              ret2._fulfillUnchecked(val);
            }
            return ret2;
          };
          Promise2.resolve = Promise2.fulfilled = Promise2.cast;
          Promise2.reject = Promise2.rejected = function(reason) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._rejectCallback(reason, true);
            return ret2;
          };
          Promise2.setScheduler = function(fn) {
            if (typeof fn !== "function")
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var prev = async._schedule;
            async._schedule = fn;
            return prev;
          };
          Promise2.prototype._then = function(didFulfill, didReject, didProgress, receiver, internalData) {
            var haveInternalData = internalData !== void 0;
            var ret2 = haveInternalData ? internalData : new Promise2(INTERNAL);
            if (!haveInternalData) {
              ret2._propagateFrom(this, 4 | 1);
              ret2._captureStackTrace();
            }
            var target = this._target();
            if (target !== this) {
              if (receiver === void 0)
                receiver = this._boundTo;
              if (!haveInternalData)
                ret2._setIsMigrated();
            }
            var callbackIndex = target._addCallbacks(
              didFulfill,
              didReject,
              didProgress,
              ret2,
              receiver,
              getDomain()
            );
            if (target._isResolved() && !target._isSettlePromisesQueued()) {
              async.invoke(
                target._settlePromiseAtPostResolution,
                target,
                callbackIndex
              );
            }
            return ret2;
          };
          Promise2.prototype._settlePromiseAtPostResolution = function(index) {
            if (this._isRejectionUnhandled())
              this._unsetRejectionIsUnhandled();
            this._settlePromiseAt(index);
          };
          Promise2.prototype._length = function() {
            return this._bitField & 131071;
          };
          Promise2.prototype._isFollowingOrFulfilledOrRejected = function() {
            return (this._bitField & 939524096) > 0;
          };
          Promise2.prototype._isFollowing = function() {
            return (this._bitField & 536870912) === 536870912;
          };
          Promise2.prototype._setLength = function(len) {
            this._bitField = this._bitField & -131072 | len & 131071;
          };
          Promise2.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 268435456;
          };
          Promise2.prototype._setRejected = function() {
            this._bitField = this._bitField | 134217728;
          };
          Promise2.prototype._setFollowing = function() {
            this._bitField = this._bitField | 536870912;
          };
          Promise2.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 33554432;
          };
          Promise2.prototype._isFinal = function() {
            return (this._bitField & 33554432) > 0;
          };
          Promise2.prototype._cancellable = function() {
            return (this._bitField & 67108864) > 0;
          };
          Promise2.prototype._setCancellable = function() {
            this._bitField = this._bitField | 67108864;
          };
          Promise2.prototype._unsetCancellable = function() {
            this._bitField = this._bitField & ~67108864;
          };
          Promise2.prototype._setIsMigrated = function() {
            this._bitField = this._bitField | 4194304;
          };
          Promise2.prototype._unsetIsMigrated = function() {
            this._bitField = this._bitField & ~4194304;
          };
          Promise2.prototype._isMigrated = function() {
            return (this._bitField & 4194304) > 0;
          };
          Promise2.prototype._receiverAt = function(index) {
            var ret2 = index === 0 ? this._receiver0 : this[index * 5 - 5 + 4];
            if (ret2 === void 0 && this._isBound()) {
              return this._boundValue();
            }
            return ret2;
          };
          Promise2.prototype._promiseAt = function(index) {
            return index === 0 ? this._promise0 : this[index * 5 - 5 + 3];
          };
          Promise2.prototype._fulfillmentHandlerAt = function(index) {
            return index === 0 ? this._fulfillmentHandler0 : this[index * 5 - 5 + 0];
          };
          Promise2.prototype._rejectionHandlerAt = function(index) {
            return index === 0 ? this._rejectionHandler0 : this[index * 5 - 5 + 1];
          };
          Promise2.prototype._boundValue = function() {
            var ret2 = this._boundTo;
            if (ret2 !== void 0) {
              if (ret2 instanceof Promise2) {
                if (ret2.isFulfilled()) {
                  return ret2.value();
                } else {
                  return void 0;
                }
              }
            }
            return ret2;
          };
          Promise2.prototype._migrateCallbacks = function(follower, index) {
            var fulfill = follower._fulfillmentHandlerAt(index);
            var reject2 = follower._rejectionHandlerAt(index);
            var progress = follower._progressHandlerAt(index);
            var promise = follower._promiseAt(index);
            var receiver = follower._receiverAt(index);
            if (promise instanceof Promise2)
              promise._setIsMigrated();
            this._addCallbacks(fulfill, reject2, progress, promise, receiver, null);
          };
          Promise2.prototype._addCallbacks = function(fulfill, reject2, progress, promise, receiver, domain) {
            var index = this._length();
            if (index >= 131071 - 5) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promise;
              if (receiver !== void 0)
                this._receiver0 = receiver;
              if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill);
              }
              if (typeof reject2 === "function") {
                this._rejectionHandler0 = domain === null ? reject2 : domain.bind(reject2);
              }
              if (typeof progress === "function") {
                this._progressHandler0 = domain === null ? progress : domain.bind(progress);
              }
            } else {
              var base = index * 5 - 5;
              this[base + 3] = promise;
              this[base + 4] = receiver;
              if (typeof fulfill === "function") {
                this[base + 0] = domain === null ? fulfill : domain.bind(fulfill);
              }
              if (typeof reject2 === "function") {
                this[base + 1] = domain === null ? reject2 : domain.bind(reject2);
              }
              if (typeof progress === "function") {
                this[base + 2] = domain === null ? progress : domain.bind(progress);
              }
            }
            this._setLength(index + 1);
            return index;
          };
          Promise2.prototype._setProxyHandlers = function(receiver, promiseSlotValue) {
            var index = this._length();
            if (index >= 131071 - 5) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promiseSlotValue;
              this._receiver0 = receiver;
            } else {
              var base = index * 5 - 5;
              this[base + 3] = promiseSlotValue;
              this[base + 4] = receiver;
            }
            this._setLength(index + 1);
          };
          Promise2.prototype._proxyPromiseArray = function(promiseArray, index) {
            this._setProxyHandlers(promiseArray, index);
          };
          Promise2.prototype._resolveCallback = function(value, shouldBind) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            if (value === this)
              return this._rejectCallback(makeSelfResolutionError(), false, true);
            var maybePromise = tryConvertToPromise(value, this);
            if (!(maybePromise instanceof Promise2))
              return this._fulfill(value);
            var propagationFlags = 1 | (shouldBind ? 4 : 0);
            this._propagateFrom(maybePromise, propagationFlags);
            var promise = maybePromise._target();
            if (promise._isPending()) {
              var len = this._length();
              for (var i = 0; i < len; ++i) {
                promise._migrateCallbacks(this, i);
              }
              this._setFollowing();
              this._setLength(0);
              this._setFollowee(promise);
            } else if (promise._isFulfilled()) {
              this._fulfillUnchecked(promise._value());
            } else {
              this._rejectUnchecked(
                promise._reason(),
                promise._getCarriedStackTrace()
              );
            }
          };
          Promise2.prototype._rejectCallback = function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
            if (!shouldNotMarkOriginatingFromRejection) {
              util.markAsOriginatingFromRejection(reason);
            }
            var trace = util.ensureErrorObject(reason);
            var hasStack = trace === reason;
            this._attachExtraTrace(trace, synchronous ? hasStack : false);
            this._reject(reason, hasStack ? void 0 : trace);
          };
          Promise2.prototype._resolveFromResolver = function(resolver) {
            var promise = this;
            this._captureStackTrace();
            this._pushContext();
            var synchronous = true;
            var r = tryCatch2(resolver)(function(value) {
              if (promise === null)
                return;
              promise._resolveCallback(value);
              promise = null;
            }, function(reason) {
              if (promise === null)
                return;
              promise._rejectCallback(reason, synchronous);
              promise = null;
            });
            synchronous = false;
            this._popContext();
            if (r !== void 0 && r === errorObj2 && promise !== null) {
              promise._rejectCallback(r.e, true, true);
              promise = null;
            }
          };
          Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
            if (promise._isRejected())
              return;
            promise._pushContext();
            var x;
            if (receiver === APPLY && !this._isRejected()) {
              x = tryCatch2(handler).apply(this._boundValue(), value);
            } else {
              x = tryCatch2(handler).call(receiver, value);
            }
            promise._popContext();
            if (x === errorObj2 || x === promise || x === NEXT_FILTER) {
              var err = x === promise ? makeSelfResolutionError() : x.e;
              promise._rejectCallback(err, false, true);
            } else {
              promise._resolveCallback(x);
            }
          };
          Promise2.prototype._target = function() {
            var ret2 = this;
            while (ret2._isFollowing())
              ret2 = ret2._followee();
            return ret2;
          };
          Promise2.prototype._followee = function() {
            return this._rejectionHandler0;
          };
          Promise2.prototype._setFollowee = function(promise) {
            this._rejectionHandler0 = promise;
          };
          Promise2.prototype._cleanValues = function() {
            if (this._cancellable()) {
              this._cancellationParent = void 0;
            }
          };
          Promise2.prototype._propagateFrom = function(parent, flags) {
            if ((flags & 1) > 0 && parent._cancellable()) {
              this._setCancellable();
              this._cancellationParent = parent;
            }
            if ((flags & 4) > 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          };
          Promise2.prototype._fulfill = function(value) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._fulfillUnchecked(value);
          };
          Promise2.prototype._reject = function(reason, carriedStackTrace) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._rejectUnchecked(reason, carriedStackTrace);
          };
          Promise2.prototype._settlePromiseAt = function(index) {
            var promise = this._promiseAt(index);
            var isPromise = promise instanceof Promise2;
            if (isPromise && promise._isMigrated()) {
              promise._unsetIsMigrated();
              return async.invoke(this._settlePromiseAt, this, index);
            }
            var handler = this._isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
            var carriedStackTrace = this._isCarryingStackTrace() ? this._getCarriedStackTrace() : void 0;
            var value = this._settledValue;
            var receiver = this._receiverAt(index);
            this._clearCallbackDataAtIndex(index);
            if (typeof handler === "function") {
              if (!isPromise) {
                handler.call(receiver, value, promise);
              } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
              }
            } else if (receiver instanceof PromiseArray) {
              if (!receiver._isResolved()) {
                if (this._isFulfilled()) {
                  receiver._promiseFulfilled(value, promise);
                } else {
                  receiver._promiseRejected(value, promise);
                }
              }
            } else if (isPromise) {
              if (this._isFulfilled()) {
                promise._fulfill(value);
              } else {
                promise._reject(value, carriedStackTrace);
              }
            }
            if (index >= 4 && (index & 31) === 4)
              async.invokeLater(this._setLength, this, 0);
          };
          Promise2.prototype._clearCallbackDataAtIndex = function(index) {
            if (index === 0) {
              if (!this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = void 0;
              }
              this._rejectionHandler0 = this._progressHandler0 = this._receiver0 = this._promise0 = void 0;
            } else {
              var base = index * 5 - 5;
              this[base + 3] = this[base + 4] = this[base + 0] = this[base + 1] = this[base + 2] = void 0;
            }
          };
          Promise2.prototype._isSettlePromisesQueued = function() {
            return (this._bitField & -1073741824) === -1073741824;
          };
          Promise2.prototype._setSettlePromisesQueued = function() {
            this._bitField = this._bitField | -1073741824;
          };
          Promise2.prototype._unsetSettlePromisesQueued = function() {
            this._bitField = this._bitField & ~-1073741824;
          };
          Promise2.prototype._queueSettlePromises = function() {
            async.settlePromises(this);
            this._setSettlePromisesQueued();
          };
          Promise2.prototype._fulfillUnchecked = function(value) {
            if (value === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._rejectUnchecked(err, void 0);
            }
            this._setFulfilled();
            this._settledValue = value;
            this._cleanValues();
            if (this._length() > 0) {
              this._queueSettlePromises();
            }
          };
          Promise2.prototype._rejectUncheckedCheckError = function(reason) {
            var trace = util.ensureErrorObject(reason);
            this._rejectUnchecked(reason, trace === reason ? void 0 : trace);
          };
          Promise2.prototype._rejectUnchecked = function(reason, trace) {
            if (reason === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._rejectUnchecked(err);
            }
            this._setRejected();
            this._settledValue = reason;
            this._cleanValues();
            if (this._isFinal()) {
              async.throwLater(function(e) {
                if ("stack" in e) {
                  async.invokeFirst(
                    CapturedTrace.unhandledRejection,
                    void 0,
                    e
                  );
                }
                throw e;
              }, trace === void 0 ? reason : trace);
              return;
            }
            if (trace !== void 0 && trace !== reason) {
              this._setCarriedStackTrace(trace);
            }
            if (this._length() > 0) {
              this._queueSettlePromises();
            } else {
              this._ensurePossibleRejectionHandled();
            }
          };
          Promise2.prototype._settlePromises = function() {
            this._unsetSettlePromisesQueued();
            var len = this._length();
            for (var i = 0; i < len; i++) {
              this._settlePromiseAt(i);
            }
          };
          util.notEnumerableProp(
            Promise2,
            "_makeSelfResolutionError",
            makeSelfResolutionError
          );
          _dereq_2("./progress.js")(Promise2, PromiseArray);
          _dereq_2("./method.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./bind.js")(Promise2, INTERNAL, tryConvertToPromise);
          _dereq_2("./finally.js")(Promise2, NEXT_FILTER, tryConvertToPromise);
          _dereq_2("./direct_resolve.js")(Promise2);
          _dereq_2("./synchronous_inspection.js")(Promise2);
          _dereq_2("./join.js")(Promise2, PromiseArray, tryConvertToPromise, INTERNAL);
          Promise2.Promise = Promise2;
          _dereq_2("./map.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
          _dereq_2("./cancel.js")(Promise2);
          _dereq_2("./using.js")(Promise2, apiRejection, tryConvertToPromise, createContext);
          _dereq_2("./generators.js")(Promise2, apiRejection, INTERNAL, tryConvertToPromise);
          _dereq_2("./nodeify.js")(Promise2);
          _dereq_2("./call_get.js")(Promise2);
          _dereq_2("./props.js")(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
          _dereq_2("./race.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./reduce.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
          _dereq_2("./settle.js")(Promise2, PromiseArray);
          _dereq_2("./some.js")(Promise2, PromiseArray, apiRejection);
          _dereq_2("./promisify.js")(Promise2, INTERNAL);
          _dereq_2("./any.js")(Promise2);
          _dereq_2("./each.js")(Promise2, INTERNAL);
          _dereq_2("./timers.js")(Promise2, INTERNAL);
          _dereq_2("./filter.js")(Promise2, INTERNAL);
          util.toFastProperties(Promise2);
          util.toFastProperties(Promise2.prototype);
          function fillTypes(value) {
            var p = new Promise2(INTERNAL);
            p._fulfillmentHandler0 = value;
            p._rejectionHandler0 = value;
            p._progressHandler0 = value;
            p._promise0 = value;
            p._receiver0 = value;
            p._settledValue = value;
          }
          fillTypes({ a: 1 });
          fillTypes({ b: 2 });
          fillTypes({ c: 3 });
          fillTypes(1);
          fillTypes(function() {
          });
          fillTypes(void 0);
          fillTypes(false);
          fillTypes(new Promise2(INTERNAL));
          CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
          return Promise2;
        };
      }, { "./any.js": 1, "./async.js": 2, "./bind.js": 3, "./call_get.js": 5, "./cancel.js": 6, "./captured_trace.js": 7, "./catch_filter.js": 8, "./context.js": 9, "./debuggability.js": 10, "./direct_resolve.js": 11, "./each.js": 12, "./errors.js": 13, "./filter.js": 15, "./finally.js": 16, "./generators.js": 17, "./join.js": 18, "./map.js": 19, "./method.js": 20, "./nodeify.js": 21, "./progress.js": 22, "./promise_array.js": 24, "./promise_resolver.js": 25, "./promisify.js": 26, "./props.js": 27, "./race.js": 29, "./reduce.js": 30, "./settle.js": 32, "./some.js": 33, "./synchronous_inspection.js": 34, "./thenables.js": 35, "./timers.js": 36, "./using.js": 37, "./util.js": 38 }], 24: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var isArray = util.isArray;
          function toResolutionValue(val) {
            switch (val) {
              case -2:
                return [];
              case -3:
                return {};
            }
          }
          function PromiseArray(values2) {
            var promise = this._promise = new Promise2(INTERNAL);
            var parent;
            if (values2 instanceof Promise2) {
              parent = values2;
              promise._propagateFrom(parent, 1 | 4);
            }
            this._values = values2;
            this._length = 0;
            this._totalResolved = 0;
            this._init(void 0, -2);
          }
          PromiseArray.prototype.length = function() {
            return this._length;
          };
          PromiseArray.prototype.promise = function() {
            return this._promise;
          };
          PromiseArray.prototype._init = function init(_3, resolveValueIfEmpty) {
            var values2 = tryConvertToPromise(this._values, this._promise);
            if (values2 instanceof Promise2) {
              values2 = values2._target();
              this._values = values2;
              if (values2._isFulfilled()) {
                values2 = values2._value();
                if (!isArray(values2)) {
                  var err = new Promise2.TypeError("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n");
                  this.__hardReject__(err);
                  return;
                }
              } else if (values2._isPending()) {
                values2._then(
                  init,
                  this._reject,
                  void 0,
                  this,
                  resolveValueIfEmpty
                );
                return;
              } else {
                this._reject(values2._reason());
                return;
              }
            } else if (!isArray(values2)) {
              this._promise._reject(apiRejection("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n")._reason());
              return;
            }
            if (values2.length === 0) {
              if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
              } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
              }
              return;
            }
            var len = this.getActualLength(values2.length);
            this._length = len;
            this._values = this.shouldCopyValues() ? new Array(len) : this._values;
            var promise = this._promise;
            for (var i = 0; i < len; ++i) {
              var isResolved = this._isResolved();
              var maybePromise = tryConvertToPromise(values2[i], promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (isResolved) {
                  maybePromise._ignoreRejections();
                } else if (maybePromise._isPending()) {
                  maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                  this._promiseFulfilled(maybePromise._value(), i);
                } else {
                  this._promiseRejected(maybePromise._reason(), i);
                }
              } else if (!isResolved) {
                this._promiseFulfilled(maybePromise, i);
              }
            }
          };
          PromiseArray.prototype._isResolved = function() {
            return this._values === null;
          };
          PromiseArray.prototype._resolve = function(value) {
            this._values = null;
            this._promise._fulfill(value);
          };
          PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function(reason) {
            this._values = null;
            this._promise._rejectCallback(reason, false, true);
          };
          PromiseArray.prototype._promiseProgressed = function(progressValue, index) {
            this._promise._progress({
              index,
              value: progressValue
            });
          };
          PromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
            }
          };
          PromiseArray.prototype._promiseRejected = function(reason, index) {
            this._totalResolved++;
            this._reject(reason);
          };
          PromiseArray.prototype.shouldCopyValues = function() {
            return true;
          };
          PromiseArray.prototype.getActualLength = function(len) {
            return len;
          };
          return PromiseArray;
        };
      }, { "./util.js": 38 }], 25: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util.js");
        var maybeWrapAsError2 = util.maybeWrapAsError;
        var errors = _dereq_2("./errors.js");
        var TimeoutError = errors.TimeoutError;
        var OperationalError = errors.OperationalError;
        var haveGetters2 = util.haveGetters;
        var es52 = _dereq_2("./es5.js");
        function isUntypedError(obj2) {
          return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
        }
        var rErrorKey = /^(?:name|message|stack|cause)$/;
        function wrapAsOperationalError(obj2) {
          var ret2;
          if (isUntypedError(obj2)) {
            ret2 = new OperationalError(obj2);
            ret2.name = obj2.name;
            ret2.message = obj2.message;
            ret2.stack = obj2.stack;
            var keys2 = es52.keys(obj2);
            for (var i = 0; i < keys2.length; ++i) {
              var key = keys2[i];
              if (!rErrorKey.test(key)) {
                ret2[key] = obj2[key];
              }
            }
            return ret2;
          }
          util.markAsOriginatingFromRejection(obj2);
          return obj2;
        }
        function nodebackForPromise(promise) {
          return function(err, value) {
            if (promise === null)
              return;
            if (err) {
              var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
              promise._attachExtraTrace(wrapped);
              promise._reject(wrapped);
            } else if (arguments.length > 2) {
              var $_len = arguments.length;
              var args = new Array($_len - 1);
              for (var $_i = 1; $_i < $_len; ++$_i) {
                args[$_i - 1] = arguments[$_i];
              }
              promise._fulfill(args);
            } else {
              promise._fulfill(value);
            }
            promise = null;
          };
        }
        var PromiseResolver;
        if (!haveGetters2) {
          PromiseResolver = function(promise) {
            this.promise = promise;
            this.asCallback = nodebackForPromise(promise);
            this.callback = this.asCallback;
          };
        } else {
          PromiseResolver = function(promise) {
            this.promise = promise;
          };
        }
        if (haveGetters2) {
          var prop = {
            get: function() {
              return nodebackForPromise(this.promise);
            }
          };
          es52.defineProperty(PromiseResolver.prototype, "asCallback", prop);
          es52.defineProperty(PromiseResolver.prototype, "callback", prop);
        }
        PromiseResolver._nodebackForPromise = nodebackForPromise;
        PromiseResolver.prototype.toString = function() {
          return "[object PromiseResolver]";
        };
        PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function(value) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._resolveCallback(value);
        };
        PromiseResolver.prototype.reject = function(reason) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._rejectCallback(reason);
        };
        PromiseResolver.prototype.progress = function(value) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._progress(value);
        };
        PromiseResolver.prototype.cancel = function(err) {
          this.promise.cancel(err);
        };
        PromiseResolver.prototype.timeout = function() {
          this.reject(new TimeoutError("timeout"));
        };
        PromiseResolver.prototype.isResolved = function() {
          return this.promise.isResolved();
        };
        PromiseResolver.prototype.toJSON = function() {
          return this.promise.toJSON();
        };
        module2.exports = PromiseResolver;
      }, { "./errors.js": 13, "./es5.js": 14, "./util.js": 38 }], 26: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var THIS = {};
          var util = _dereq_2("./util.js");
          var nodebackForPromise = _dereq_2("./promise_resolver.js")._nodebackForPromise;
          var withAppended2 = util.withAppended;
          var maybeWrapAsError2 = util.maybeWrapAsError;
          var canEvaluate2 = util.canEvaluate;
          var TypeError2 = _dereq_2("./errors").TypeError;
          var defaultSuffix = "Async";
          var defaultPromisified = { __isPromisified__: true };
          var noCopyProps = [
            "arity",
            "length",
            "name",
            "arguments",
            "caller",
            "callee",
            "prototype",
            "__isPromisified__"
          ];
          var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
          var defaultFilter = function(name) {
            return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
          };
          function propsFilter(key) {
            return !noCopyPropsPattern.test(key);
          }
          function isPromisified(fn) {
            try {
              return fn.__isPromisified__ === true;
            } catch (e) {
              return false;
            }
          }
          function hasPromisified(obj2, key, suffix) {
            var val = util.getDataPropertyOrDefault(
              obj2,
              key + suffix,
              defaultPromisified
            );
            return val ? isPromisified(val) : false;
          }
          function checkValid(ret2, suffix, suffixRegexp) {
            for (var i = 0; i < ret2.length; i += 2) {
              var key = ret2[i];
              if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret2.length; j += 2) {
                  if (ret2[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n".replace("%s", suffix));
                  }
                }
              }
            }
          }
          function promisifiableMethods(obj2, suffix, suffixRegexp, filter2) {
            var keys2 = util.inheritedDataKeys(obj2);
            var ret2 = [];
            for (var i = 0; i < keys2.length; ++i) {
              var key = keys2[i];
              var value = obj2[key];
              var passesDefaultFilter = filter2 === defaultFilter ? true : defaultFilter(key, value, obj2);
              if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter2(key, value, obj2, passesDefaultFilter)) {
                ret2.push(key, value);
              }
            }
            checkValid(ret2, suffix, suffixRegexp);
            return ret2;
          }
          var escapeIdentRegex = function(str) {
            return str.replace(/([$])/, "\\$");
          };
          var makeNodePromisifiedEval;
          if (false) {
            var switchCaseArgumentOrder = function(likelyArgumentCount) {
              var ret2 = [likelyArgumentCount];
              var min2 = Math.max(0, likelyArgumentCount - 1 - 3);
              for (var i = likelyArgumentCount - 1; i >= min2; --i) {
                ret2.push(i);
              }
              for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret2.push(i);
              }
              return ret2;
            };
            var argumentSequence = function(argumentCount) {
              return util.filledRange(argumentCount, "_arg", "");
            };
            var parameterDeclaration = function(parameterCount2) {
              return util.filledRange(
                Math.max(parameterCount2, 3),
                "_arg",
                ""
              );
            };
            var parameterCount = function(fn) {
              if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
              }
              return 0;
            };
            makeNodePromisifiedEval = function(callback, receiver, originalName, fn) {
              var newParameterCount = Math.max(0, parameterCount(fn) - 1);
              var argumentOrder = switchCaseArgumentOrder(newParameterCount);
              var shouldProxyThis = typeof callback === "string" || receiver === THIS;
              function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret2;
                if (shouldProxyThis) {
                  ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                  ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret2.replace("{{args}}", args).replace(", ", comma);
              }
              function generateArgumentSwitchCase() {
                var ret2 = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                  ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }
                ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret2;
              }
              var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
              return new Function(
                "Promise",
                "fn",
                "receiver",
                "withAppended",
                "maybeWrapAsError",
                "nodebackForPromise",
                "tryCatch",
                "errorObj",
                "notEnumerableProp",
                "INTERNAL",
                "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ".replace("Parameters", parameterDeclaration(newParameterCount)).replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode)
              )(
                Promise2,
                fn,
                receiver,
                withAppended2,
                maybeWrapAsError2,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
              );
            };
          }
          function makeNodePromisifiedClosure(callback, receiver, _3, fn) {
            var defaultThis = /* @__PURE__ */ function() {
              return this;
            }();
            var method = callback;
            if (typeof method === "string") {
              callback = fn;
            }
            function promisified() {
              var _receiver = receiver;
              if (receiver === THIS)
                _receiver = this;
              var promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
              var cb2 = typeof method === "string" && this !== defaultThis ? this[method] : callback;
              var fn2 = nodebackForPromise(promise);
              try {
                cb2.apply(_receiver, withAppended2(arguments, fn2));
              } catch (e) {
                promise._rejectCallback(maybeWrapAsError2(e), true, true);
              }
              return promise;
            }
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            return promisified;
          }
          var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
          function promisifyAll(obj2, suffix, filter2, promisifier) {
            var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
            var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter2);
            for (var i = 0, len = methods.length; i < len; i += 2) {
              var key = methods[i];
              var fn = methods[i + 1];
              var promisifiedKey = key + suffix;
              obj2[promisifiedKey] = promisifier === makeNodePromisified ? makeNodePromisified(key, THIS, key, fn, suffix) : promisifier(fn, function() {
                return makeNodePromisified(key, THIS, key, fn, suffix);
              });
            }
            util.toFastProperties(obj2);
            return obj2;
          }
          function promisify(callback, receiver) {
            return makeNodePromisified(callback, receiver, void 0, callback);
          }
          Promise2.promisify = function(fn, receiver) {
            if (typeof fn !== "function") {
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            if (isPromisified(fn)) {
              return fn;
            }
            var ret2 = promisify(fn, arguments.length < 2 ? THIS : receiver);
            util.copyDescriptors(fn, ret2, propsFilter);
            return ret2;
          };
          Promise2.promisifyAll = function(target, options) {
            if (typeof target !== "function" && typeof target !== "object") {
              throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n");
            }
            options = Object(options);
            var suffix = options.suffix;
            if (typeof suffix !== "string")
              suffix = defaultSuffix;
            var filter2 = options.filter;
            if (typeof filter2 !== "function")
              filter2 = defaultFilter;
            var promisifier = options.promisifier;
            if (typeof promisifier !== "function")
              promisifier = makeNodePromisified;
            if (!util.isIdentifier(suffix)) {
              throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n");
            }
            var keys2 = util.inheritedDataKeys(target);
            for (var i = 0; i < keys2.length; ++i) {
              var value = target[keys2[i]];
              if (keys2[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter2, promisifier);
                promisifyAll(value, suffix, filter2, promisifier);
              }
            }
            return promisifyAll(target, suffix, filter2, promisifier);
          };
        };
      }, { "./errors": 13, "./promise_resolver.js": 25, "./util.js": 38 }], 27: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var isObject3 = util.isObject;
          var es52 = _dereq_2("./es5.js");
          function PropertiesPromiseArray(obj2) {
            var keys2 = es52.keys(obj2);
            var len = keys2.length;
            var values2 = new Array(len * 2);
            for (var i = 0; i < len; ++i) {
              var key = keys2[i];
              values2[i] = obj2[key];
              values2[i + len] = key;
            }
            this.constructor$(values2);
          }
          util.inherits(PropertiesPromiseArray, PromiseArray);
          PropertiesPromiseArray.prototype._init = function() {
            this._init$(void 0, -3);
          };
          PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              var val = {};
              var keyOffset = this.length();
              for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
              }
              this._resolve(val);
            }
          };
          PropertiesPromiseArray.prototype._promiseProgressed = function(value, index) {
            this._promise._progress({
              key: this._values[index + this.length()],
              value
            });
          };
          PropertiesPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          PropertiesPromiseArray.prototype.getActualLength = function(len) {
            return len >> 1;
          };
          function props(promises) {
            var ret2;
            var castValue = tryConvertToPromise(promises);
            if (!isObject3(castValue)) {
              return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n");
            } else if (castValue instanceof Promise2) {
              ret2 = castValue._then(
                Promise2.props,
                void 0,
                void 0,
                void 0,
                void 0
              );
            } else {
              ret2 = new PropertiesPromiseArray(castValue).promise();
            }
            if (castValue instanceof Promise2) {
              ret2._propagateFrom(castValue, 4);
            }
            return ret2;
          }
          Promise2.prototype.props = function() {
            return props(this);
          };
          Promise2.props = function(promises) {
            return props(promises);
          };
        };
      }, { "./es5.js": 14, "./util.js": 38 }], 28: [function(_dereq_2, module2, exports2) {
        "use strict";
        function arrayMove(src, srcIndex, dst, dstIndex, len) {
          for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
          }
        }
        function Queue(capacity) {
          this._capacity = capacity;
          this._length = 0;
          this._front = 0;
        }
        Queue.prototype._willBeOverCapacity = function(size2) {
          return this._capacity < size2;
        };
        Queue.prototype._pushOne = function(arg) {
          var length = this.length();
          this._checkCapacity(length + 1);
          var i = this._front + length & this._capacity - 1;
          this[i] = arg;
          this._length = length + 1;
        };
        Queue.prototype._unshiftOne = function(value) {
          var capacity = this._capacity;
          this._checkCapacity(this.length() + 1);
          var front = this._front;
          var i = (front - 1 & capacity - 1 ^ capacity) - capacity;
          this[i] = value;
          this._front = i;
          this._length = this.length() + 1;
        };
        Queue.prototype.unshift = function(fn, receiver, arg) {
          this._unshiftOne(arg);
          this._unshiftOne(receiver);
          this._unshiftOne(fn);
        };
        Queue.prototype.push = function(fn, receiver, arg) {
          var length = this.length() + 3;
          if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver);
            this._pushOne(arg);
            return;
          }
          var j = this._front + length - 3;
          this._checkCapacity(length);
          var wrapMask = this._capacity - 1;
          this[j + 0 & wrapMask] = fn;
          this[j + 1 & wrapMask] = receiver;
          this[j + 2 & wrapMask] = arg;
          this._length = length;
        };
        Queue.prototype.shift = function() {
          var front = this._front, ret2 = this[front];
          this[front] = void 0;
          this._front = front + 1 & this._capacity - 1;
          this._length--;
          return ret2;
        };
        Queue.prototype.length = function() {
          return this._length;
        };
        Queue.prototype._checkCapacity = function(size2) {
          if (this._capacity < size2) {
            this._resizeTo(this._capacity << 1);
          }
        };
        Queue.prototype._resizeTo = function(capacity) {
          var oldCapacity = this._capacity;
          this._capacity = capacity;
          var front = this._front;
          var length = this._length;
          var moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this, 0, this, oldCapacity, moveItemsCount);
        };
        module2.exports = Queue;
      }, {}], 29: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var isArray = _dereq_2("./util.js").isArray;
          var raceLater = function(promise) {
            return promise.then(function(array) {
              return race(array, promise);
            });
          };
          function race(promises, parent) {
            var maybePromise = tryConvertToPromise(promises);
            if (maybePromise instanceof Promise2) {
              return raceLater(maybePromise);
            } else if (!isArray(promises)) {
              return apiRejection("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n");
            }
            var ret2 = new Promise2(INTERNAL);
            if (parent !== void 0) {
              ret2._propagateFrom(parent, 4 | 1);
            }
            var fulfill = ret2._fulfill;
            var reject2 = ret2._reject;
            for (var i = 0, len = promises.length; i < len; ++i) {
              var val = promises[i];
              if (val === void 0 && !(i in promises)) {
                continue;
              }
              Promise2.cast(val)._then(fulfill, reject2, void 0, ret2, null);
            }
            return ret2;
          }
          Promise2.race = function(promises) {
            return race(promises, void 0);
          };
          Promise2.prototype.race = function() {
            return race(this, void 0);
          };
        };
      }, { "./util.js": 38 }], 30: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function ReductionPromiseArray(promises, fn, accum, _each) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            this._preservedValues = _each === INTERNAL ? [] : null;
            this._zerothIsAccum = accum === void 0;
            this._gotAccum = false;
            this._reducingIndex = this._zerothIsAccum ? 1 : 0;
            this._valuesPhase = void 0;
            var maybePromise = tryConvertToPromise(accum, this._promise);
            var rejected = false;
            var isPromise = maybePromise instanceof Promise2;
            if (isPromise) {
              maybePromise = maybePromise._target();
              if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, -1);
              } else if (maybePromise._isFulfilled()) {
                accum = maybePromise._value();
                this._gotAccum = true;
              } else {
                this._reject(maybePromise._reason());
                rejected = true;
              }
            }
            if (!(isPromise || this._zerothIsAccum))
              this._gotAccum = true;
            var domain = getDomain();
            this._callback = domain === null ? fn : domain.bind(fn);
            this._accum = accum;
            if (!rejected)
              async.invoke(init, this, void 0);
          }
          function init() {
            this._init$(void 0, -5);
          }
          util.inherits(ReductionPromiseArray, PromiseArray);
          ReductionPromiseArray.prototype._init = function() {
          };
          ReductionPromiseArray.prototype._resolveEmptyArray = function() {
            if (this._gotAccum || this._zerothIsAccum) {
              this._resolve(this._preservedValues !== null ? [] : this._accum);
            }
          };
          ReductionPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values2 = this._values;
            values2[index] = value;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var isEach = preservedValues !== null;
            var gotAccum = this._gotAccum;
            var valuesPhase = this._valuesPhase;
            var valuesPhaseIndex;
            if (!valuesPhase) {
              valuesPhase = this._valuesPhase = new Array(length);
              for (valuesPhaseIndex = 0; valuesPhaseIndex < length; ++valuesPhaseIndex) {
                valuesPhase[valuesPhaseIndex] = 0;
              }
            }
            valuesPhaseIndex = valuesPhase[index];
            if (index === 0 && this._zerothIsAccum) {
              this._accum = value;
              this._gotAccum = gotAccum = true;
              valuesPhase[index] = valuesPhaseIndex === 0 ? 1 : 2;
            } else if (index === -1) {
              this._accum = value;
              this._gotAccum = gotAccum = true;
            } else {
              if (valuesPhaseIndex === 0) {
                valuesPhase[index] = 1;
              } else {
                valuesPhase[index] = 2;
                this._accum = value;
              }
            }
            if (!gotAccum)
              return;
            var callback = this._callback;
            var receiver = this._promise._boundValue();
            var ret2;
            for (var i = this._reducingIndex; i < length; ++i) {
              valuesPhaseIndex = valuesPhase[i];
              if (valuesPhaseIndex === 2) {
                this._reducingIndex = i + 1;
                continue;
              }
              if (valuesPhaseIndex !== 1)
                return;
              value = values2[i];
              this._promise._pushContext();
              if (isEach) {
                preservedValues.push(value);
                ret2 = tryCatch2(callback).call(receiver, value, i, length);
              } else {
                ret2 = tryCatch2(callback).call(receiver, this._accum, value, i, length);
              }
              this._promise._popContext();
              if (ret2 === errorObj2)
                return this._reject(ret2.e);
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  valuesPhase[i] = 4;
                  return maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                  ret2 = maybePromise._value();
                } else {
                  return this._reject(maybePromise._reason());
                }
              }
              this._reducingIndex = i + 1;
              this._accum = ret2;
            }
            this._resolve(isEach ? preservedValues : this._accum);
          };
          function reduce(promises, fn, initialValue, _each) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
            return array.promise();
          }
          Promise2.prototype.reduce = function(fn, initialValue) {
            return reduce(this, fn, initialValue, null);
          };
          Promise2.reduce = function(promises, fn, initialValue, _each) {
            return reduce(promises, fn, initialValue, _each);
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 31: [function(_dereq_2, module2, exports2) {
        "use strict";
        var schedule;
        var util = _dereq_2("./util");
        var noAsyncScheduler = function() {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/m3OTXk\n");
        };
        if (util.isNode && typeof MutationObserver === "undefined") {
          var GlobalSetImmediate = global.setImmediate;
          var ProcessNextTick = process.nextTick;
          schedule = util.isRecentNode ? function(fn) {
            GlobalSetImmediate.call(global, fn);
          } : function(fn) {
            ProcessNextTick.call(process, fn);
          };
        } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && window.navigator.standalone)) {
          schedule = function(fn) {
            var div = document.createElement("div");
            var observer = new MutationObserver(fn);
            observer.observe(div, { attributes: true });
            return function() {
              div.classList.toggle("foo");
            };
          };
          schedule.isStatic = true;
        } else if (typeof setImmediate !== "undefined") {
          schedule = function(fn) {
            setImmediate(fn);
          };
        } else if (typeof setTimeout !== "undefined") {
          schedule = function(fn) {
            setTimeout(fn, 0);
          };
        } else {
          schedule = noAsyncScheduler;
        }
        module2.exports = schedule;
      }, { "./util": 38 }], 32: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray) {
          var PromiseInspection = Promise2.PromiseInspection;
          var util = _dereq_2("./util.js");
          function SettledPromiseArray(values2) {
            this.constructor$(values2);
          }
          util.inherits(SettledPromiseArray, PromiseArray);
          SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
            this._values[index] = inspection;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
            }
          };
          SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 268435456;
            ret2._settledValue = value;
            this._promiseResolved(index, ret2);
          };
          SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 134217728;
            ret2._settledValue = reason;
            this._promiseResolved(index, ret2);
          };
          Promise2.settle = function(promises) {
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.prototype.settle = function() {
            return new SettledPromiseArray(this).promise();
          };
        };
      }, { "./util.js": 38 }], 33: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection) {
          var util = _dereq_2("./util.js");
          var RangeError2 = _dereq_2("./errors.js").RangeError;
          var AggregateError = _dereq_2("./errors.js").AggregateError;
          var isArray = util.isArray;
          function SomePromiseArray(values2) {
            this.constructor$(values2);
            this._howMany = 0;
            this._unwrap = false;
            this._initialized = false;
          }
          util.inherits(SomePromiseArray, PromiseArray);
          SomePromiseArray.prototype._init = function() {
            if (!this._initialized) {
              return;
            }
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var isArrayResolved = isArray(this._values);
            if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
              this._reject(this._getRangeError(this.length()));
            }
          };
          SomePromiseArray.prototype.init = function() {
            this._initialized = true;
            this._init();
          };
          SomePromiseArray.prototype.setUnwrap = function() {
            this._unwrap = true;
          };
          SomePromiseArray.prototype.howMany = function() {
            return this._howMany;
          };
          SomePromiseArray.prototype.setHowMany = function(count) {
            this._howMany = count;
          };
          SomePromiseArray.prototype._promiseFulfilled = function(value) {
            this._addFulfilled(value);
            if (this._fulfilled() === this.howMany()) {
              this._values.length = this.howMany();
              if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
              } else {
                this._resolve(this._values);
              }
            }
          };
          SomePromiseArray.prototype._promiseRejected = function(reason) {
            this._addRejected(reason);
            if (this.howMany() > this._canPossiblyFulfill()) {
              var e = new AggregateError();
              for (var i = this.length(); i < this._values.length; ++i) {
                e.push(this._values[i]);
              }
              this._reject(e);
            }
          };
          SomePromiseArray.prototype._fulfilled = function() {
            return this._totalResolved;
          };
          SomePromiseArray.prototype._rejected = function() {
            return this._values.length - this.length();
          };
          SomePromiseArray.prototype._addRejected = function(reason) {
            this._values.push(reason);
          };
          SomePromiseArray.prototype._addFulfilled = function(value) {
            this._values[this._totalResolved++] = value;
          };
          SomePromiseArray.prototype._canPossiblyFulfill = function() {
            return this.length() - this._rejected();
          };
          SomePromiseArray.prototype._getRangeError = function(count) {
            var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
            return new RangeError2(message);
          };
          SomePromiseArray.prototype._resolveEmptyArray = function() {
            this._reject(this._getRangeError(0));
          };
          function some2(promises, howMany) {
            if ((howMany | 0) !== howMany || howMany < 0) {
              return apiRejection("expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n");
            }
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(howMany);
            ret2.init();
            return promise;
          }
          Promise2.some = function(promises, howMany) {
            return some2(promises, howMany);
          };
          Promise2.prototype.some = function(howMany) {
            return some2(this, howMany);
          };
          Promise2._SomePromiseArray = SomePromiseArray;
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 34: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function PromiseInspection(promise) {
            if (promise !== void 0) {
              promise = promise._target();
              this._bitField = promise._bitField;
              this._settledValue = promise._settledValue;
            } else {
              this._bitField = 0;
              this._settledValue = void 0;
            }
          }
          PromiseInspection.prototype.value = function() {
            if (!this.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n");
            }
            return this._settledValue;
          };
          PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
            if (!this.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n");
            }
            return this._settledValue;
          };
          PromiseInspection.prototype.isFulfilled = Promise2.prototype._isFulfilled = function() {
            return (this._bitField & 268435456) > 0;
          };
          PromiseInspection.prototype.isRejected = Promise2.prototype._isRejected = function() {
            return (this._bitField & 134217728) > 0;
          };
          PromiseInspection.prototype.isPending = Promise2.prototype._isPending = function() {
            return (this._bitField & 402653184) === 0;
          };
          PromiseInspection.prototype.isResolved = Promise2.prototype._isResolved = function() {
            return (this._bitField & 402653184) > 0;
          };
          Promise2.prototype.isPending = function() {
            return this._target()._isPending();
          };
          Promise2.prototype.isRejected = function() {
            return this._target()._isRejected();
          };
          Promise2.prototype.isFulfilled = function() {
            return this._target()._isFulfilled();
          };
          Promise2.prototype.isResolved = function() {
            return this._target()._isResolved();
          };
          Promise2.prototype._value = function() {
            return this._settledValue;
          };
          Promise2.prototype._reason = function() {
            this._unsetRejectionIsUnhandled();
            return this._settledValue;
          };
          Promise2.prototype.value = function() {
            var target = this._target();
            if (!target.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n");
            }
            return target._settledValue;
          };
          Promise2.prototype.reason = function() {
            var target = this._target();
            if (!target.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n");
            }
            target._unsetRejectionIsUnhandled();
            return target._settledValue;
          };
          Promise2.PromiseInspection = PromiseInspection;
        };
      }, {}], 35: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util.js");
          var errorObj2 = util.errorObj;
          var isObject3 = util.isObject;
          function tryConvertToPromise(obj2, context) {
            if (isObject3(obj2)) {
              if (obj2 instanceof Promise2) {
                return obj2;
              } else if (isAnyBluebirdPromise(obj2)) {
                var ret2 = new Promise2(INTERNAL);
                obj2._then(
                  ret2._fulfillUnchecked,
                  ret2._rejectUncheckedCheckError,
                  ret2._progressUnchecked,
                  ret2,
                  null
                );
                return ret2;
              }
              var then = util.tryCatch(getThen)(obj2);
              if (then === errorObj2) {
                if (context)
                  context._pushContext();
                var ret2 = Promise2.reject(then.e);
                if (context)
                  context._popContext();
                return ret2;
              } else if (typeof then === "function") {
                return doThenable(obj2, then, context);
              }
            }
            return obj2;
          }
          function getThen(obj2) {
            return obj2.then;
          }
          var hasProp = {}.hasOwnProperty;
          function isAnyBluebirdPromise(obj2) {
            return hasProp.call(obj2, "_promise0");
          }
          function doThenable(x, then, context) {
            var promise = new Promise2(INTERNAL);
            var ret2 = promise;
            if (context)
              context._pushContext();
            promise._captureStackTrace();
            if (context)
              context._popContext();
            var synchronous = true;
            var result2 = util.tryCatch(then).call(
              x,
              resolveFromThenable,
              rejectFromThenable,
              progressFromThenable
            );
            synchronous = false;
            if (promise && result2 === errorObj2) {
              promise._rejectCallback(result2.e, true, true);
              promise = null;
            }
            function resolveFromThenable(value) {
              if (!promise)
                return;
              promise._resolveCallback(value);
              promise = null;
            }
            function rejectFromThenable(reason) {
              if (!promise)
                return;
              promise._rejectCallback(reason, synchronous, true);
              promise = null;
            }
            function progressFromThenable(value) {
              if (!promise)
                return;
              if (typeof promise._progress === "function") {
                promise._progress(value);
              }
            }
            return ret2;
          }
          return tryConvertToPromise;
        };
      }, { "./util.js": 38 }], 36: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util.js");
          var TimeoutError = Promise2.TimeoutError;
          var afterTimeout = function(promise, message) {
            if (!promise.isPending())
              return;
            if (typeof message !== "string") {
              message = "operation timed out";
            }
            var err = new TimeoutError(message);
            util.markAsOriginatingFromRejection(err);
            promise._attachExtraTrace(err);
            promise._cancel(err);
          };
          var afterValue = function(value) {
            return delay(+this).thenReturn(value);
          };
          var delay = Promise2.delay = function(value, ms) {
            if (ms === void 0) {
              ms = value;
              value = void 0;
              var ret2 = new Promise2(INTERNAL);
              setTimeout(function() {
                ret2._fulfill();
              }, ms);
              return ret2;
            }
            ms = +ms;
            return Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          };
          Promise2.prototype.delay = function(ms) {
            return delay(this, ms);
          };
          function successClear(value) {
            var handle = this;
            if (handle instanceof Number)
              handle = +handle;
            clearTimeout(handle);
            return value;
          }
          function failureClear(reason) {
            var handle = this;
            if (handle instanceof Number)
              handle = +handle;
            clearTimeout(handle);
            throw reason;
          }
          Promise2.prototype.timeout = function(ms, message) {
            ms = +ms;
            var ret2 = this.then().cancellable();
            ret2._cancellationParent = this;
            var handle = setTimeout(function timeoutTimeout() {
              afterTimeout(ret2, message);
            }, ms);
            return ret2._then(successClear, failureClear, void 0, handle, void 0);
          };
        };
      }, { "./util.js": 38 }], 37: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext) {
          var TypeError2 = _dereq_2("./errors.js").TypeError;
          var inherits2 = _dereq_2("./util.js").inherits;
          var PromiseInspection = Promise2.PromiseInspection;
          function inspectionMapper(inspections) {
            var len = inspections.length;
            for (var i = 0; i < len; ++i) {
              var inspection = inspections[i];
              if (inspection.isRejected()) {
                return Promise2.reject(inspection.error());
              }
              inspections[i] = inspection._settledValue;
            }
            return inspections;
          }
          function thrower2(e) {
            setTimeout(function() {
              throw e;
            }, 0);
          }
          function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
              maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
          }
          function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret2 = Promise2.defer();
            function iterator() {
              if (i >= len)
                return ret2.resolve();
              var maybePromise = castPreservingDisposable(resources[i++]);
              if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
                try {
                  maybePromise = tryConvertToPromise(
                    maybePromise._getDisposer().tryDispose(inspection),
                    resources.promise
                  );
                } catch (e) {
                  return thrower2(e);
                }
                if (maybePromise instanceof Promise2) {
                  return maybePromise._then(
                    iterator,
                    thrower2,
                    null,
                    null,
                    null
                  );
                }
              }
              iterator();
            }
            iterator();
            return ret2.promise;
          }
          function disposerSuccess(value) {
            var inspection = new PromiseInspection();
            inspection._settledValue = value;
            inspection._bitField = 268435456;
            return dispose(this, inspection).thenReturn(value);
          }
          function disposerFail(reason) {
            var inspection = new PromiseInspection();
            inspection._settledValue = reason;
            inspection._bitField = 134217728;
            return dispose(this, inspection).thenThrow(reason);
          }
          function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
          }
          Disposer.prototype.data = function() {
            return this._data;
          };
          Disposer.prototype.promise = function() {
            return this._promise;
          };
          Disposer.prototype.resource = function() {
            if (this.promise().isFulfilled()) {
              return this.promise().value();
            }
            return null;
          };
          Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== void 0)
              context._pushContext();
            var ret2 = resource !== null ? this.doDispose(resource, inspection) : null;
            if (context !== void 0)
              context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret2;
          };
          Disposer.isDisposer = function(d) {
            return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
          };
          function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
          }
          inherits2(FunctionDisposer, Disposer);
          FunctionDisposer.prototype.doDispose = function(resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
          };
          function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
              this.resources[this.index]._setDisposable(value);
              return value.promise();
            }
            return value;
          }
          Promise2.using = function() {
            var len = arguments.length;
            if (len < 2)
              return apiRejection(
                "you must pass at least 2 arguments to Promise.using"
              );
            var fn = arguments[len - 1];
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            len--;
            var resources = new Array(len);
            for (var i = 0; i < len; ++i) {
              var resource = arguments[i];
              if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
              } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise2) {
                  resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                    resources,
                    index: i
                  }, void 0);
                }
              }
              resources[i] = resource;
            }
            var promise = Promise2.settle(resources).then(inspectionMapper).then(function(vals) {
              promise._pushContext();
              var ret2;
              try {
                ret2 = fn.apply(void 0, vals);
              } finally {
                promise._popContext();
              }
              return ret2;
            })._then(
              disposerSuccess,
              disposerFail,
              void 0,
              resources,
              void 0
            );
            resources.promise = promise;
            return promise;
          };
          Promise2.prototype._setDisposable = function(disposer) {
            this._bitField = this._bitField | 262144;
            this._disposer = disposer;
          };
          Promise2.prototype._isDisposable = function() {
            return (this._bitField & 262144) > 0;
          };
          Promise2.prototype._getDisposer = function() {
            return this._disposer;
          };
          Promise2.prototype._unsetDisposable = function() {
            this._bitField = this._bitField & ~262144;
            this._disposer = void 0;
          };
          Promise2.prototype.disposer = function(fn) {
            if (typeof fn === "function") {
              return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError2();
          };
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 38: [function(_dereq_, module, exports) {
        "use strict";
        var es5 = _dereq_("./es5.js");
        var canEvaluate = typeof navigator == "undefined";
        var haveGetters = function() {
          try {
            var o = {};
            es5.defineProperty(o, "f", {
              get: function() {
                return 3;
              }
            });
            return o.f === 3;
          } catch (e) {
            return false;
          }
        }();
        var errorObj = { e: {} };
        var tryCatchTarget;
        function tryCatcher() {
          try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
          } catch (e) {
            errorObj.e = e;
            return errorObj;
          }
        }
        function tryCatch(fn) {
          tryCatchTarget = fn;
          return tryCatcher;
        }
        var inherits = function(Child, Parent) {
          var hasProp = {}.hasOwnProperty;
          function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
              if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
              }
            }
          }
          T.prototype = Parent.prototype;
          Child.prototype = new T();
          return Child.prototype;
        };
        function isPrimitive(val) {
          return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
        }
        function isObject(value) {
          return !isPrimitive(value);
        }
        function maybeWrapAsError(maybeError) {
          if (!isPrimitive(maybeError))
            return maybeError;
          return new Error(safeToString(maybeError));
        }
        function withAppended(target, appendee) {
          var len = target.length;
          var ret2 = new Array(len + 1);
          var i;
          for (i = 0; i < len; ++i) {
            ret2[i] = target[i];
          }
          ret2[i] = appendee;
          return ret2;
        }
        function getDataPropertyOrDefault(obj2, key, defaultValue) {
          if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null) {
              return desc.get == null && desc.set == null ? desc.value : defaultValue;
            }
          } else {
            return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
          }
        }
        function notEnumerableProp(obj2, name, value) {
          if (isPrimitive(obj2))
            return obj2;
          var descriptor = {
            value,
            configurable: true,
            enumerable: false,
            writable: true
          };
          es5.defineProperty(obj2, name, descriptor);
          return obj2;
        }
        function thrower(r) {
          throw r;
        }
        var inheritedDataKeys = function() {
          var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ];
          var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (excludedPrototypes[i] === val) {
                return true;
              }
            }
            return false;
          };
          if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj2) {
              var ret2 = [];
              var visitedKeys = /* @__PURE__ */ Object.create(null);
              while (obj2 != null && !isExcludedProto(obj2)) {
                var keys2;
                try {
                  keys2 = getKeys(obj2);
                } catch (e) {
                  return ret2;
                }
                for (var i = 0; i < keys2.length; ++i) {
                  var key = keys2[i];
                  if (visitedKeys[key])
                    continue;
                  visitedKeys[key] = true;
                  var desc = Object.getOwnPropertyDescriptor(obj2, key);
                  if (desc != null && desc.get == null && desc.set == null) {
                    ret2.push(key);
                  }
                }
                obj2 = es5.getPrototypeOf(obj2);
              }
              return ret2;
            };
          } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj2) {
              if (isExcludedProto(obj2))
                return [];
              var ret2 = [];
              enumeration:
                for (var key in obj2) {
                  if (hasProp.call(obj2, key)) {
                    ret2.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret2.push(key);
                  }
                }
              return ret2;
            };
          }
        }();
        var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
        function isClass(fn) {
          try {
            if (typeof fn === "function") {
              var keys2 = es5.names(fn.prototype);
              var hasMethods = es5.isES5 && keys2.length > 1;
              var hasMethodsOtherThanConstructor = keys2.length > 0 && !(keys2.length === 1 && keys2[0] === "constructor");
              var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
              if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
              }
            }
            return false;
          } catch (e) {
            return false;
          }
        }
        function toFastProperties(obj) {
          function f() {
          }
          f.prototype = obj;
          var l = 8;
          while (l--)
            new f();
          return obj;
          eval(obj);
        }
        var rident = /^[a-z$_][a-z$_0-9]*$/i;
        function isIdentifier(str) {
          return rident.test(str);
        }
        function filledRange(count, prefix, suffix) {
          var ret2 = new Array(count);
          for (var i = 0; i < count; ++i) {
            ret2[i] = prefix + i + suffix;
          }
          return ret2;
        }
        function safeToString(obj2) {
          try {
            return obj2 + "";
          } catch (e) {
            return "[no string representation]";
          }
        }
        function markAsOriginatingFromRejection(e) {
          try {
            notEnumerableProp(e, "isOperational", true);
          } catch (ignore) {
          }
        }
        function originatesFromRejection(e) {
          if (e == null)
            return false;
          return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
        }
        function canAttachTrace(obj2) {
          return obj2 instanceof Error && es5.propertyIsWritable(obj2, "stack");
        }
        var ensureErrorObject = function() {
          if (!("stack" in new Error())) {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              try {
                throw new Error(safeToString(value));
              } catch (err) {
                return err;
              }
            };
          } else {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              return new Error(safeToString(value));
            };
          }
        }();
        function classString(obj2) {
          return {}.toString.call(obj2);
        }
        function copyDescriptors(from, to, filter2) {
          var keys2 = es5.names(from);
          for (var i = 0; i < keys2.length; ++i) {
            var key = keys2[i];
            if (filter2(key)) {
              try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
              } catch (ignore) {
              }
            }
          }
        }
        var ret = {
          isClass,
          isIdentifier,
          inheritedDataKeys,
          getDataPropertyOrDefault,
          thrower,
          isArray: es5.isArray,
          haveGetters,
          notEnumerableProp,
          isPrimitive,
          isObject,
          canEvaluate,
          errorObj,
          tryCatch,
          inherits,
          withAppended,
          maybeWrapAsError,
          toFastProperties,
          filledRange,
          toString: safeToString,
          canAttachTrace,
          ensureErrorObject,
          originatesFromRejection,
          markAsOriginatingFromRejection,
          classString,
          copyDescriptors,
          hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
          isNode: typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]"
        };
        ret.isRecentNode = ret.isNode && function() {
          var version = process.versions.node.split(".").map(Number);
          return version[0] === 0 && version[1] > 10 || version[0] > 0;
        }();
        if (ret.isNode)
          ret.toFastProperties(process);
        try {
          throw new Error();
        } catch (e) {
          ret.lastLineError = e;
        }
        module.exports = ret;
      }, { "./es5.js": 14 }] }, {}, [4])(4);
    });
    if (typeof window !== "undefined" && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== "undefined" && self !== null) {
      self.P = self.Promise;
    }
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/npm/node_modules/config-chain/node_modules/proto-list/proto-list.js
var require_proto_list = __commonJS({
  "node_modules/npm/node_modules/config-chain/node_modules/proto-list/proto-list.js"(exports2, module2) {
    module2.exports = ProtoList;
    function setProto(obj2, proto) {
      if (typeof Object.setPrototypeOf === "function")
        return Object.setPrototypeOf(obj2, proto);
      else
        obj2.__proto__ = proto;
    }
    function ProtoList() {
      this.list = [];
      var root2 = null;
      Object.defineProperty(this, "root", {
        get: function() {
          return root2;
        },
        set: function(r) {
          root2 = r;
          if (this.list.length) {
            setProto(this.list[this.list.length - 1], r);
          }
        },
        enumerable: true,
        configurable: true
      });
    }
    ProtoList.prototype = {
      get length() {
        return this.list.length;
      },
      get keys() {
        var k = [];
        for (var i in this.list[0])
          k.push(i);
        return k;
      },
      get snapshot() {
        var o = {};
        this.keys.forEach(function(k) {
          o[k] = this.get(k);
        }, this);
        return o;
      },
      get store() {
        return this.list[0];
      },
      push: function(obj2) {
        if (typeof obj2 !== "object")
          obj2 = { valueOf: obj2 };
        if (this.list.length >= 1) {
          setProto(this.list[this.list.length - 1], obj2);
        }
        setProto(obj2, this.root);
        return this.list.push(obj2);
      },
      pop: function() {
        if (this.list.length >= 2) {
          setProto(this.list[this.list.length - 2], this.root);
        }
        return this.list.pop();
      },
      unshift: function(obj2) {
        setProto(obj2, this.list[0] || this.root);
        return this.list.unshift(obj2);
      },
      shift: function() {
        if (this.list.length === 1) {
          setProto(this.list[0], this.root);
        }
        return this.list.shift();
      },
      get: function(key) {
        return this.list[0][key];
      },
      set: function(key, val, save) {
        if (!this.length)
          this.push({});
        if (save && this.list[0].hasOwnProperty(key))
          this.push({});
        return this.list[0][key] = val;
      },
      forEach: function(fn, thisp) {
        for (var key in this.list[0])
          fn.call(thisp, key, this.list[0][key]);
      },
      slice: function() {
        return this.list.slice.apply(this.list, arguments);
      },
      splice: function() {
        var ret2 = this.list.splice.apply(this.list, arguments);
        for (var i = 0, l2 = this.list.length; i < l2; i++) {
          setProto(this.list[i], this.list[i + 1] || this.root);
        }
        return ret2;
      }
    };
  }
});

// node_modules/npm/node_modules/ini/ini.js
var require_ini = __commonJS({
  "node_modules/npm/node_modules/ini/ini.js"(exports2) {
    exports2.parse = exports2.decode = decode;
    exports2.stringify = exports2.encode = encode;
    exports2.safe = safe;
    exports2.unsafe = unsafe;
    var eol = process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj2, opt) {
      var children = [], out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj2).forEach(function(k, _3, __) {
        var val = obj2[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object") {
          children.push(k);
        } else {
          out += safe(k) + separator + safe(val) + eol;
        }
      });
      if (opt.section && out.length) {
        out = "[" + safe(opt.section) + "]" + eol + out;
      }
      children.forEach(function(k, _3, __) {
        var nk = dotSplit(k).join("\\.");
        var section = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj2[k], {
          section,
          whitespace: opt.whitespace
        });
        if (out.length && child.length) {
          out += eol;
        }
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str) {
      var out = {}, p = out, section = null, state = "START", re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, lines = str.split(/[\r\n]+/g), section = null;
      lines.forEach(function(line, _3, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match = line.match(re);
        if (!match)
          return;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          p = out[section] = out[section] || {};
          return;
        }
        var key = unsafe(match[2]), value = match[3] ? unsafe(match[4] || "") : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (!p[key]) {
            p[key] = [];
          } else if (!Array.isArray(p[key])) {
            p[key] = [p[key]];
          }
        }
        if (Array.isArray(p[key])) {
          p[key].push(value);
        } else {
          p[key] = value;
        }
      });
      Object.keys(out).filter(function(k, _3, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
          return false;
        var parts = dotSplit(k), p2 = out, l2 = parts.pop(), nl = l2.replace(/\\\./g, ".");
        parts.forEach(function(part, _4, __2) {
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = {};
          p2 = p2[part];
        });
        if (p2 === out && nl === l2)
          return false;
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _3, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'") {
          val = val.substr(1, val.length - 2);
        }
        try {
          val = JSON.parse(val);
        } catch (_3) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l2 = val.length; i < l2; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1) {
            break;
          } else if (c === "\\") {
            esc = true;
          } else {
            unesc += c;
          }
        }
        if (esc)
          unesc += "\\";
        return unesc;
      }
      return val;
    }
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/npm/node_modules/config-chain/index.js
var require_config_chain = __commonJS({
  "node_modules/npm/node_modules/config-chain/index.js"(exports2, module2) {
    var ProtoList = require_proto_list();
    var path = require_path();
    var fs = require_fs();
    var ini = require_ini();
    var EE = require_events().EventEmitter;
    var url = require_url();
    var http = require_http();
    var exports2 = module2.exports = function() {
      var args = [].slice.call(arguments), conf = new ConfigChain();
      while (args.length) {
        var a = args.shift();
        if (a)
          conf.push("string" === typeof a ? json(a) : a);
      }
      return conf;
    };
    var find2 = exports2.find = function() {
      var rel = path.join.apply(null, [].slice.call(arguments));
      function find3(start, rel2) {
        var file = path.join(start, rel2);
        try {
          fs.statSync(file);
          return file;
        } catch (err) {
          if (path.dirname(start) !== start)
            return find3(path.dirname(start), rel2);
        }
      }
      return find3(__dirname, rel);
    };
    var parse = exports2.parse = function(content, file, type) {
      content = "" + content;
      if (!type) {
        try {
          return JSON.parse(content);
        } catch (er) {
          return ini.parse(content);
        }
      } else if (type === "json") {
        if (this.emit) {
          try {
            return JSON.parse(content);
          } catch (er) {
            this.emit("error", er);
          }
        } else {
          return JSON.parse(content);
        }
      } else {
        return ini.parse(content);
      }
    };
    var json = exports2.json = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      var file = path.join.apply(null, args);
      var content;
      try {
        content = fs.readFileSync(file, "utf-8");
      } catch (err) {
        return;
      }
      return parse(content, file, "json");
    };
    var env = exports2.env = function(prefix, env2) {
      env2 = env2 || process.env;
      var obj2 = {};
      var l2 = prefix.length;
      for (var k in env2) {
        if (k.indexOf(prefix) === 0)
          obj2[k.substring(l2)] = env2[k];
      }
      return obj2;
    };
    exports2.ConfigChain = ConfigChain;
    function ConfigChain() {
      EE.apply(this);
      ProtoList.apply(this, arguments);
      this._awaiting = 0;
      this._saving = 0;
      this.sources = {};
    }
    var extras = {
      constructor: { value: ConfigChain }
    };
    Object.keys(EE.prototype).forEach(function(k) {
      extras[k] = Object.getOwnPropertyDescriptor(EE.prototype, k);
    });
    ConfigChain.prototype = Object.create(ProtoList.prototype, extras);
    ConfigChain.prototype.del = function(key, where2) {
      if (where2) {
        var target = this.sources[where2];
        target = target && target.data;
        if (!target) {
          return this.emit("error", new Error("not found " + where2));
        }
        delete target[key];
      } else {
        for (var i = 0, l2 = this.list.length; i < l2; i++) {
          delete this.list[i][key];
        }
      }
      return this;
    };
    ConfigChain.prototype.set = function(key, value, where2) {
      var target;
      if (where2) {
        target = this.sources[where2];
        target = target && target.data;
        if (!target) {
          return this.emit("error", new Error("not found " + where2));
        }
      } else {
        target = this.list[0];
        if (!target) {
          return this.emit("error", new Error("cannot set, no confs!"));
        }
      }
      target[key] = value;
      return this;
    };
    ConfigChain.prototype.get = function(key, where2) {
      if (where2) {
        where2 = this.sources[where2];
        if (where2)
          where2 = where2.data;
        if (where2 && Object.hasOwnProperty.call(where2, key))
          return where2[key];
        return void 0;
      }
      return this.list[0][key];
    };
    ConfigChain.prototype.save = function(where2, type, cb2) {
      if (typeof type === "function")
        cb2 = type, type = null;
      var target = this.sources[where2];
      if (!target || !(target.path || target.source) || !target.data) {
        return this.emit("error", new Error("bad save target: " + where2));
      }
      if (target.source) {
        var pref = target.prefix || "";
        Object.keys(target.data).forEach(function(k) {
          target.source[pref + k] = target.data[k];
        });
        return this;
      }
      var type = type || target.type;
      var data = target.data;
      if (target.type === "json") {
        data = JSON.stringify(data);
      } else {
        data = ini.stringify(data);
      }
      this._saving++;
      fs.writeFile(target.path, data, "utf8", (function(er) {
        this._saving--;
        if (er) {
          if (cb2)
            return cb2(er);
          else
            return this.emit("error", er);
        }
        if (this._saving === 0) {
          if (cb2)
            cb2();
          this.emit("save");
        }
      }).bind(this));
      return this;
    };
    ConfigChain.prototype.addFile = function(file, type, name) {
      name = name || file;
      var marker = { __source__: name };
      this.sources[name] = { path: file, type };
      this.push(marker);
      this._await();
      fs.readFile(file, "utf8", (function(er, data) {
        if (er)
          this.emit("error", er);
        this.addString(data, file, type, marker);
      }).bind(this));
      return this;
    };
    ConfigChain.prototype.addEnv = function(prefix, env2, name) {
      name = name || "env";
      var data = exports2.env(prefix, env2);
      this.sources[name] = { data, source: env2, prefix };
      return this.add(data, name);
    };
    ConfigChain.prototype.addUrl = function(req, type, name) {
      this._await();
      var href = url.format(req);
      name = name || href;
      var marker = { __source__: name };
      this.sources[name] = { href, type };
      this.push(marker);
      http.request(req, (function(res) {
        var c = [];
        var ct = res.headers["content-type"];
        if (!type) {
          type = ct.indexOf("json") !== -1 ? "json" : ct.indexOf("ini") !== -1 ? "ini" : href.match(/\.json$/) ? "json" : href.match(/\.ini$/) ? "ini" : null;
          marker.type = type;
        }
        res.on("data", c.push.bind(c)).on("end", (function() {
          this.addString(Buffer.concat(c), href, type, marker);
        }).bind(this)).on("error", this.emit.bind(this, "error"));
      }).bind(this)).on("error", this.emit.bind(this, "error")).end();
      return this;
    };
    ConfigChain.prototype.addString = function(data, file, type, marker) {
      data = this.parse(data, file, type);
      this.add(data, marker);
      return this;
    };
    ConfigChain.prototype.add = function(data, marker) {
      if (marker && typeof marker === "object") {
        var i = this.list.indexOf(marker);
        if (i === -1) {
          return this.emit("error", new Error("bad marker"));
        }
        this.splice(i, 1, data);
        marker = marker.__source__;
        this.sources[marker] = this.sources[marker] || {};
        this.sources[marker].data = data;
        this._resolve();
      } else {
        if (typeof marker === "string") {
          this.sources[marker] = this.sources[marker] || {};
          this.sources[marker].data = data;
        }
        this._await();
        this.push(data);
        process.nextTick(this._resolve.bind(this));
      }
      return this;
    };
    ConfigChain.prototype.parse = exports2.parse;
    ConfigChain.prototype._await = function() {
      this._awaiting++;
    };
    ConfigChain.prototype._resolve = function() {
      this._awaiting--;
      if (this._awaiting === 0)
        this.emit("load", this);
    };
  }
});

// node_modules/npm/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/npm/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor2, superCtor) {
        ctor2.super_ = superCtor;
        ctor2.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor2,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      module2.exports = function inherits2(ctor2, superCtor) {
        ctor2.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor2.prototype = new TempCtor();
        ctor2.prototype.constructor = ctor2;
      };
    }
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/npm/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/npm/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && /* nomin */
    process.env && /* nomin */
    process.env.NODE_DEBUG && /* nomin */
    /\bsemver\b/i.test(process.env.NODE_DEBUG))
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    else
      debug = function() {
      };
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i])
        re[i] = new RegExp(src[i]);
    }
    var i;
    exports2.parse = parse;
    function parse(version, loose) {
      if (version instanceof SemVer)
        return version;
      if (typeof version !== "string")
        return null;
      if (version.length > MAX_LENGTH)
        return null;
      var r = loose ? re[LOOSE] : re[FULL];
      if (!r.test(version))
        return null;
      try {
        return new SemVer(version, loose);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, loose) {
      var v = parse(version, loose);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, loose) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), loose);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, loose) {
      if (version instanceof SemVer) {
        if (version.loose === loose)
          return version;
        else
          version = version.version;
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH)
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      if (!(this instanceof SemVer))
        return new SemVer(version, loose);
      debug("SemVer", version, loose);
      this.loose = loose;
      var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
      if (!m)
        throw new TypeError("Invalid Version: " + version);
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
        throw new TypeError("Invalid patch version");
      if (!m[4])
        this.prerelease = [];
      else
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER)
              return num;
          }
          return id;
        });
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length)
        this.version += "-" + this.prerelease.join(".");
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.loose, other);
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
      if (this.prerelease.length && !other.prerelease.length)
        return -1;
      else if (!this.prerelease.length && other.prerelease.length)
        return 1;
      else if (!this.prerelease.length && !other.prerelease.length)
        return 0;
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0)
          return 0;
        else if (b === void 0)
          return 1;
        else if (a === void 0)
          return -1;
        else if (a === b)
          continue;
        else
          return compareIdentifiers(a, b);
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0)
            this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
            this.major++;
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0)
            this.minor++;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0)
            this.patch++;
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1)
              this.prerelease.push(0);
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1]))
                this.prerelease = [identifier, 0];
            } else
              this.prerelease = [identifier, 0];
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq2(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        if (v1.prerelease.length || v2.prerelease.length) {
          for (var key in v1) {
            if (key === "major" || key === "minor" || key === "patch") {
              if (v1[key] !== v2[key]) {
                return "pre" + key;
              }
            }
          }
          return "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return key;
            }
          }
        }
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : a > b ? 1 : 0;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(b);
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq2;
    function eq2(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      var ret2;
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          ret2 = a === b;
          break;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          ret2 = a !== b;
          break;
        case "":
        case "=":
        case "==":
          ret2 = eq2(a, b, loose);
          break;
        case "!=":
          ret2 = neq(a, b, loose);
          break;
        case ">":
          ret2 = gt(a, b, loose);
          break;
        case ">=":
          ret2 = gte(a, b, loose);
          break;
        case "<":
          ret2 = lt(a, b, loose);
          break;
        case "<=":
          ret2 = lte(a, b, loose);
          break;
        default:
          throw new TypeError("Invalid operator: " + op);
      }
      return ret2;
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, loose) {
      if (comp instanceof Comparator) {
        if (comp.loose === loose)
          return comp;
        else
          comp = comp.value;
      }
      if (!(this instanceof Comparator))
        return new Comparator(comp, loose);
      debug("comparator", comp, loose);
      this.loose = loose;
      this.parse(comp);
      if (this.semver === ANY)
        this.value = "";
      else
        this.value = this.operator + this.semver.version;
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m)
        throw new TypeError("Invalid comparator: " + comp);
      this.operator = m[1];
      if (this.operator === "=")
        this.operator = "";
      if (!m[2])
        this.semver = ANY;
      else
        this.semver = new SemVer(m[2], this.loose);
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.loose);
      if (this.semver === ANY)
        return true;
      if (typeof version === "string")
        version = new SemVer(version, this.loose);
      return cmp(version, this.operator, this.semver, this.loose);
    };
    exports2.Range = Range;
    function Range(range2, loose) {
      if (range2 instanceof Range && range2.loose === loose)
        return range2;
      if (!(this instanceof Range))
        return new Range(range2, loose);
      this.loose = loose;
      this.raw = range2;
      this.set = range2.split(/\s*\|\|\s*/).map(function(range3) {
        return this.parseRange(range3.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range2);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range2) {
      var loose = this.loose;
      range2 = range2.trim();
      debug("range", range2, loose);
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace);
      debug("hyphen replace", range2);
      range2 = range2.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range2, re[COMPARATORTRIM]);
      range2 = range2.replace(re[TILDETRIM], tildeTrimReplace);
      range2 = range2.replace(re[CARETTRIM], caretTrimReplace);
      range2 = range2.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range2.split(" ").map(function(comp) {
        return parseComparator(comp, loose);
      }).join(" ").split(/\s+/);
      if (this.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, loose);
      });
      return set;
    };
    exports2.toComparators = toComparators;
    function toComparators(range2, loose) {
      return new Range(range2, loose).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, loose) {
      debug("comp", comp);
      comp = replaceCarets(comp, loose);
      debug("caret", comp);
      comp = replaceTildes(comp, loose);
      debug("tildes", comp);
      comp = replaceXRanges(comp, loose);
      debug("xrange", comp);
      comp = replaceStars(comp, loose);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, loose);
      }).join(" ");
    }
    function replaceTilde(comp, loose) {
      var r = loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_3, M, m, p, pr) {
        debug("tilde", comp, _3, M, m, p, pr);
        var ret2;
        if (isX(M))
          ret2 = "";
        else if (isX(m))
          ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        else if (isX(p))
          ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        else if (pr) {
          debug("replaceTilde pr", pr);
          if (pr.charAt(0) !== "-")
            pr = "-" + pr;
          ret2 = ">=" + M + "." + m + "." + p + pr + " <" + M + "." + (+m + 1) + ".0";
        } else
          ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        debug("tilde return", ret2);
        return ret2;
      });
    }
    function replaceCarets(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, loose);
      }).join(" ");
    }
    function replaceCaret(comp, loose) {
      debug("caret", comp, loose);
      var r = loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_3, M, m, p, pr) {
        debug("caret", comp, _3, M, m, p, pr);
        var ret2;
        if (isX(M))
          ret2 = "";
        else if (isX(m))
          ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        else if (isX(p)) {
          if (M === "0")
            ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          else
            ret2 = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (pr.charAt(0) !== "-")
            pr = "-" + pr;
          if (M === "0") {
            if (m === "0")
              ret2 = ">=" + M + "." + m + "." + p + pr + " <" + M + "." + m + "." + (+p + 1);
            else
              ret2 = ">=" + M + "." + m + "." + p + pr + " <" + M + "." + (+m + 1) + ".0";
          } else
            ret2 = ">=" + M + "." + m + "." + p + pr + " <" + (+M + 1) + ".0.0";
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0")
              ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            else
              ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          } else
            ret2 = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
        debug("caret return", ret2);
        return ret2;
      });
    }
    function replaceXRanges(comp, loose) {
      debug("replaceXRanges", comp, loose);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, loose);
      }).join(" ");
    }
    function replaceXRange(comp, loose) {
      comp = comp.trim();
      var r = loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret2, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret2, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX)
          gtlt = "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret2 = "<0.0.0";
          } else {
            ret2 = "*";
          }
        } else if (gtlt && anyX) {
          if (xm)
            m = 0;
          if (xp)
            p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else if (xp) {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm)
              M = +M + 1;
            else
              m = +m + 1;
          }
          ret2 = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret2);
        return ret2;
      });
    }
    function replaceStars(comp, loose) {
      debug("replaceStars", comp, loose);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM))
        from = "";
      else if (isX(fm))
        from = ">=" + fM + ".0.0";
      else if (isX(fp))
        from = ">=" + fM + "." + fm + ".0";
      else
        from = ">=" + from;
      if (isX(tM))
        to = "";
      else if (isX(tm))
        to = "<" + (+tM + 1) + ".0.0";
      else if (isX(tp))
        to = "<" + tM + "." + (+tm + 1) + ".0";
      else if (tpr)
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      else
        to = "<=" + to;
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version)
        return false;
      if (typeof version === "string")
        version = new SemVer(version, this.loose);
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version))
          return true;
      }
      return false;
    };
    function testSet(set, version) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version))
          return false;
      }
      if (version.prerelease.length) {
        for (var i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY)
            continue;
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch)
              return true;
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range2, loose) {
      try {
        range2 = new Range(range2, loose);
      } catch (er) {
        return false;
      }
      return range2.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range2, loose) {
      return versions.filter(function(version) {
        return satisfies(version, range2, loose);
      }).sort(function(a, b) {
        return rcompare(a, b, loose);
      })[0] || null;
    }
    exports2.validRange = validRange;
    function validRange(range2, loose) {
      try {
        return new Range(range2, loose).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range2, loose) {
      return outside(version, range2, "<", loose);
    }
    exports2.gtr = gtr;
    function gtr(version, range2, loose) {
      return outside(version, range2, ">", loose);
    }
    exports2.outside = outside;
    function outside(version, range2, hilo, loose) {
      version = new SemVer(version, loose);
      range2 = new Range(range2, loose);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range2, loose)) {
        return false;
      }
      for (var i2 = 0; i2 < range2.set.length; ++i2) {
        var comparators = range2.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, loose)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, loose)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/npm/node_modules/abbrev/abbrev.js
var require_abbrev = __commonJS({
  "node_modules/npm/node_modules/abbrev/abbrev.js"(exports2, module2) {
    module2.exports = exports2 = abbrev.abbrev = abbrev;
    abbrev.monkeyPatch = monkeyPatch;
    function monkeyPatch() {
      Object.defineProperty(Array.prototype, "abbrev", {
        value: function() {
          return abbrev(this);
        },
        enumerable: false,
        configurable: true,
        writable: true
      });
      Object.defineProperty(Object.prototype, "abbrev", {
        value: function() {
          return abbrev(Object.keys(this));
        },
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    function abbrev(list) {
      if (arguments.length !== 1 || !Array.isArray(list)) {
        list = Array.prototype.slice.call(arguments, 0);
      }
      for (var i = 0, l2 = list.length, args = []; i < l2; i++) {
        args[i] = typeof list[i] === "string" ? list[i] : String(list[i]);
      }
      args = args.sort(lexSort);
      var abbrevs = {}, prev = "";
      for (var i = 0, l2 = args.length; i < l2; i++) {
        var current = args[i], next = args[i + 1] || "", nextMatches = true, prevMatches = true;
        if (current === next)
          continue;
        for (var j = 0, cl = current.length; j < cl; j++) {
          var curChar = current.charAt(j);
          nextMatches = nextMatches && curChar === next.charAt(j);
          prevMatches = prevMatches && curChar === prev.charAt(j);
          if (!nextMatches && !prevMatches) {
            j++;
            break;
          }
        }
        prev = current;
        if (j === cl) {
          abbrevs[current] = current;
          continue;
        }
        for (var a = current.substr(0, j); j <= cl; j++) {
          abbrevs[a] = current;
          a += current.charAt(j);
        }
      }
      return abbrevs;
    }
    function lexSort(a, b) {
      return a === b ? 0 : a > b ? 1 : -1;
    }
  }
});

// node_modules/npm/node_modules/nopt/lib/nopt.js
var require_nopt = __commonJS({
  "node_modules/npm/node_modules/nopt/lib/nopt.js"(exports2, module2) {
    var debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG ? function() {
      console.error.apply(console, arguments);
    } : function() {
    };
    var url = require_url();
    var path = require_path();
    var Stream = require_stream().Stream;
    var abbrev = require_abbrev();
    module2.exports = exports2 = nopt;
    exports2.clean = clean;
    exports2.typeDefs = {
      String: { type: String, validate: validateString },
      Boolean: { type: Boolean, validate: validateBoolean },
      url: { type: url, validate: validateUrl },
      Number: { type: Number, validate: validateNumber },
      path: { type: path, validate: validatePath },
      Stream: { type: Stream, validate: validateStream },
      Date: { type: Date, validate: validateDate }
    };
    function nopt(types, shorthands, args, slice2) {
      args = args || process.argv;
      types = types || {};
      shorthands = shorthands || {};
      if (typeof slice2 !== "number")
        slice2 = 2;
      debug(types, shorthands, args, slice2);
      args = args.slice(slice2);
      var data = {}, key, remain = [], cooked = args, original = args.slice(0);
      parse(args, data, remain, types, shorthands);
      clean(data, types, exports2.typeDefs);
      data.argv = { remain, cooked, original };
      Object.defineProperty(data.argv, "toString", { value: function() {
        return this.original.map(JSON.stringify).join(" ");
      }, enumerable: false });
      return data;
    }
    function clean(data, types, typeDefs) {
      typeDefs = typeDefs || exports2.typeDefs;
      var remove = {}, typeDefault = [false, true, null, String, Array];
      Object.keys(data).forEach(function(k) {
        if (k === "argv")
          return;
        var val = data[k], isArray = Array.isArray(val), type = types[k];
        if (!isArray)
          val = [val];
        if (!type)
          type = typeDefault;
        if (type === Array)
          type = typeDefault.concat(Array);
        if (!Array.isArray(type))
          type = [type];
        debug("val=%j", val);
        debug("types=", type);
        val = val.map(function(val2) {
          if (typeof val2 === "string") {
            debug("string %j", val2);
            val2 = val2.trim();
            if (val2 === "null" && ~type.indexOf(null) || val2 === "true" && (~type.indexOf(true) || ~type.indexOf(Boolean)) || val2 === "false" && (~type.indexOf(false) || ~type.indexOf(Boolean))) {
              val2 = JSON.parse(val2);
              debug("jsonable %j", val2);
            } else if (~type.indexOf(Number) && !isNaN(val2)) {
              debug("convert to number", val2);
              val2 = +val2;
            } else if (~type.indexOf(Date) && !isNaN(Date.parse(val2))) {
              debug("convert to date", val2);
              val2 = new Date(val2);
            }
          }
          if (!types.hasOwnProperty(k)) {
            return val2;
          }
          if (val2 === false && ~type.indexOf(null) && !(~type.indexOf(false) || ~type.indexOf(Boolean))) {
            val2 = null;
          }
          var d = {};
          d[k] = val2;
          debug("prevalidated val", d, val2, types[k]);
          if (!validate(d, k, val2, types[k], typeDefs)) {
            if (exports2.invalidHandler) {
              exports2.invalidHandler(k, val2, types[k], data);
            } else if (exports2.invalidHandler !== false) {
              debug("invalid: " + k + "=" + val2, types[k]);
            }
            return remove;
          }
          debug("validated val", d, val2, types[k]);
          return d[k];
        }).filter(function(val2) {
          return val2 !== remove;
        });
        if (!val.length)
          delete data[k];
        else if (isArray) {
          debug(isArray, data[k], val);
          data[k] = val;
        } else
          data[k] = val[0];
        debug("k=%s val=%j", k, val, data[k]);
      });
    }
    function validateString(data, k, val) {
      data[k] = String(val);
    }
    function validatePath(data, k, val) {
      if (val === true)
        return false;
      if (val === null)
        return true;
      val = String(val);
      var homePattern = process.platform === "win32" ? /^~(\/|\\)/ : /^~\//;
      if (val.match(homePattern) && process.env.HOME) {
        val = path.resolve(process.env.HOME, val.substr(2));
      }
      data[k] = path.resolve(String(val));
      return true;
    }
    function validateNumber(data, k, val) {
      debug("validate Number %j %j %j", k, val, isNaN(val));
      if (isNaN(val))
        return false;
      data[k] = +val;
    }
    function validateDate(data, k, val) {
      debug("validate Date %j %j %j", k, val, Date.parse(val));
      var s = Date.parse(val);
      if (isNaN(s))
        return false;
      data[k] = new Date(val);
    }
    function validateBoolean(data, k, val) {
      if (val instanceof Boolean)
        val = val.valueOf();
      else if (typeof val === "string") {
        if (!isNaN(val))
          val = !!+val;
        else if (val === "null" || val === "false")
          val = false;
        else
          val = true;
      } else
        val = !!val;
      data[k] = val;
    }
    function validateUrl(data, k, val) {
      val = url.parse(String(val));
      if (!val.host)
        return false;
      data[k] = val.href;
    }
    function validateStream(data, k, val) {
      if (!(val instanceof Stream))
        return false;
      data[k] = val;
    }
    function validate(data, k, val, type, typeDefs) {
      if (Array.isArray(type)) {
        for (var i = 0, l2 = type.length; i < l2; i++) {
          if (type[i] === Array)
            continue;
          if (validate(data, k, val, type[i], typeDefs))
            return true;
        }
        delete data[k];
        return false;
      }
      if (type === Array)
        return true;
      if (type !== type) {
        debug("Poison NaN", k, val, type);
        delete data[k];
        return false;
      }
      if (val === type) {
        debug("Explicitly allowed %j", val);
        data[k] = val;
        return true;
      }
      var ok = false, types = Object.keys(typeDefs);
      for (var i = 0, l2 = types.length; i < l2; i++) {
        debug("test type %j %j %j", k, val, types[i]);
        var t = typeDefs[types[i]];
        if (t && (type && type.name && t.type && t.type.name ? type.name === t.type.name : type === t.type)) {
          var d = {};
          ok = false !== t.validate(d, k, val);
          val = d[k];
          if (ok) {
            data[k] = val;
            break;
          }
        }
      }
      debug("OK? %j (%j %j %j)", ok, k, val, types[i]);
      if (!ok)
        delete data[k];
      return ok;
    }
    function parse(args, data, remain, types, shorthands) {
      debug("parse", args, data, remain);
      var key = null, abbrevs = abbrev(Object.keys(types)), shortAbbr = abbrev(Object.keys(shorthands));
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        debug("arg", arg);
        if (arg.match(/^-{2,}$/)) {
          remain.push.apply(remain, args.slice(i + 1));
          args[i] = "--";
          break;
        }
        var hadEq = false;
        if (arg.charAt(0) === "-" && arg.length > 1) {
          if (arg.indexOf("=") !== -1) {
            hadEq = true;
            var v = arg.split("=");
            arg = v.shift();
            v = v.join("=");
            args.splice.apply(args, [i, 1].concat([arg, v]));
          }
          var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs);
          debug("arg=%j shRes=%j", arg, shRes);
          if (shRes) {
            debug(arg, shRes);
            args.splice.apply(args, [i, 1].concat(shRes));
            if (arg !== shRes[0]) {
              i--;
              continue;
            }
          }
          arg = arg.replace(/^-+/, "");
          var no = null;
          while (arg.toLowerCase().indexOf("no-") === 0) {
            no = !no;
            arg = arg.substr(3);
          }
          if (abbrevs[arg])
            arg = abbrevs[arg];
          var isArray = types[arg] === Array || Array.isArray(types[arg]) && types[arg].indexOf(Array) !== -1;
          if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {
            if (!Array.isArray(data[arg]))
              data[arg] = [data[arg]];
            isArray = true;
          }
          var val, la = args[i + 1];
          var isBool = typeof no === "boolean" || types[arg] === Boolean || Array.isArray(types[arg]) && types[arg].indexOf(Boolean) !== -1 || typeof types[arg] === "undefined" && !hadEq || la === "false" && (types[arg] === null || Array.isArray(types[arg]) && ~types[arg].indexOf(null));
          if (isBool) {
            val = !no;
            if (la === "true" || la === "false") {
              val = JSON.parse(la);
              la = null;
              if (no)
                val = !val;
              i++;
            }
            if (Array.isArray(types[arg]) && la) {
              if (~types[arg].indexOf(la)) {
                val = la;
                i++;
              } else if (la === "null" && ~types[arg].indexOf(null)) {
                val = null;
                i++;
              } else if (!la.match(/^-{2,}[^-]/) && !isNaN(la) && ~types[arg].indexOf(Number)) {
                val = +la;
                i++;
              } else if (!la.match(/^-[^-]/) && ~types[arg].indexOf(String)) {
                val = la;
                i++;
              }
            }
            if (isArray)
              (data[arg] = data[arg] || []).push(val);
            else
              data[arg] = val;
            continue;
          }
          if (types[arg] === String && la === void 0)
            la = "";
          if (la && la.match(/^-{2,}$/)) {
            la = void 0;
            i--;
          }
          val = la === void 0 ? true : la;
          if (isArray)
            (data[arg] = data[arg] || []).push(val);
          else
            data[arg] = val;
          i++;
          continue;
        }
        remain.push(arg);
      }
    }
    function resolveShort(arg, shorthands, shortAbbr, abbrevs) {
      arg = arg.replace(/^-+/, "");
      if (abbrevs[arg] === arg)
        return null;
      if (shorthands[arg]) {
        if (shorthands[arg] && !Array.isArray(shorthands[arg]))
          shorthands[arg] = shorthands[arg].split(/\s+/);
        return shorthands[arg];
      }
      var singles = shorthands.___singles;
      if (!singles) {
        singles = Object.keys(shorthands).filter(function(s) {
          return s.length === 1;
        }).reduce(function(l2, r) {
          l2[r] = true;
          return l2;
        }, {});
        shorthands.___singles = singles;
        debug("shorthand singles", singles);
      }
      var chrs = arg.split("").filter(function(c) {
        return singles[c];
      });
      if (chrs.join("") === arg)
        return chrs.map(function(c) {
          return shorthands[c];
        }).reduce(function(l2, r) {
          return l2.concat(r);
        }, []);
      if (abbrevs[arg] && !shorthands[arg])
        return null;
      if (shortAbbr[arg])
        arg = shortAbbr[arg];
      if (shorthands[arg] && !Array.isArray(shorthands[arg]))
        shorthands[arg] = shorthands[arg].split(/\s+/);
      return shorthands[arg];
    }
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/npm/node_modules/osenv/node_modules/os-tmpdir/index.js
var require_os_tmpdir = __commonJS({
  "node_modules/npm/node_modules/osenv/node_modules/os-tmpdir/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;
    module2.exports = function() {
      var path;
      if (isWindows) {
        path = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp";
      } else {
        path = process.env.TMPDIR || process.env.TMP || process.env.TEMP || "/tmp";
      }
      if (trailingSlashRe.test(path)) {
        path = path.slice(0, -1);
      }
      return path;
    };
  }
});

// node_modules/npm/node_modules/osenv/node_modules/os-homedir/index.js
var require_os_homedir = __commonJS({
  "node_modules/npm/node_modules/osenv/node_modules/os-homedir/index.js"(exports2, module2) {
    "use strict";
    var os = require_os();
    function homedir() {
      var env = process.env;
      var home = env.HOME;
      var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
      if (process.platform === "win32") {
        return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (user ? process.getuid() === 0 ? "/root" : "/home/" + user : null);
      }
      return home || null;
    }
    module2.exports = typeof os.homedir === "function" ? os.homedir : homedir;
  }
});

// node_modules/npm/node_modules/osenv/osenv.js
var require_osenv = __commonJS({
  "node_modules/npm/node_modules/osenv/osenv.js"(exports2) {
    var isWindows = process.platform === "win32";
    var path = require_path();
    var exec = require_child_process().exec;
    var osTmpdir = require_os_tmpdir();
    var osHomedir = require_os_homedir();
    function memo(key, lookup, fallback) {
      var fell = false;
      var falling = false;
      exports2[key] = function(cb2) {
        var val = lookup();
        if (!val && !fell && !falling && fallback) {
          fell = true;
          falling = true;
          exec(fallback, function(er, output, stderr) {
            falling = false;
            if (er)
              return;
            val = output.trim();
          });
        }
        exports2[key] = function(cb3) {
          if (cb3)
            process.nextTick(cb3.bind(null, null, val));
          return val;
        };
        if (cb2 && !falling)
          process.nextTick(cb2.bind(null, null, val));
        return val;
      };
    }
    memo("user", function() {
      return isWindows ? process.env.USERDOMAIN + "\\" + process.env.USERNAME : process.env.USER;
    }, "whoami");
    memo("prompt", function() {
      return isWindows ? process.env.PROMPT : process.env.PS1;
    });
    memo("hostname", function() {
      return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME;
    }, "hostname");
    memo("tmpdir", function() {
      return osTmpdir();
    });
    memo("home", function() {
      return osHomedir();
    });
    memo("path", function() {
      return (process.env.PATH || process.env.Path || process.env.path).split(isWindows ? ";" : ":");
    });
    memo("editor", function() {
      return process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi");
    });
    memo("shell", function() {
      return isWindows ? process.env.ComSpec || "cmd" : process.env.SHELL || "bash";
    });
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/npm/node_modules/umask/index.js
var require_umask = __commonJS({
  "node_modules/npm/node_modules/umask/index.js"(exports2) {
    "use strict";
    var util = require_util();
    function toString2(val) {
      val = val.toString(8);
      while (val.length < 4) {
        val = "0" + val;
      }
      return val;
    }
    var defaultUmask = 18;
    var defaultUmaskString = toString2(defaultUmask);
    function validate(data, k, val) {
      if (typeof val === "number" && !isNaN(val)) {
        data[k] = val;
        return true;
      }
      if (typeof val === "string") {
        if (val.charAt(0) !== "0") {
          return false;
        }
        data[k] = parseInt(val, 8);
        return true;
      }
      return false;
    }
    function convert_fromString(val, cb2) {
      if (typeof val === "string") {
        if (val.charAt(0) === "0" && /^[0-7]+$/.test(val)) {
          val = parseInt(val, 8);
        } else if (val.charAt(0) !== "0" && /^[0-9]+$/.test(val)) {
          val = parseInt(val, 10);
        } else {
          return cb2(
            new Error(util.format(
              "Expected octal string, got %j, defaulting to %j",
              val,
              defaultUmaskString
            )),
            defaultUmask
          );
        }
      } else if (typeof val !== "number") {
        return cb2(
          new Error(util.format(
            "Expected number or octal string, got %j, defaulting to %j",
            val,
            defaultUmaskString
          )),
          defaultUmask
        );
      }
      val = Math.floor(val);
      if (val < 0 || val > 511) {
        return cb2(
          new Error(util.format("Must be in range 0..511 (0000..0777), got %j", val)),
          defaultUmask
        );
      }
      cb2(null, val);
    }
    function fromString(val, cb2) {
      convert_fromString(val, cb2 || function(err, result2) {
        val = result2;
      });
      return val;
    }
    exports2.toString = toString2;
    exports2.fromString = fromString;
    exports2.validate = validate;
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/tracker-base.js
var require_tracker_base = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/tracker-base.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_events().EventEmitter;
    var util = require_util();
    var trackerId = 0;
    var TrackerBase = module2.exports = function(name) {
      EventEmitter.call(this);
      this.id = ++trackerId;
      this.name = name;
    };
    util.inherits(TrackerBase, EventEmitter);
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/tracker.js
var require_tracker = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/tracker.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var TrackerBase = require_tracker_base();
    var Tracker = module2.exports = function(name, todo) {
      TrackerBase.call(this, name);
      this.workDone = 0;
      this.workTodo = todo || 0;
    };
    util.inherits(Tracker, TrackerBase);
    Tracker.prototype.completed = function() {
      return this.workTodo === 0 ? 0 : this.workDone / this.workTodo;
    };
    Tracker.prototype.addWork = function(work) {
      this.workTodo += work;
      this.emit("change", this.name, this.completed(), this);
    };
    Tracker.prototype.completeWork = function(work) {
      this.workDone += work;
      if (this.workDone > this.workTodo)
        this.workDone = this.workTodo;
      this.emit("change", this.name, this.completed(), this);
    };
    Tracker.prototype.finish = function() {
      this.workTodo = this.workDone = 1;
      this.emit("change", this.name, 1, this);
    };
  }
});

// node_modules/npm/node_modules/readable-stream/node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/npm/node_modules/readable-stream/node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (!process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = nextTick;
    } else {
      module2.exports = process.nextTick;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/npm/node_modules/readable-stream/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/npm/node_modules/readable-stream/node_modules/isarray/index.js"(exports2, module2) {
    var toString2 = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/npm/node_modules/readable-stream/node_modules/buffer-shims/index.js
var require_buffer_shims = __commonJS({
  "node_modules/npm/node_modules/readable-stream/node_modules/buffer-shims/index.js"(exports2) {
    "use strict";
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    var SlowBuffer = buffer.SlowBuffer;
    var MAX_LEN = buffer.kMaxLength || 2147483647;
    exports2.alloc = function alloc(size2, fill, encoding) {
      if (typeof Buffer2.alloc === "function") {
        return Buffer2.alloc(size2, fill, encoding);
      }
      if (typeof encoding === "number") {
        throw new TypeError("encoding must not be number");
      }
      if (typeof size2 !== "number") {
        throw new TypeError("size must be a number");
      }
      if (size2 > MAX_LEN) {
        throw new RangeError("size is too large");
      }
      var enc = encoding;
      var _fill = fill;
      if (_fill === void 0) {
        enc = void 0;
        _fill = 0;
      }
      var buf = new Buffer2(size2);
      if (typeof _fill === "string") {
        var fillBuf = new Buffer2(_fill, enc);
        var flen = fillBuf.length;
        var i = -1;
        while (++i < size2) {
          buf[i] = fillBuf[i % flen];
        }
      } else {
        buf.fill(_fill);
      }
      return buf;
    };
    exports2.allocUnsafe = function allocUnsafe(size2) {
      if (typeof Buffer2.allocUnsafe === "function") {
        return Buffer2.allocUnsafe(size2);
      }
      if (typeof size2 !== "number") {
        throw new TypeError("size must be a number");
      }
      if (size2 > MAX_LEN) {
        throw new RangeError("size is too large");
      }
      return new Buffer2(size2);
    };
    exports2.from = function from(value, encodingOrOffset, length) {
      if (typeof Buffer2.from === "function" && (!global.Uint8Array || Uint8Array.from !== Buffer2.from)) {
        return Buffer2.from(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof value === "string") {
        return new Buffer2(value, encodingOrOffset);
      }
      if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        var offset = encodingOrOffset;
        if (arguments.length === 1) {
          return new Buffer2(value);
        }
        if (typeof offset === "undefined") {
          offset = 0;
        }
        var len = length;
        if (typeof len === "undefined") {
          len = value.byteLength - offset;
        }
        if (offset >= value.byteLength) {
          throw new RangeError("'offset' is out of bounds");
        }
        if (len > value.byteLength - offset) {
          throw new RangeError("'length' is out of bounds");
        }
        return new Buffer2(value.slice(offset, offset + len));
      }
      if (Buffer2.isBuffer(value)) {
        var out = new Buffer2(value.length);
        value.copy(out, 0, 0, value.length);
        return out;
      }
      if (value) {
        if (Array.isArray(value) || typeof ArrayBuffer !== "undefined" && value.buffer instanceof ArrayBuffer || "length" in value) {
          return new Buffer2(value);
        }
        if (value.type === "Buffer" && Array.isArray(value.data)) {
          return new Buffer2(value.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    };
    exports2.allocUnsafeSlow = function allocUnsafeSlow(size2) {
      if (typeof Buffer2.allocUnsafeSlow === "function") {
        return Buffer2.allocUnsafeSlow(size2);
      }
      if (typeof size2 !== "number") {
        throw new TypeError("size must be a number");
      }
      if (size2 >= MAX_LEN) {
        throw new RangeError("size is too large");
      }
      return new SlowBuffer(size2);
    };
  }
});

// node_modules/npm/node_modules/readable-stream/node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/npm/node_modules/readable-stream/node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean2;
    function isNull2(arg) {
      return arg === null;
    }
    exports2.isNull = isNull2;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined2(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined2;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject3(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject3;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/npm/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/npm/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_buffer().Buffer;
    var bufferShim = require_buffer_shims();
    module2.exports = BufferList;
    function BufferList() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret2 = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret2;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret2 = "" + p.data;
      while (p = p.next) {
        ret2 += s + p.data;
      }
      return ret2;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return bufferShim.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret2 = bufferShim.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret2, i);
        i += p.data.length;
        p = p.next;
      }
      return ret2;
    };
  }
});

// node_modules/npm/node_modules/readable-stream/node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/npm/node_modules/readable-stream/node_modules/util-deprecate/browser.js"(exports2, module2) {
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_3) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/npm/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/npm/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    var processNextTick = require_process_nextick_args();
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
    Writable.WritableState = WritableState;
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream;
    (function() {
      try {
        Stream = require_stream();
      } catch (_3) {
      } finally {
        if (!Stream)
          Stream = require_events().EventEmitter;
      }
    })();
    var Buffer2 = require_buffer().Buffer;
    var bufferShim = require_buffer_shims();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WriteReq(chunk2, encoding, cb2) {
      this.chunk = chunk2;
      this.encoding = encoding;
      this.callback = cb2;
      this.next = null;
    }
    var Duplex;
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
        });
      } catch (_3) {
      }
    })();
    var Duplex;
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb2) {
      var er = new Error("write after end");
      stream.emit("error", er);
      processNextTick(cb2, er);
    }
    function validChunk(stream, state, chunk2, cb2) {
      var valid = true;
      var er = false;
      if (chunk2 === null) {
        er = new TypeError("May not write null values to stream");
      } else if (!Buffer2.isBuffer(chunk2) && typeof chunk2 !== "string" && chunk2 !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        processNextTick(cb2, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk2, encoding, cb2) {
      var state = this._writableState;
      var ret2 = false;
      if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk2))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb2 !== "function")
        cb2 = nop;
      if (state.ended)
        writeAfterEnd(this, cb2);
      else if (validChunk(this, state, chunk2, cb2)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, chunk2, encoding, cb2);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk2, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk2 === "string") {
        chunk2 = bufferShim.from(chunk2, encoding);
      }
      return chunk2;
    }
    function writeOrBuffer(stream, state, chunk2, encoding, cb2) {
      chunk2 = decodeChunk(state, chunk2, encoding);
      if (Buffer2.isBuffer(chunk2))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk2.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk2, encoding, cb2);
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk2, encoding, cb2);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk2, encoding, cb2) {
      state.writelen = len;
      state.writecb = cb2;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk2, state.onwrite);
      else
        stream._write(chunk2, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb2) {
      --state.pendingcb;
      if (sync)
        processNextTick(cb2, er);
      else
        cb2(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb2 = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb2);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb2);
        } else {
          afterWrite(stream, state, finished, cb2);
        }
      }
    }
    function afterWrite(stream, state, finished, cb2) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb2();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        while (entry) {
          buffer[count] = entry;
          entry = entry.next;
          count += 1;
        }
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
      } else {
        while (entry) {
          var chunk2 = entry.chunk;
          var encoding = entry.encoding;
          var cb2 = entry.callback;
          var len = state.objectMode ? 1 : chunk2.length;
          doWrite(stream, state, false, len, chunk2, encoding, cb2);
          entry = entry.next;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequestCount = 0;
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk2, encoding, cb2) {
      cb2(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk2, encoding, cb2) {
      var state = this._writableState;
      if (typeof chunk2 === "function") {
        cb2 = chunk2;
        chunk2 = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (chunk2 !== null && chunk2 !== void 0)
        this.write(chunk2, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb2);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit("finish");
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }
    function endWritable(stream, state, cb2) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb2) {
        if (state.finished)
          processNextTick(cb2);
        else
          stream.once("finish", cb2);
      }
      state.ended = true;
      stream.writable = false;
    }
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function(err) {
        var entry = _this.entry;
        _this.entry = null;
        while (entry) {
          var cb2 = entry.callback;
          state.pendingcb--;
          cb2(err);
          entry = entry.next;
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = _this;
        } else {
          state.corkedRequestsFree = _this;
        }
      };
    }
  }
});

// node_modules/npm/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/npm/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj2) {
      var keys3 = [];
      for (var key in obj2) {
        keys3.push(key);
      }
      return keys3;
    };
    module2.exports = Duplex;
    var processNextTick = require_process_nextick_args();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    var keys2 = objectKeys(Writable.prototype);
    for (v = 0; v < keys2.length; v++) {
      method = keys2[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      processNextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
  }
});

// node_modules/npm/node_modules/readable-stream/node_modules/string_decoder/index.js
var require_string_decoder = __commonJS({
  "node_modules/npm/node_modules/readable-stream/node_modules/string_decoder/index.js"(exports2) {
    var Buffer2 = require_buffer().Buffer;
    var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    var StringDecoder = exports2.StringDecoder = function(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer2(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size2 = this.surrogateSize;
        this.charLength += size2;
        this.charReceived += size2;
        this.charBuffer.copy(this.charBuffer, size2, 0, size2);
        buffer.copy(this.charBuffer, 0, 0, size2);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// node_modules/npm/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/npm/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var processNextTick = require_process_nextick_args();
    var isArray = require_isarray();
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream;
    (function() {
      try {
        Stream = require_stream();
      } catch (_3) {
      } finally {
        if (!Stream)
          Stream = require_events().EventEmitter;
      }
    })();
    var Buffer2 = require_buffer().Buffer;
    var bufferShim = require_buffer_shims();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var debugUtil = require_util();
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var StringDecoder;
    util.inherits(Readable, Stream);
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") {
        return emitter.prependListener(event, fn);
      } else {
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
    }
    var Duplex;
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    var Duplex;
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options && typeof options.read === "function")
        this._read = options.read;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk2, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk2 === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk2 = bufferShim.from(chunk2, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk2, encoding, false);
    };
    Readable.prototype.unshift = function(chunk2) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk2, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    function readableAddChunk(stream, state, chunk2, encoding, addToFront) {
      var er = chunkInvalid(state, chunk2);
      if (er) {
        stream.emit("error", er);
      } else if (chunk2 === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk2 && chunk2.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream.emit("error", e);
        } else if (state.endEmitted && addToFront) {
          var _e = new Error("stream.unshift() after end event");
          stream.emit("error", _e);
        } else {
          var skipAdd;
          if (state.decoder && !addToFront && !encoding) {
            chunk2 = state.decoder.write(chunk2);
            skipAdd = !state.objectMode && chunk2.length === 0;
          }
          if (!addToFront)
            state.reading = false;
          if (!skipAdd) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit("data", chunk2);
              stream.read(0);
            } else {
              state.length += state.objectMode ? 1 : chunk2.length;
              if (addToFront)
                state.buffer.unshift(chunk2);
              else
                state.buffer.push(chunk2);
              if (state.needReadable)
                emitReadable(stream);
            }
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function chunkInvalid(state, chunk2) {
      var er = null;
      if (!Buffer2.isBuffer(chunk2) && typeof chunk2 !== "string" && chunk2 !== null && chunk2 !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk2 = state.decoder.end();
        if (chunk2 && chunk2.length) {
          state.buffer.push(chunk2);
          state.length += state.objectMode ? 1 : chunk2.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          processNextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        processNextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        processNextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk2) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk2);
        if (false === ret2 && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            processNextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        processNextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk2 = state.decoder.end();
          if (chunk2 && chunk2.length)
            self2.push(chunk2);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk2) {
        debug("wrapped data");
        if (state.decoder)
          chunk2 = state.decoder.write(chunk2);
        if (state.objectMode && (chunk2 === null || chunk2 === void 0))
          return;
        else if (!state.objectMode && (!chunk2 || !chunk2.length))
          return;
        var ret2 = self2.push(chunk2);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.head.data;
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret2 += str;
        else
          ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = bufferShim.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        processNextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function forEach(xs, f2) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        f2(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/npm/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/npm/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function TransformState(stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb2 = ts.writecb;
      if (!cb2)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== void 0)
        stream.push(data);
      cb2(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.once("prefinish", function() {
        if (typeof this._flush === "function")
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk2, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk2, encoding);
    };
    Transform.prototype._transform = function(chunk2, encoding, cb2) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk2, encoding, cb2) {
      var ts = this._transformState;
      ts.writecb = cb2;
      ts.writechunk = chunk2;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/npm/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/npm/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk2, encoding, cb2) {
      cb2(null, chunk2);
    };
  }
});

// node_modules/npm/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/npm/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = function() {
      try {
        return require_stream();
      } catch (_3) {
      }
    }();
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    if (!process.browser && process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
    }
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/node_modules/delegates/index.js
var require_delegates = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/node_modules/delegates/index.js"(exports2, module2) {
    module2.exports = Delegator;
    function Delegator(proto, target) {
      if (!(this instanceof Delegator))
        return new Delegator(proto, target);
      this.proto = proto;
      this.target = target;
      this.methods = [];
      this.getters = [];
      this.setters = [];
      this.fluents = [];
    }
    Delegator.prototype.method = function(name) {
      var proto = this.proto;
      var target = this.target;
      this.methods.push(name);
      proto[name] = function() {
        return this[target][name].apply(this[target], arguments);
      };
      return this;
    };
    Delegator.prototype.access = function(name) {
      return this.getter(name).setter(name);
    };
    Delegator.prototype.getter = function(name) {
      var proto = this.proto;
      var target = this.target;
      this.getters.push(name);
      proto.__defineGetter__(name, function() {
        return this[target][name];
      });
      return this;
    };
    Delegator.prototype.setter = function(name) {
      var proto = this.proto;
      var target = this.target;
      this.setters.push(name);
      proto.__defineSetter__(name, function(val) {
        return this[target][name] = val;
      });
      return this;
    };
    Delegator.prototype.fluent = function(name) {
      var proto = this.proto;
      var target = this.target;
      this.fluents.push(name);
      proto[name] = function(val) {
        if ("undefined" != typeof val) {
          this[target][name] = val;
          return this;
        } else {
          return this[target][name];
        }
      };
      return this;
    };
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/tracker-stream.js
var require_tracker_stream = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/tracker-stream.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var stream = require_readable();
    var delegate = require_delegates();
    var Tracker = require_tracker();
    var TrackerStream = module2.exports = function(name, size2, options) {
      stream.Transform.call(this, options);
      this.tracker = new Tracker(name, size2);
      this.name = name;
      this.id = this.tracker.id;
      this.tracker.on("change", delegateChange(this));
    };
    util.inherits(TrackerStream, stream.Transform);
    function delegateChange(trackerStream) {
      return function(name, completion, tracker) {
        trackerStream.emit("change", name, completion, trackerStream);
      };
    }
    TrackerStream.prototype._transform = function(data, encoding, cb2) {
      this.tracker.completeWork(data.length ? data.length : 1);
      this.push(data);
      cb2();
    };
    TrackerStream.prototype._flush = function(cb2) {
      this.tracker.finish();
      cb2();
    };
    delegate(TrackerStream.prototype, "tracker").method("completed").method("addWork");
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/tracker-group.js
var require_tracker_group = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/tracker-group.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var TrackerBase = require_tracker_base();
    var Tracker = require_tracker();
    var TrackerStream = require_tracker_stream();
    var TrackerGroup = module2.exports = function(name) {
      TrackerBase.call(this, name);
      this.parentGroup = null;
      this.trackers = [];
      this.completion = {};
      this.weight = {};
      this.totalWeight = 0;
      this.finished = false;
      this.bubbleChange = bubbleChange(this);
    };
    util.inherits(TrackerGroup, TrackerBase);
    function bubbleChange(trackerGroup) {
      return function(name, completed, tracker) {
        trackerGroup.completion[tracker.id] = completed;
        if (trackerGroup.finished)
          return;
        trackerGroup.emit("change", name || trackerGroup.name, trackerGroup.completed(), trackerGroup);
      };
    }
    TrackerGroup.prototype.nameInTree = function() {
      var names = [];
      var from = this;
      while (from) {
        names.unshift(from.name);
        from = from.parentGroup;
      }
      return names.join("/");
    };
    TrackerGroup.prototype.addUnit = function(unit, weight) {
      if (unit.addUnit) {
        var toTest = this;
        while (toTest) {
          if (unit === toTest) {
            throw new Error(
              "Attempted to add tracker group " + unit.name + " to tree that already includes it " + this.nameInTree(this)
            );
          }
          toTest = toTest.parentGroup;
        }
        unit.parentGroup = this;
      }
      this.weight[unit.id] = weight || 1;
      this.totalWeight += this.weight[unit.id];
      this.trackers.push(unit);
      this.completion[unit.id] = unit.completed();
      unit.on("change", this.bubbleChange);
      if (!this.finished)
        this.emit("change", unit.name, this.completion[unit.id], unit);
      return unit;
    };
    TrackerGroup.prototype.completed = function() {
      if (this.trackers.length === 0)
        return 0;
      var valPerWeight = 1 / this.totalWeight;
      var completed = 0;
      for (var ii = 0; ii < this.trackers.length; ii++) {
        var trackerId = this.trackers[ii].id;
        completed += valPerWeight * this.weight[trackerId] * this.completion[trackerId];
      }
      return completed;
    };
    TrackerGroup.prototype.newGroup = function(name, weight) {
      return this.addUnit(new TrackerGroup(name), weight);
    };
    TrackerGroup.prototype.newItem = function(name, todo, weight) {
      return this.addUnit(new Tracker(name, todo), weight);
    };
    TrackerGroup.prototype.newStream = function(name, todo, weight) {
      return this.addUnit(new TrackerStream(name, todo), weight);
    };
    TrackerGroup.prototype.finish = function() {
      this.finished = true;
      if (!this.trackers.length)
        this.addUnit(new Tracker(), 1, true);
      for (var ii = 0; ii < this.trackers.length; ii++) {
        var tracker = this.trackers[ii];
        tracker.finish();
        tracker.removeListener("change", this.bubbleChange);
      }
      this.emit("change", this.name, 1, this);
    };
    var buffer = "                                  ";
    TrackerGroup.prototype.debug = function(depth) {
      depth = depth || 0;
      var indent = depth ? buffer.substr(0, depth) : "";
      var output = indent + (this.name || "top") + ": " + this.completed() + "\n";
      this.trackers.forEach(function(tracker) {
        if (tracker instanceof TrackerGroup) {
          output += tracker.debug(depth + 1);
        } else {
          output += indent + " " + tracker.name + ": " + tracker.completed() + "\n";
        }
      });
      return output;
    };
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/index.js
var require_are_we_there_yet = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/are-we-there-yet/index.js"(exports2) {
    "use strict";
    exports2.TrackerGroup = require_tracker_group();
    exports2.Tracker = require_tracker();
    exports2.TrackerStream = require_tracker_stream();
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/has-unicode/index.js
var require_has_unicode = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/has-unicode/index.js"(exports2, module2) {
    "use strict";
    var os = require_os();
    var hasUnicode = module2.exports = function() {
      if (os.type() == "Windows_NT") {
        return false;
      }
      var isUTF8 = /[.]UTF-8/;
      if (isUTF8.test(process.env.LC_ALL) || process.env.LC_CTYPE == "UTF-8" || isUTF8.test(process.env.LANG)) {
        return true;
      }
      return false;
    };
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/npm/node_modules/ansi/lib/newlines.js
var require_newlines = __commonJS({
  "node_modules/npm/node_modules/ansi/lib/newlines.js"(exports2, module2) {
    var assert = require_assert();
    var NEWLINE = "\n".charCodeAt(0);
    function emitNewlineEvents(stream) {
      if (stream._emittingNewlines) {
        return;
      }
      var write = stream.write;
      stream.write = function(data) {
        var rtn = write.apply(stream, arguments);
        if (stream.listeners("newline").length > 0) {
          var len = data.length, i = 0;
          if (typeof data == "string") {
            for (; i < len; i++) {
              processByte(stream, data.charCodeAt(i));
            }
          } else {
            for (; i < len; i++) {
              processByte(stream, data[i]);
            }
          }
        }
        return rtn;
      };
      stream._emittingNewlines = true;
    }
    module2.exports = emitNewlineEvents;
    function processByte(stream, b) {
      assert.equal(typeof b, "number");
      if (b === NEWLINE) {
        stream.emit("newline");
      }
    }
  }
});

// node_modules/npm/node_modules/ansi/lib/ansi.js
var require_ansi = __commonJS({
  "node_modules/npm/node_modules/ansi/lib/ansi.js"(exports2, module2) {
    var emitNewlineEvents = require_newlines();
    var prefix = "\x1B[";
    var suffix = "m";
    var codes = {
      up: "A",
      down: "B",
      forward: "C",
      back: "D",
      nextLine: "E",
      previousLine: "F",
      horizontalAbsolute: "G",
      eraseData: "J",
      eraseLine: "K",
      scrollUp: "S",
      scrollDown: "T",
      savePosition: "s",
      restorePosition: "u",
      queryPosition: "6n",
      hide: "?25l",
      show: "?25h"
    };
    var styles = {
      bold: 1,
      italic: 3,
      underline: 4,
      inverse: 7
    };
    var reset = {
      bold: 22,
      italic: 23,
      underline: 24,
      inverse: 27
    };
    var colors = {
      white: 37,
      black: 30,
      blue: 34,
      cyan: 36,
      green: 32,
      magenta: 35,
      red: 31,
      yellow: 33,
      grey: 90,
      brightBlack: 90,
      brightRed: 91,
      brightGreen: 92,
      brightYellow: 93,
      brightBlue: 94,
      brightMagenta: 95,
      brightCyan: 96,
      brightWhite: 97
    };
    function ansi(stream, options) {
      if (stream._ansicursor) {
        return stream._ansicursor;
      } else {
        return stream._ansicursor = new Cursor(stream, options);
      }
    }
    module2.exports = exports2 = ansi;
    function Cursor(stream, options) {
      if (!(this instanceof Cursor)) {
        return new Cursor(stream, options);
      }
      if (typeof stream != "object" || typeof stream.write != "function") {
        throw new Error("a valid Stream instance must be passed in");
      }
      this.stream = stream;
      this.enabled = options && options.enabled;
      if (typeof this.enabled === "undefined") {
        this.enabled = stream.isTTY;
      }
      this.enabled = !!this.enabled;
      this.buffering = !!(options && options.buffering);
      this._buffer = [];
      this.fg = this.foreground = new Colorer(this, 0);
      this.bg = this.background = new Colorer(this, 10);
      this.Bold = false;
      this.Italic = false;
      this.Underline = false;
      this.Inverse = false;
      this.newlines = 0;
      emitNewlineEvents(stream);
      stream.on("newline", (function() {
        this.newlines++;
      }).bind(this));
    }
    exports2.Cursor = Cursor;
    Cursor.prototype.write = function(data) {
      if (this.buffering) {
        this._buffer.push(arguments);
      } else {
        this.stream.write.apply(this.stream, arguments);
      }
      return this;
    };
    Cursor.prototype.buffer = function() {
      this.buffering = true;
      return this;
    };
    Cursor.prototype.flush = function() {
      this.buffering = false;
      var str = this._buffer.map(function(args) {
        if (args.length != 1)
          throw new Error("unexpected args length! " + args.length);
        return args[0];
      }).join("");
      this._buffer.splice(0);
      this.write(str);
      return this;
    };
    function Colorer(cursor, base) {
      this.current = null;
      this.cursor = cursor;
      this.base = base;
    }
    exports2.Colorer = Colorer;
    Colorer.prototype._setColorCode = function setColorCode(code) {
      var c = String(code);
      if (this.current === c)
        return;
      this.cursor.enabled && this.cursor.write(prefix + c + suffix);
      this.current = c;
      return this;
    };
    Object.keys(codes).forEach(function(name) {
      var code = String(codes[name]);
      Cursor.prototype[name] = function() {
        var c = code;
        if (arguments.length > 0) {
          c = toArray2(arguments).map(Math.round).join(";") + code;
        }
        this.enabled && this.write(prefix + c);
        return this;
      };
    });
    Object.keys(styles).forEach(function(style) {
      var name = style[0].toUpperCase() + style.substring(1), c = styles[style], r = reset[style];
      Cursor.prototype[style] = function() {
        if (this[name])
          return this;
        this.enabled && this.write(prefix + c + suffix);
        this[name] = true;
        return this;
      };
      Cursor.prototype["reset" + name] = function() {
        if (!this[name])
          return this;
        this.enabled && this.write(prefix + r + suffix);
        this[name] = false;
        return this;
      };
    });
    Object.keys(colors).forEach(function(color) {
      var code = colors[color];
      Colorer.prototype[color] = function() {
        this._setColorCode(this.base + code);
        return this.cursor;
      };
      Cursor.prototype[color] = function() {
        return this.foreground[color]();
      };
    });
    Cursor.prototype.beep = function() {
      this.enabled && this.write("\x07");
      return this;
    };
    Cursor.prototype.goto = function(x, y) {
      x = x | 0;
      y = y | 0;
      this.enabled && this.write(prefix + y + ";" + x + "H");
      return this;
    };
    Colorer.prototype.reset = function() {
      this._setColorCode(this.base + 39);
      return this.cursor;
    };
    Cursor.prototype.reset = function() {
      this.enabled && this.write(prefix + "0" + suffix);
      this.Bold = false;
      this.Italic = false;
      this.Underline = false;
      this.Inverse = false;
      this.foreground.current = null;
      this.background.current = null;
      return this;
    };
    Colorer.prototype.rgb = function(r, g, b) {
      var base = this.base + 38, code = rgb(r, g, b);
      this._setColorCode(base + ";5;" + code);
      return this.cursor;
    };
    Cursor.prototype.rgb = function(r, g, b) {
      return this.foreground.rgb(r, g, b);
    };
    Colorer.prototype.hex = function(color) {
      return this.rgb.apply(this, hex(color));
    };
    Cursor.prototype.hex = function(color) {
      return this.foreground.hex(color);
    };
    function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return rgb5(red, green, blue);
    }
    function rgb5(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    }
    function hex(color) {
      var c = color[0] === "#" ? color.substring(1) : color, r = c.substring(0, 2), g = c.substring(2, 4), b = c.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    }
    function toArray2(a) {
      var i = 0, l2 = a.length, rtn = [];
      for (; i < l2; i++) {
        rtn.push(a[i]);
      }
      return rtn;
    }
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash._baseslice/index.js
var require_lodash = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash._baseslice/index.js"(exports2, module2) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result2 = Array(length);
      while (++index < length) {
        result2[index] = array[index + start];
      }
      return result2;
    }
    module2.exports = baseSlice;
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash._basetostring/index.js
var require_lodash2 = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash._basetostring/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var objectTypes = {
      "function": true,
      "object": true
    };
    var freeExports = objectTypes[typeof exports2] && exports2 && !exports2.nodeType ? exports2 : void 0;
    var freeModule = objectTypes[typeof module2] && module2 && !module2.nodeType ? module2 : void 0;
    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == "object" && global);
    var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    var thisGlobal = checkGlobal(objectTypes[typeof exports2] && exports2);
    var root2 = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function("return this")();
    function checkGlobal(value) {
      return value && value.Object === Object ? value : null;
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root2.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    module2.exports = baseToString;
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash.tostring/index.js
var require_lodash3 = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash.tostring/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root2.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString2;
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash.pad/index.js
var require_lodash4 = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash.pad/index.js"(exports2, module2) {
    var baseSlice = require_lodash();
    var baseToString = require_lodash2();
    var toString2 = require_lodash3();
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reComplexSymbol = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reHasComplexSymbol = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var freeParseInt = parseInt;
    function stringSize(string) {
      if (!(string && reHasComplexSymbol.test(string))) {
        return string.length;
      }
      var result2 = reComplexSymbol.lastIndex = 0;
      while (reComplexSymbol.test(string)) {
        result2++;
      }
      return result2;
    }
    function stringToArray(string) {
      return string.match(reComplexSymbol);
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeCeil = Math.ceil;
    var nativeFloor = Math.floor;
    function baseRepeat(string, n) {
      var result2 = "";
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result2;
      }
      do {
        if (n % 2) {
          result2 += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);
      return result2;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createPadding(length, chars) {
      chars = chars === void 0 ? " " : baseToString(chars);
      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
    }
    function isFunction2(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result2 = toFinite(value), remainder = result2 % 1;
      return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = isFunction2(value.valueOf) ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function pad(string, length, chars) {
      string = toString2(string);
      length = toInteger(length);
      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
    }
    module2.exports = pad;
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash.padend/index.js
var require_lodash5 = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash.padend/index.js"(exports2, module2) {
    var baseSlice = require_lodash();
    var baseToString = require_lodash2();
    var toString2 = require_lodash3();
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reComplexSymbol = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reHasComplexSymbol = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var freeParseInt = parseInt;
    function stringSize(string) {
      if (!(string && reHasComplexSymbol.test(string))) {
        return string.length;
      }
      var result2 = reComplexSymbol.lastIndex = 0;
      while (reComplexSymbol.test(string)) {
        result2++;
      }
      return result2;
    }
    function stringToArray(string) {
      return string.match(reComplexSymbol);
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeCeil = Math.ceil;
    var nativeFloor = Math.floor;
    function baseRepeat(string, n) {
      var result2 = "";
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result2;
      }
      do {
        if (n % 2) {
          result2 += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);
      return result2;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createPadding(length, chars) {
      chars = chars === void 0 ? " " : baseToString(chars);
      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
    }
    function isFunction2(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result2 = toFinite(value), remainder = result2 % 1;
      return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = isFunction2(value.valueOf) ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function padEnd(string, length, chars) {
      string = toString2(string);
      length = toInteger(length);
      var strLength = length ? stringSize(string) : 0;
      return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
    }
    module2.exports = padEnd;
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash.padstart/index.js
var require_lodash6 = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/gauge/node_modules/lodash.padstart/index.js"(exports2, module2) {
    var baseSlice = require_lodash();
    var baseToString = require_lodash2();
    var toString2 = require_lodash3();
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reComplexSymbol = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reHasComplexSymbol = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var freeParseInt = parseInt;
    function stringSize(string) {
      if (!(string && reHasComplexSymbol.test(string))) {
        return string.length;
      }
      var result2 = reComplexSymbol.lastIndex = 0;
      while (reComplexSymbol.test(string)) {
        result2++;
      }
      return result2;
    }
    function stringToArray(string) {
      return string.match(reComplexSymbol);
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeCeil = Math.ceil;
    var nativeFloor = Math.floor;
    function baseRepeat(string, n) {
      var result2 = "";
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result2;
      }
      do {
        if (n % 2) {
          result2 += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);
      return result2;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createPadding(length, chars) {
      chars = chars === void 0 ? " " : baseToString(chars);
      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
    }
    function isFunction2(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result2 = toFinite(value), remainder = result2 % 1;
      return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = isFunction2(value.valueOf) ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function padStart(string, length, chars) {
      string = toString2(string);
      length = toInteger(length);
      var strLength = length ? stringSize(string) : 0;
      return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
    }
    module2.exports = padStart;
  }
});

// node_modules/npm/node_modules/npmlog/node_modules/gauge/progress-bar.js
var require_progress_bar = __commonJS({
  "node_modules/npm/node_modules/npmlog/node_modules/gauge/progress-bar.js"(exports2, module2) {
    "use strict";
    var hasUnicode = require_has_unicode();
    var ansi = require_ansi();
    var align = {
      center: require_lodash4(),
      left: require_lodash5(),
      right: require_lodash6()
    };
    var defaultStream = process.stderr;
    function isTTY() {
      return process.stderr.isTTY;
    }
    function getWritableTTYColumns() {
      return process.stdout.columns - 1;
    }
    var ProgressBar = module2.exports = function(options, cursor) {
      if (!options)
        options = {};
      if (!cursor && options.write) {
        cursor = options;
        options = {};
      }
      if (!cursor) {
        cursor = ansi(defaultStream);
      }
      this.cursor = cursor;
      this.showing = false;
      this.theme = options.theme || (hasUnicode() ? ProgressBar.unicode : ProgressBar.ascii);
      this.template = options.template || [
        { type: "name", separated: true, length: 25 },
        { type: "spinner", separated: true },
        { type: "startgroup" },
        { type: "completionbar" },
        { type: "endgroup" }
      ];
      this.updatefreq = options.maxUpdateFrequency == null ? 50 : options.maxUpdateFrequency;
      this.lastName = "";
      this.lastCompleted = 0;
      this.spun = 0;
      this.last = /* @__PURE__ */ new Date(0);
      var self2 = this;
      this._handleSizeChange = function() {
        if (!self2.showing)
          return;
        self2.hide();
        self2.show();
      };
    };
    ProgressBar.prototype = {};
    ProgressBar.unicode = {
      startgroup: "╢",
      endgroup: "╟",
      complete: "█",
      incomplete: "░",
      spinner: "▀▐▄▌",
      subsection: "→"
    };
    ProgressBar.ascii = {
      startgroup: "|",
      endgroup: "|",
      complete: "#",
      incomplete: "-",
      spinner: "-\\|/",
      subsection: "->"
    };
    ProgressBar.prototype.setTheme = function(theme) {
      this.theme = theme;
    };
    ProgressBar.prototype.setTemplate = function(template2) {
      this.template = template2;
    };
    ProgressBar.prototype._enableResizeEvents = function() {
      process.stdout.on("resize", this._handleSizeChange);
    };
    ProgressBar.prototype._disableResizeEvents = function() {
      process.stdout.removeListener("resize", this._handleSizeChange);
    };
    ProgressBar.prototype.disable = function() {
      this.hide();
      this.disabled = true;
    };
    ProgressBar.prototype.enable = function() {
      this.disabled = false;
      this.show();
    };
    ProgressBar.prototype.hide = function() {
      if (!isTTY())
        return;
      if (this.disabled)
        return;
      this.cursor.show();
      if (this.showing)
        this.cursor.up(1);
      this.cursor.horizontalAbsolute(0).eraseLine();
      this.showing = false;
    };
    var repeat = function(str, count) {
      var out = "";
      for (var ii = 0; ii < count; ++ii)
        out += str;
      return out;
    };
    ProgressBar.prototype.pulse = function(name) {
      ++this.spun;
      if (!this.showing)
        return;
      if (this.disabled)
        return;
      var baseName = this.lastName;
      name = name ? baseName ? baseName + " " + this.theme.subsection + " " + name : null : baseName;
      this.show(name);
      this.lastName = baseName;
    };
    ProgressBar.prototype.show = function(name, completed) {
      name = this.lastName = name || this.lastName;
      completed = this.lastCompleted = completed || this.lastCompleted;
      if (!isTTY())
        return;
      if (this.disabled)
        return;
      if (!this.spun && !completed)
        return;
      if (this.tryAgain)
        return;
      var self2 = this;
      if (this.showing && /* @__PURE__ */ new Date() - this.last < this.updatefreq) {
        this.tryAgain = setTimeout(function() {
          self2.tryAgain = null;
          if (self2.disabled)
            return;
          if (!self2.spun && !completed)
            return;
          drawBar();
        }, this.updatefreq - (/* @__PURE__ */ new Date() - this.last));
        return;
      }
      return drawBar();
      function drawBar() {
        var values2 = {
          name,
          spinner: self2.spun,
          completed
        };
        self2.last = /* @__PURE__ */ new Date();
        var statusline = self2.renderTemplate(self2.theme, self2.template, values2);
        if (self2.showing)
          self2.cursor.up(1);
        self2.cursor.hide().horizontalAbsolute(0).write(statusline.substr(0, getWritableTTYColumns()) + "\n").show();
        self2.showing = true;
      }
    };
    ProgressBar.prototype.renderTemplate = function(theme, template2, values2) {
      values2.startgroup = theme.startgroup;
      values2.endgroup = theme.endgroup;
      values2.spinner = values2.spinner ? theme.spinner.substr(values2.spinner % theme.spinner.length, 1) : "";
      var output = { prebar: "", postbar: "" };
      var status = "prebar";
      var self2 = this;
      template2.forEach(function(T) {
        if (typeof T === "string") {
          output[status] += T;
          return;
        }
        if (T.type === "completionbar") {
          status = "postbar";
          return;
        }
        if (!values2.hasOwnProperty(T.type))
          throw new Error("Unknown template value '" + T.type + "'");
        var value = self2.renderValue(T, values2[T.type]);
        if (value === "")
          return;
        var sofar2 = output[status].length;
        var lastChar = sofar2 ? output[status][sofar2 - 1] : null;
        if (T.separated && sofar2 && lastChar !== " ") {
          output[status] += " ";
        }
        output[status] += value;
        if (T.separated)
          output[status] += " ";
      });
      var bar = "";
      if (status === "postbar") {
        var nonBarLen = output.prebar.length + output.postbar.length;
        var barLen = getWritableTTYColumns() - nonBarLen;
        var sofar = Math.round(barLen * Math.max(0, Math.min(1, values2.completed || 0)));
        var rest2 = barLen - sofar;
        bar = repeat(theme.complete, sofar) + repeat(theme.incomplete, rest2);
      }
      return output.prebar + bar + output.postbar;
    };
    ProgressBar.prototype.renderValue = function(template2, value) {
      if (value == null || value === "")
        return "";
      var maxLength = template2.maxLength || template2.length;
      var minLength = template2.minLength || template2.length;
      var alignWith = align[template2.align] || align.left;
      if (maxLength)
        value = value.substr(0, maxLength);
      if (minLength)
        value = alignWith(value, minLength);
      return value;
    };
  }
});

// node_modules/npm/node_modules/npmlog/log.js
var require_log = __commonJS({
  "node_modules/npm/node_modules/npmlog/log.js"(exports2, module2) {
    "use strict";
    var Progress = require_are_we_there_yet();
    var Gauge = require_progress_bar();
    var EE = require_events().EventEmitter;
    var log = exports2 = module2.exports = new EE();
    var util = require_util();
    var ansi = require_ansi();
    log.cursor = ansi(process.stderr);
    log.stream = process.stderr;
    var colorEnabled = void 0;
    log.enableColor = function() {
      colorEnabled = true;
      this.cursor.enabled = true;
    };
    log.disableColor = function() {
      colorEnabled = false;
      this.cursor.enabled = false;
    };
    log.level = "info";
    log.gauge = new Gauge(log.cursor);
    log.tracker = new Progress.TrackerGroup();
    log.progressEnabled = false;
    var gaugeTheme = void 0;
    log.enableUnicode = function() {
      gaugeTheme = Gauge.unicode;
      log.gauge.setTheme(gaugeTheme);
    };
    log.disableUnicode = function() {
      gaugeTheme = Gauge.ascii;
      log.gauge.setTheme(gaugeTheme);
    };
    var gaugeTemplate = void 0;
    log.setGaugeTemplate = function(template2) {
      gaugeTemplate = template2;
      log.gauge.setTemplate(gaugeTemplate);
    };
    log.enableProgress = function() {
      if (this.progressEnabled)
        return;
      this.progressEnabled = true;
      if (this._pause)
        return;
      this.tracker.on("change", this.showProgress);
      this.gauge.enable();
      this.showProgress();
    };
    log.disableProgress = function() {
      if (!this.progressEnabled)
        return;
      this.clearProgress();
      this.progressEnabled = false;
      this.tracker.removeListener("change", this.showProgress);
      this.gauge.disable();
    };
    var trackerConstructors = ["newGroup", "newItem", "newStream"];
    var mixinLog = function(tracker) {
      Object.keys(log).forEach(function(P) {
        if (P[0] === "_")
          return;
        if (trackerConstructors.filter(function(C) {
          return C === P;
        }).length)
          return;
        if (tracker[P])
          return;
        if (typeof log[P] !== "function")
          return;
        var func = log[P];
        tracker[P] = function() {
          return func.apply(log, arguments);
        };
      });
      if (tracker instanceof Progress.TrackerGroup) {
        trackerConstructors.forEach(function(C) {
          var func = tracker[C];
          tracker[C] = function() {
            return mixinLog(func.apply(tracker, arguments));
          };
        });
      }
      return tracker;
    };
    trackerConstructors.forEach(function(C) {
      log[C] = function() {
        return mixinLog(this.tracker[C].apply(this.tracker, arguments));
      };
    });
    log.clearProgress = function() {
      if (!this.progressEnabled)
        return;
      this.gauge.hide();
    };
    log.showProgress = (function(name, completed) {
      if (!this.progressEnabled)
        return;
      if (completed == null)
        completed = this.tracker.completed();
      this.gauge.show(name, completed);
    }).bind(log);
    log.pause = function() {
      this._paused = true;
    };
    log.resume = function() {
      if (!this._paused)
        return;
      this._paused = false;
      var b = this._buffer;
      this._buffer = [];
      b.forEach(function(m) {
        this.emitLog(m);
      }, this);
      if (this.progressEnabled)
        this.enableProgress();
    };
    log._buffer = [];
    var id = 0;
    log.record = [];
    log.maxRecordSize = 1e4;
    log.log = (function(lvl, prefix, message) {
      var l2 = this.levels[lvl];
      if (l2 === void 0) {
        return this.emit("error", new Error(util.format(
          "Undefined log level: %j",
          lvl
        )));
      }
      var a = new Array(arguments.length - 2);
      var stack = null;
      for (var i = 2; i < arguments.length; i++) {
        var arg = a[i - 2] = arguments[i];
        if (typeof arg === "object" && arg && arg instanceof Error && arg.stack) {
          arg.stack = stack = arg.stack + "";
        }
      }
      if (stack)
        a.unshift(stack + "\n");
      message = util.format.apply(util, a);
      var m = {
        id: id++,
        level: lvl,
        prefix: String(prefix || ""),
        message,
        messageRaw: a
      };
      this.emit("log", m);
      this.emit("log." + lvl, m);
      if (m.prefix)
        this.emit(m.prefix, m);
      this.record.push(m);
      var mrs = this.maxRecordSize;
      var n = this.record.length - mrs;
      if (n > mrs / 10) {
        var newSize = Math.floor(mrs * 0.9);
        this.record = this.record.slice(-1 * newSize);
      }
      this.emitLog(m);
    }).bind(log);
    log.emitLog = function(m) {
      if (this._paused) {
        this._buffer.push(m);
        return;
      }
      if (this.progressEnabled)
        this.gauge.pulse(m.prefix);
      var l2 = this.levels[m.level];
      if (l2 === void 0)
        return;
      if (l2 < this.levels[this.level])
        return;
      if (l2 > 0 && !isFinite(l2))
        return;
      var style = log.style[m.level];
      var disp = log.disp[m.level] || m.level;
      this.clearProgress();
      m.message.split(/\r?\n/).forEach(function(line) {
        if (this.heading) {
          this.write(this.heading, this.headingStyle);
          this.write(" ");
        }
        this.write(disp, log.style[m.level]);
        var p = m.prefix || "";
        if (p)
          this.write(" ");
        this.write(p, this.prefixStyle);
        this.write(" " + line + "\n");
      }, this);
      this.showProgress();
    };
    log.write = function(msg, style) {
      if (!this.cursor)
        return;
      if (this.stream !== this.cursor.stream) {
        this.cursor = ansi(this.stream, { enabled: colorEnabled });
        var options = {};
        if (gaugeTheme != null)
          options.theme = gaugeTheme;
        if (gaugeTemplate != null)
          options.template = gaugeTemplate;
        this.gauge = new Gauge(options, this.cursor);
      }
      style = style || {};
      if (style.fg)
        this.cursor.fg[style.fg]();
      if (style.bg)
        this.cursor.bg[style.bg]();
      if (style.bold)
        this.cursor.bold();
      if (style.underline)
        this.cursor.underline();
      if (style.inverse)
        this.cursor.inverse();
      if (style.beep)
        this.cursor.beep();
      this.cursor.write(msg).reset();
    };
    log.addLevel = function(lvl, n, style, disp) {
      if (!disp)
        disp = lvl;
      this.levels[lvl] = n;
      this.style[lvl] = style;
      if (!this[lvl])
        this[lvl] = (function() {
          var a = new Array(arguments.length + 1);
          a[0] = lvl;
          for (var i = 0; i < arguments.length; i++) {
            a[i + 1] = arguments[i];
          }
          return this.log.apply(this, a);
        }).bind(this);
      this.disp[lvl] = disp;
    };
    log.prefixStyle = { fg: "magenta" };
    log.headingStyle = { fg: "white", bg: "black" };
    log.style = {};
    log.levels = {};
    log.disp = {};
    log.addLevel("silly", -Infinity, { inverse: true }, "sill");
    log.addLevel("verbose", 1e3, { fg: "blue", bg: "black" }, "verb");
    log.addLevel("info", 2e3, { fg: "green" });
    log.addLevel("http", 3e3, { fg: "green", bg: "black" });
    log.addLevel("warn", 4e3, { fg: "black", bg: "yellow" }, "WARN");
    log.addLevel("error", 5e3, { fg: "red", bg: "black" }, "ERR!");
    log.addLevel("silent", Infinity);
    log.on("error", function() {
    });
  }
});

// node_modules/npm/lib/utils/umask.js
var require_umask2 = __commonJS({
  "node_modules/npm/lib/utils/umask.js"(exports2, module2) {
    var umask = require_umask();
    var npmlog = require_log();
    var _fromString = umask.fromString;
    module2.exports = umask;
    umask.fromString = function(val) {
      _fromString(val, function(err, result2) {
        if (err) {
          npmlog.warn("invalid umask", err.message);
        }
        val = result2;
      });
      return val;
    };
  }
});

// node_modules/npm/lib/config/defaults.js
var require_defaults = __commonJS({
  "node_modules/npm/lib/config/defaults.js"(exports2) {
    var path = require_path();
    var url = require_url();
    var Stream = require_stream().Stream;
    var semver = require_semver();
    var stableFamily = semver.parse(process.version);
    var nopt = require_nopt();
    var os = require_os();
    var osenv = require_osenv();
    var umask = require_umask2();
    var log;
    try {
      log = require_log();
    } catch (er) {
      util = require_util();
      log = { warn: function(m) {
        console.warn(m + " " + util.format.apply(util, [].slice.call(arguments, 1)));
      } };
    }
    var util;
    exports2.Umask = Umask;
    function Umask() {
    }
    function validateUmask(data, k, val) {
      return umask.validate(data, k, val);
    }
    function validateSemver(data, k, val) {
      if (!semver.valid(val))
        return false;
      data[k] = semver.valid(val);
    }
    function validateStream(data, k, val) {
      if (!(val instanceof Stream))
        return false;
      data[k] = val;
    }
    nopt.typeDefs.semver = { type: semver, validate: validateSemver };
    nopt.typeDefs.Stream = { type: Stream, validate: validateStream };
    nopt.typeDefs.Umask = { type: Umask, validate: validateUmask };
    nopt.invalidHandler = function(k, val, type) {
      log.warn("invalid config", k + "=" + JSON.stringify(val));
      if (Array.isArray(type)) {
        if (type.indexOf(url) !== -1)
          type = url;
        else if (type.indexOf(path) !== -1)
          type = path;
      }
      switch (type) {
        case Umask:
          log.warn("invalid config", "Must be umask, octal number in range 0000..0777");
          break;
        case url:
          log.warn("invalid config", "Must be a full url with 'http://'");
          break;
        case path:
          log.warn("invalid config", "Must be a valid filesystem path");
          break;
        case Number:
          log.warn("invalid config", "Must be a numeric value");
          break;
        case Stream:
          log.warn("invalid config", "Must be an instance of the Stream class");
          break;
      }
    };
    if (!stableFamily || +stableFamily.minor % 2)
      stableFamily = null;
    else
      stableFamily = stableFamily.major + "." + stableFamily.minor;
    var defaults;
    var temp = osenv.tmpdir();
    var home = osenv.home();
    var uidOrPid = process.getuid ? process.getuid() : process.pid;
    if (home)
      process.env.HOME = home;
    else
      home = path.resolve(temp, "npm-" + uidOrPid);
    var cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm";
    var cacheRoot = process.platform === "win32" && process.env.APPDATA || home;
    var cache = path.resolve(cacheRoot, cacheExtra);
    var globalPrefix;
    Object.defineProperty(exports2, "defaults", { get: function() {
      if (defaults)
        return defaults;
      if (process.env.PREFIX) {
        globalPrefix = process.env.PREFIX;
      } else if (process.platform === "win32") {
        globalPrefix = path.dirname(process.execPath);
      } else {
        globalPrefix = path.dirname(path.dirname(process.execPath));
        if (process.env.DESTDIR) {
          globalPrefix = path.join(process.env.DESTDIR, globalPrefix);
        }
      }
      defaults = {
        access: null,
        "always-auth": false,
        "bin-links": true,
        browser: null,
        ca: null,
        cafile: null,
        cache,
        "cache-lock-stale": 6e4,
        "cache-lock-retries": 10,
        "cache-lock-wait": 1e4,
        "cache-max": Infinity,
        "cache-min": 10,
        cert: null,
        color: true,
        depth: Infinity,
        description: true,
        dev: false,
        editor: osenv.editor(),
        "engine-strict": false,
        force: false,
        "fetch-retries": 2,
        "fetch-retry-factor": 10,
        "fetch-retry-mintimeout": 1e4,
        "fetch-retry-maxtimeout": 6e4,
        git: "git",
        "git-tag-version": true,
        global: false,
        globalconfig: path.resolve(globalPrefix, "etc", "npmrc"),
        group: process.platform === "win32" ? 0 : process.env.SUDO_GID || process.getgid && process.getgid(),
        heading: "npm",
        "if-present": false,
        "ignore-scripts": false,
        "init-module": path.resolve(home, ".npm-init.js"),
        "init-author-name": "",
        "init-author-email": "",
        "init-author-url": "",
        "init-version": "1.0.0",
        "init-license": "ISC",
        json: false,
        key: null,
        link: false,
        "local-address": void 0,
        loglevel: "warn",
        logstream: process.stderr,
        long: false,
        maxsockets: 50,
        message: "%s",
        "node-version": process.version,
        npat: false,
        "onload-script": false,
        optional: true,
        parseable: false,
        prefix: globalPrefix,
        production: false,
        "proprietary-attribs": true,
        proxy: null,
        "https-proxy": null,
        "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
        "rebuild-bundle": true,
        registry: "https://registry.npmjs.org/",
        rollback: true,
        save: false,
        "save-bundle": false,
        "save-dev": false,
        "save-exact": false,
        "save-optional": false,
        "save-prefix": "^",
        scope: "",
        searchopts: "",
        searchexclude: null,
        searchsort: "name",
        shell: osenv.shell(),
        shrinkwrap: true,
        "sign-git-tag": false,
        spin: true,
        "strict-ssl": true,
        tag: "latest",
        "tag-version-prefix": "v",
        tmp: temp,
        unicode: true,
        "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
        usage: false,
        user: process.platform === "win32" ? 0 : "nobody",
        userconfig: path.resolve(home, ".npmrc"),
        umask: process.umask ? process.umask() : umask.fromString("022"),
        version: false,
        versions: false,
        viewer: process.platform === "win32" ? "browser" : "man",
        _exit: true
      };
      return defaults;
    } });
    exports2.types = {
      access: [null, "restricted", "public"],
      "always-auth": Boolean,
      "bin-links": Boolean,
      browser: [null, String],
      ca: [null, String, Array],
      cafile: path,
      cache: path,
      "cache-lock-stale": Number,
      "cache-lock-retries": Number,
      "cache-lock-wait": Number,
      "cache-max": Number,
      "cache-min": Number,
      cert: [null, String],
      color: ["always", Boolean],
      depth: Number,
      description: Boolean,
      dev: Boolean,
      editor: String,
      "engine-strict": Boolean,
      force: Boolean,
      "fetch-retries": Number,
      "fetch-retry-factor": Number,
      "fetch-retry-mintimeout": Number,
      "fetch-retry-maxtimeout": Number,
      git: String,
      "git-tag-version": Boolean,
      global: Boolean,
      globalconfig: path,
      group: [Number, String],
      "https-proxy": [null, url],
      "user-agent": String,
      "heading": String,
      "if-present": Boolean,
      "ignore-scripts": Boolean,
      "init-module": path,
      "init-author-name": String,
      "init-author-email": String,
      "init-author-url": ["", url],
      "init-license": String,
      "init-version": semver,
      json: Boolean,
      key: [null, String],
      link: Boolean,
      "local-address": getLocalAddresses(),
      loglevel: ["silent", "error", "warn", "http", "info", "verbose", "silly"],
      logstream: Stream,
      long: Boolean,
      maxsockets: Number,
      message: String,
      "node-version": [null, semver],
      npat: Boolean,
      "onload-script": [null, String],
      optional: Boolean,
      parseable: Boolean,
      prefix: path,
      production: Boolean,
      "proprietary-attribs": Boolean,
      proxy: [null, false, url],
      "rebuild-bundle": Boolean,
      registry: [null, url],
      rollback: Boolean,
      save: Boolean,
      "save-bundle": Boolean,
      "save-dev": Boolean,
      "save-exact": Boolean,
      "save-optional": Boolean,
      "save-prefix": String,
      scope: String,
      searchopts: String,
      searchexclude: [null, String],
      searchsort: [
        "name",
        "-name",
        "description",
        "-description",
        "author",
        "-author",
        "date",
        "-date",
        "keywords",
        "-keywords"
      ],
      shell: String,
      shrinkwrap: Boolean,
      "sign-git-tag": Boolean,
      spin: ["always", Boolean],
      "strict-ssl": Boolean,
      tag: String,
      tmp: path,
      unicode: Boolean,
      "unsafe-perm": Boolean,
      usage: Boolean,
      user: [Number, String],
      userconfig: path,
      umask: Umask,
      version: Boolean,
      "tag-version-prefix": String,
      versions: Boolean,
      viewer: String,
      _exit: Boolean
    };
    function getLocalAddresses() {
      var interfaces;
      try {
        interfaces = os.networkInterfaces();
      } catch (e) {
        interfaces = {};
      }
      return Object.keys(interfaces).map(function(nic) {
        return interfaces[nic].filter(function(addr) {
          return addr.family === "IPv4";
        }).map(function(addr) {
          return addr.address;
        });
      }).reduce(function(curr, next) {
        return curr.concat(next);
      }, []).concat(void 0);
    }
    exports2.shorthands = {
      s: ["--loglevel", "silent"],
      d: ["--loglevel", "info"],
      dd: ["--loglevel", "verbose"],
      ddd: ["--loglevel", "silly"],
      noreg: ["--no-registry"],
      N: ["--no-registry"],
      reg: ["--registry"],
      "no-reg": ["--no-registry"],
      silent: ["--loglevel", "silent"],
      verbose: ["--loglevel", "verbose"],
      quiet: ["--loglevel", "warn"],
      q: ["--loglevel", "warn"],
      h: ["--usage"],
      H: ["--usage"],
      "?": ["--usage"],
      help: ["--usage"],
      v: ["--version"],
      f: ["--force"],
      gangster: ["--force"],
      gangsta: ["--force"],
      desc: ["--description"],
      "no-desc": ["--no-description"],
      "local": ["--no-global"],
      l: ["--long"],
      m: ["--message"],
      p: ["--parseable"],
      porcelain: ["--parseable"],
      g: ["--global"],
      S: ["--save"],
      D: ["--save-dev"],
      E: ["--save-exact"],
      O: ["--save-optional"],
      y: ["--yes"],
      n: ["--no-yes"],
      B: ["--save-bundle"],
      C: ["--prefix"]
    };
  }
});

// node_modules/npm/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/npm/node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb2) {
      if (fn && cb2)
        return wrappy(fn)(cb2);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret2 = fn.apply(this, args);
        var cb3 = args[args.length - 1];
        if (typeof ret2 === "function" && ret2 !== cb3) {
          Object.keys(cb3).forEach(function(k) {
            ret2[k] = cb3[k];
          });
        }
        return ret2;
      }
    }
  }
});

// node_modules/npm/node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/npm/node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f2 = function() {
        if (f2.called)
          return f2.value;
        f2.called = true;
        return f2.value = fn.apply(this, arguments);
      };
      f2.called = false;
      return f2;
    }
    function onceStrict(fn) {
      var f2 = function() {
        if (f2.called)
          throw new Error(f2.onceError);
        f2.called = true;
        return f2.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f2.onceError = name + " shouldn't be called more than once";
      f2.called = false;
      return f2;
    }
  }
});

// node_modules/npm/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/npm/node_modules/mkdirp/index.js"(exports2, module2) {
    var path = require_path();
    var fs = require_fs();
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f2, made) {
      if (typeof opts === "function") {
        f2 = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777 & ~process.umask();
      }
      if (!made)
        made = null;
      var cb2 = f2 || function() {
      };
      p = path.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb2(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            mkdirP(path.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb2(er2, made2);
              else
                mkdirP(p, opts, cb2, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb2(er, made);
              else
                cb2(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777 & ~process.umask();
      }
      if (!made)
        made = null;
      p = path.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/npm/lib/config/find-prefix.js
var require_find_prefix = __commonJS({
  "node_modules/npm/lib/config/find-prefix.js"(exports2, module2) {
    module2.exports = findPrefix;
    var fs = require_fs();
    var path = require_path();
    function findPrefix(p, cb_) {
      function cb2(er, p2) {
        process.nextTick(function() {
          cb_(er, p2);
        });
      }
      p = path.resolve(p);
      var walkedUp = false;
      while (path.basename(p) === "node_modules") {
        p = path.dirname(p);
        walkedUp = true;
      }
      if (walkedUp)
        return cb2(null, p);
      findPrefix_(p, p, cb2);
    }
    function findPrefix_(p, original, cb2) {
      if (p === "/" || process.platform === "win32" && p.match(/^[a-zA-Z]:(\\|\/)?$/)) {
        return cb2(null, original);
      }
      fs.readdir(p, function(er, files) {
        if (er && p === original) {
          if (er.code === "ENOENT")
            return cb2(null, original);
          return cb2(er);
        }
        if (er)
          return cb2(null, original);
        if (files.indexOf("node_modules") !== -1 || files.indexOf("package.json") !== -1) {
          return cb2(null, p);
        }
        var d = path.dirname(p);
        if (d === p)
          return cb2(null, original);
        return findPrefix_(d, original, cb2);
      });
    }
  }
});

// node_modules/npm/lib/config/load-prefix.js
var require_load_prefix = __commonJS({
  "node_modules/npm/lib/config/load-prefix.js"(exports2, module2) {
    module2.exports = loadPrefix;
    var findPrefix = require_find_prefix();
    var path = require_path();
    function loadPrefix(cb2) {
      var cli = this.list[0];
      Object.defineProperty(
        this,
        "prefix",
        {
          set: (function(prefix) {
            var g = this.get("global");
            this[g ? "globalPrefix" : "localPrefix"] = prefix;
          }).bind(this),
          get: (function() {
            var g = this.get("global");
            return g ? this.globalPrefix : this.localPrefix;
          }).bind(this),
          enumerable: true
        }
      );
      Object.defineProperty(
        this,
        "globalPrefix",
        {
          set: (function(prefix) {
            this.set("prefix", prefix);
          }).bind(this),
          get: (function() {
            return path.resolve(this.get("prefix"));
          }).bind(this),
          enumerable: true
        }
      );
      var p;
      Object.defineProperty(
        this,
        "localPrefix",
        {
          set: function(prefix) {
            p = prefix;
          },
          get: function() {
            return p;
          },
          enumerable: true
        }
      );
      if (Object.prototype.hasOwnProperty.call(cli, "prefix")) {
        p = path.resolve(cli.prefix);
        process.nextTick(cb2);
      } else {
        findPrefix(process.cwd(), function(er, found) {
          p = found;
          cb2(er);
        });
      }
    }
  }
});

// node_modules/npm/lib/config/load-cafile.js
var require_load_cafile = __commonJS({
  "node_modules/npm/lib/config/load-cafile.js"(exports2, module2) {
    module2.exports = loadCAFile;
    var fs = require_fs();
    function loadCAFile(cafilePath, cb2) {
      if (!cafilePath)
        return process.nextTick(cb2);
      fs.readFile(cafilePath, "utf8", afterCARead.bind(this));
      function afterCARead(er, cadata) {
        if (er) {
          if (er.code === "ENOENT")
            return cb2();
          return cb2(er);
        }
        var delim = "-----END CERTIFICATE-----";
        var output;
        output = cadata.split(delim).filter(function(xs) {
          return !!xs.trim();
        }).map(function(xs) {
          return xs.trimLeft() + delim;
        });
        this.set("ca", output);
        cb2(null);
      }
    }
  }
});

// node_modules/npm/node_modules/uid-number/uid-number.js
var require_uid_number = __commonJS({
  "node_modules/npm/node_modules/uid-number/uid-number.js"(exports2, module2) {
    module2.exports = uidNumber;
    var child_process = require_child_process();
    var path = require_path();
    var uidSupport = process.getuid && process.setuid;
    var uidCache = {};
    var gidCache = {};
    function uidNumber(uid, gid, cb2) {
      if (!uidSupport)
        return cb2();
      if (typeof cb2 !== "function")
        cb2 = gid, gid = null;
      if (typeof cb2 !== "function")
        cb2 = uid, uid = null;
      if (gid == null)
        gid = process.getgid();
      if (uid == null)
        uid = process.getuid();
      if (!isNaN(gid))
        gid = gidCache[gid] = +gid;
      if (!isNaN(uid))
        uid = uidCache[uid] = +uid;
      if (uidCache.hasOwnProperty(uid))
        uid = uidCache[uid];
      if (gidCache.hasOwnProperty(gid))
        gid = gidCache[gid];
      if (typeof gid === "number" && typeof uid === "number") {
        return process.nextTick(cb2.bind(null, null, uid, gid));
      }
      var getter = __require.resolve("./get-uid-gid.js");
      child_process.execFile(
        process.execPath,
        [getter, uid, gid],
        function(code, out, stderr) {
          if (code) {
            var er = new Error("could not get uid/gid\n" + stderr);
            er.code = code;
            return cb2(er);
          }
          try {
            out = JSON.parse(out + "");
          } catch (ex) {
            return cb2(ex);
          }
          if (out.error) {
            var er = new Error(out.error);
            er.errno = out.errno;
            return cb2(er);
          }
          if (isNaN(out.uid) || isNaN(out.gid))
            return cb2(new Error(
              "Could not get uid/gid: " + JSON.stringify(out)
            ));
          cb2(null, uidCache[uid] = +out.uid, gidCache[gid] = +out.gid);
        }
      );
    }
  }
});

// node_modules/npm/lib/config/load-uid.js
var require_load_uid = __commonJS({
  "node_modules/npm/lib/config/load-uid.js"(exports2, module2) {
    module2.exports = loadUid;
    var getUid = require_uid_number();
    function loadUid(cb2) {
      if (!this.get("unsafe-perm")) {
        getUid(this.get("user"), this.get("group"), cb2);
      } else {
        process.nextTick(cb2);
      }
    }
  }
});

// node_modules/npm/lib/config/set-user.js
var require_set_user = __commonJS({
  "node_modules/npm/lib/config/set-user.js"(exports2, module2) {
    module2.exports = setUser;
    var assert = require_assert();
    var path = require_path();
    var fs = require_fs();
    var mkdirp = require_mkdirp();
    function setUser(cb2) {
      var defaultConf = this.root;
      assert(defaultConf !== Object.prototype);
      if (this.get("global"))
        return cb2();
      if (process.env.SUDO_UID) {
        defaultConf.user = +process.env.SUDO_UID;
        return cb2();
      }
      var prefix = path.resolve(this.get("prefix"));
      mkdirp(prefix, function(er) {
        if (er)
          return cb2(er);
        fs.stat(prefix, function(er2, st) {
          defaultConf.user = st && st.uid;
          return cb2(er2);
        });
      });
    }
  }
});

// node_modules/npm/lib/config/nerf-dart.js
var require_nerf_dart = __commonJS({
  "node_modules/npm/lib/config/nerf-dart.js"(exports2, module2) {
    var url = require_url();
    module2.exports = toNerfDart;
    function toNerfDart(uri) {
      var parsed = url.parse(uri);
      delete parsed.protocol;
      delete parsed.auth;
      delete parsed.query;
      delete parsed.search;
      delete parsed.hash;
      return url.resolve(url.format(parsed), ".");
    }
  }
});

// node_modules/npm/lib/config/get-credentials-by-uri.js
var require_get_credentials_by_uri = __commonJS({
  "node_modules/npm/lib/config/get-credentials-by-uri.js"(exports2, module2) {
    var assert = require_assert();
    var toNerfDart = require_nerf_dart();
    module2.exports = getCredentialsByURI;
    function getCredentialsByURI(uri) {
      assert(uri && typeof uri === "string", "registry URL is required");
      var nerfed = toNerfDart(uri);
      var defnerf = toNerfDart(this.get("registry"));
      var c = {
        scope: nerfed,
        token: void 0,
        password: void 0,
        username: void 0,
        email: void 0,
        auth: void 0,
        alwaysAuth: void 0
      };
      if (this.get(nerfed + ":always-auth") !== void 0) {
        var val = this.get(nerfed + ":always-auth");
        c.alwaysAuth = val === "false" ? false : !!val;
      } else if (this.get("always-auth") !== void 0) {
        c.alwaysAuth = this.get("always-auth");
      }
      if (this.get(nerfed + ":_authToken")) {
        c.token = this.get(nerfed + ":_authToken");
        return c;
      }
      var authDef = this.get("_auth");
      var userDef = this.get("username");
      var passDef = this.get("_password");
      if (authDef && !(userDef && passDef)) {
        authDef = new Buffer(authDef, "base64").toString();
        authDef = authDef.split(":");
        userDef = authDef.shift();
        passDef = authDef.join(":");
      }
      if (this.get(nerfed + ":_password")) {
        c.password = new Buffer(this.get(nerfed + ":_password"), "base64").toString("utf8");
      } else if (nerfed === defnerf && passDef) {
        c.password = passDef;
      }
      if (this.get(nerfed + ":username")) {
        c.username = this.get(nerfed + ":username");
      } else if (nerfed === defnerf && userDef) {
        c.username = userDef;
      }
      if (this.get(nerfed + ":email")) {
        c.email = this.get(nerfed + ":email");
      } else if (this.get("email")) {
        c.email = this.get("email");
      }
      if (c.username && c.password) {
        c.auth = new Buffer(c.username + ":" + c.password).toString("base64");
      }
      return c;
    }
  }
});

// node_modules/npm/lib/config/set-credentials-by-uri.js
var require_set_credentials_by_uri = __commonJS({
  "node_modules/npm/lib/config/set-credentials-by-uri.js"(exports2, module2) {
    var assert = require_assert();
    var toNerfDart = require_nerf_dart();
    module2.exports = setCredentialsByURI;
    function setCredentialsByURI(uri, c) {
      assert(uri && typeof uri === "string", "registry URL is required");
      assert(c && typeof c === "object", "credentials are required");
      var nerfed = toNerfDart(uri);
      if (c.token) {
        this.set(nerfed + ":_authToken", c.token, "user");
        this.del(nerfed + ":_password", "user");
        this.del(nerfed + ":username", "user");
        this.del(nerfed + ":email", "user");
        this.del(nerfed + ":always-auth", "user");
      } else if (c.username || c.password || c.email) {
        assert(c.username, "must include username");
        assert(c.password, "must include password");
        assert(c.email, "must include email address");
        this.del(nerfed + ":_authToken", "user");
        var encoded = new Buffer(c.password, "utf8").toString("base64");
        this.set(nerfed + ":_password", encoded, "user");
        this.set(nerfed + ":username", c.username, "user");
        this.set(nerfed + ":email", c.email, "user");
        if (c.alwaysAuth !== void 0) {
          this.set(nerfed + ":always-auth", c.alwaysAuth, "user");
        } else {
          this.del(nerfed + ":always-auth", "user");
        }
      } else {
        throw new Error("No credentials to set.");
      }
    }
  }
});

// node_modules/npm/lib/config/clear-credentials-by-uri.js
var require_clear_credentials_by_uri = __commonJS({
  "node_modules/npm/lib/config/clear-credentials-by-uri.js"(exports2, module2) {
    var assert = require_assert();
    var toNerfDart = require_nerf_dart();
    module2.exports = clearCredentialsByURI;
    function clearCredentialsByURI(uri) {
      assert(uri && typeof uri === "string", "registry URL is required");
      var nerfed = toNerfDart(uri);
      this.del(nerfed + ":_authToken", "user");
      this.del(nerfed + ":_password", "user");
      this.del(nerfed + ":username", "user");
      this.del(nerfed + ":email", "user");
    }
  }
});

// node_modules/npm/lib/config/core.js
var require_core = __commonJS({
  "node_modules/npm/lib/config/core.js"(exports2) {
    var CC = require_config_chain().ConfigChain;
    var inherits2 = require_inherits_browser();
    var configDefs = require_defaults();
    var types = configDefs.types;
    var once = require_once();
    var fs = require_fs();
    var path = require_path();
    var nopt = require_nopt();
    var ini = require_ini();
    var Umask = configDefs.Umask;
    var mkdirp = require_mkdirp();
    var umask = require_umask2();
    exports2.load = load;
    exports2.Conf = Conf;
    exports2.loaded = false;
    exports2.rootConf = null;
    exports2.usingBuiltin = false;
    exports2.defs = configDefs;
    Object.defineProperty(exports2, "defaults", { get: function() {
      return configDefs.defaults;
    }, enumerable: true });
    Object.defineProperty(exports2, "types", { get: function() {
      return configDefs.types;
    }, enumerable: true });
    exports2.validate = validate;
    var myUid = process.env.SUDO_UID !== void 0 ? process.env.SUDO_UID : process.getuid && process.getuid();
    var myGid = process.env.SUDO_GID !== void 0 ? process.env.SUDO_GID : process.getgid && process.getgid();
    var loading = false;
    var loadCbs = [];
    function load() {
      var cli, builtin, cb2;
      for (var i = 0; i < arguments.length; i++)
        switch (typeof arguments[i]) {
          case "string":
            builtin = arguments[i];
            break;
          case "object":
            cli = arguments[i];
            break;
          case "function":
            cb2 = arguments[i];
            break;
        }
      if (!cb2)
        cb2 = function() {
        };
      if (exports2.loaded) {
        var ret2 = exports2.loaded;
        if (cli) {
          ret2 = new Conf(ret2);
          ret2.unshift(cli);
        }
        return process.nextTick(cb2.bind(null, null, ret2));
      }
      if (!cli)
        cli = {};
      else
        cli = Object.keys(cli).reduce(function(c, k) {
          c[k] = cli[k];
          return c;
        }, {});
      loadCbs.push(cb2);
      if (loading)
        return;
      loading = true;
      cb2 = once(function(er, conf) {
        if (!er) {
          exports2.loaded = conf;
          loading = false;
        }
        loadCbs.forEach(function(fn) {
          fn(er, conf);
        });
        loadCbs.length = 0;
      });
      exports2.usingBuiltin = !!builtin;
      var rc = exports2.rootConf = new Conf();
      if (builtin)
        rc.addFile(builtin, "builtin");
      else
        rc.add({}, "builtin");
      rc.on("load", function() {
        load_(builtin, rc, cli, cb2);
      });
      rc.on("error", cb2);
    }
    function load_(builtin, rc, cli, cb2) {
      var defaults = configDefs.defaults;
      var conf = new Conf(rc);
      conf.usingBuiltin = !!builtin;
      conf.add(cli, "cli");
      conf.addEnv();
      conf.loadPrefix(function(er) {
        if (er)
          return cb2(er);
        var projectConf = path.resolve(conf.localPrefix, ".npmrc");
        var defaultUserConfig = rc.get("userconfig");
        var resolvedUserConfig = conf.get("userconfig");
        if (!conf.get("global") && projectConf !== defaultUserConfig && projectConf !== resolvedUserConfig) {
          conf.addFile(projectConf, "project");
          conf.once("load", afterPrefix);
        } else {
          conf.add({}, "project");
          afterPrefix();
        }
      });
      function afterPrefix() {
        conf.addFile(conf.get("userconfig"), "user");
        conf.once("error", cb2);
        conf.once("load", afterUser);
      }
      function afterUser() {
        if (conf.get("prefix")) {
          var etc = path.resolve(conf.get("prefix"), "etc");
          mkdirp(etc, function(err) {
            defaults.globalconfig = path.resolve(etc, "npmrc");
            defaults.globalignorefile = path.resolve(etc, "npmignore");
            afterUserContinuation();
          });
        } else {
          afterUserContinuation();
        }
      }
      function afterUserContinuation() {
        conf.addFile(conf.get("globalconfig"), "global");
        conf.root = defaults;
        conf.add(rc.shift(), "builtin");
        conf.once("load", function() {
          conf.loadExtras(afterExtras);
        });
      }
      function afterExtras(er) {
        if (er)
          return cb2(er);
        validate(conf);
        var cafile = conf.get("cafile");
        if (cafile) {
          return conf.loadCAFile(cafile, finalize);
        }
        finalize();
      }
      function finalize(er) {
        if (er) {
          return cb2(er);
        }
        exports2.loaded = conf;
        cb2(er, conf);
      }
    }
    inherits2(Conf, CC);
    function Conf(base) {
      if (!(this instanceof Conf))
        return new Conf(base);
      CC.apply(this);
      if (base)
        if (base instanceof Conf)
          this.root = base.list[0] || base.root;
        else
          this.root = base;
      else
        this.root = configDefs.defaults;
    }
    Conf.prototype.loadPrefix = require_load_prefix();
    Conf.prototype.loadCAFile = require_load_cafile();
    Conf.prototype.loadUid = require_load_uid();
    Conf.prototype.setUser = require_set_user();
    Conf.prototype.findPrefix = require_find_prefix();
    Conf.prototype.getCredentialsByURI = require_get_credentials_by_uri();
    Conf.prototype.setCredentialsByURI = require_set_credentials_by_uri();
    Conf.prototype.clearCredentialsByURI = require_clear_credentials_by_uri();
    Conf.prototype.loadExtras = function(cb2) {
      this.setUser((function(er) {
        if (er)
          return cb2(er);
        this.loadUid((function(er2) {
          if (er2)
            return cb2(er2);
          mkdirp(this.prefix, cb2);
        }).bind(this));
      }).bind(this));
    };
    Conf.prototype.save = function(where2, cb2) {
      var target = this.sources[where2];
      if (!target || !(target.path || target.source) || !target.data) {
        if (where2 !== "builtin")
          var er = new Error("bad save target: " + where2);
        if (cb2) {
          process.nextTick(cb2.bind(null, er));
          return this;
        }
        return this.emit("error", er);
      }
      if (target.source) {
        var pref = target.prefix || "";
        Object.keys(target.data).forEach(function(k) {
          target.source[pref + k] = target.data[k];
        });
        if (cb2)
          process.nextTick(cb2);
        return this;
      }
      var data = ini.stringify(target.data);
      then = then.bind(this);
      done = done.bind(this);
      this._saving++;
      var mode = where2 === "user" ? "0600" : "0666";
      if (!data.trim()) {
        fs.unlink(target.path, function() {
          done(null);
        });
      } else {
        mkdirp(path.dirname(target.path), function(er2) {
          if (er2)
            return then(er2);
          fs.writeFile(target.path, data, "utf8", function(er3) {
            if (er3)
              return then(er3);
            if (where2 === "user" && myUid && myGid)
              fs.chown(target.path, +myUid, +myGid, then);
            else
              then();
          });
        });
      }
      function then(er2) {
        if (er2)
          return done(er2);
        fs.chmod(target.path, mode, done);
      }
      function done(er2) {
        if (er2) {
          if (cb2)
            return cb2(er2);
          else
            return this.emit("error", er2);
        }
        this._saving--;
        if (this._saving === 0) {
          if (cb2)
            cb2();
          this.emit("save");
        }
      }
      return this;
    };
    Conf.prototype.addFile = function(file, name) {
      name = name || file;
      var marker = { __source__: name };
      this.sources[name] = { path: file, type: "ini" };
      this.push(marker);
      this._await();
      fs.readFile(file, "utf8", (function(er, data) {
        if (er)
          return this.add({}, marker);
        this.addString(data, file, "ini", marker);
      }).bind(this));
      return this;
    };
    Conf.prototype.parse = function(content, file) {
      return CC.prototype.parse.call(this, content, file, "ini");
    };
    Conf.prototype.add = function(data, marker) {
      try {
        Object.keys(data).forEach(function(k) {
          data[k] = parseField(data[k], k);
        });
      } catch (e) {
        this.emit("error", e);
        return this;
      }
      return CC.prototype.add.call(this, data, marker);
    };
    Conf.prototype.addEnv = function(env) {
      env = env || process.env;
      var conf = {};
      Object.keys(env).filter(function(k) {
        return k.match(/^npm_config_/i);
      }).forEach(function(k) {
        if (!env[k])
          return;
        var p = k.toLowerCase().replace(/^npm_config_/, "").replace(/(?!^)_/g, "-");
        conf[p] = env[k];
      });
      return CC.prototype.addEnv.call(this, "", conf, "env");
    };
    function parseField(f2, k) {
      if (typeof f2 !== "string" && !(f2 instanceof String))
        return f2;
      var typeList = [].concat(types[k]);
      var isPath = -1 !== typeList.indexOf(path);
      var isBool = -1 !== typeList.indexOf(Boolean);
      var isString = -1 !== typeList.indexOf(String);
      var isUmask = -1 !== typeList.indexOf(Umask);
      var isNumber = -1 !== typeList.indexOf(Number);
      f2 = ("" + f2).trim();
      if (f2.match(/^".*"$/)) {
        try {
          f2 = JSON.parse(f2);
        } catch (e) {
          throw new Error("Failed parsing JSON config key " + k + ": " + f2);
        }
      }
      if (isBool && !isString && f2 === "")
        return true;
      switch (f2) {
        case "true":
          return true;
        case "false":
          return false;
        case "null":
          return null;
        case "undefined":
          return void 0;
      }
      f2 = envReplace(f2);
      if (isPath) {
        var homePattern = process.platform === "win32" ? /^~(\/|\\)/ : /^~\//;
        if (f2.match(homePattern) && process.env.HOME) {
          f2 = path.resolve(process.env.HOME, f2.substr(2));
        }
        f2 = path.resolve(f2);
      }
      if (isUmask)
        f2 = umask.fromString(f2);
      if (isNumber && !isNaN(f2))
        f2 = +f2;
      return f2;
    }
    function envReplace(f2) {
      if (typeof f2 !== "string" || !f2)
        return f2;
      var envExpr = /(\\*)\$\{([^}]+)\}/g;
      return f2.replace(envExpr, function(orig, esc, name) {
        esc = esc.length && esc.length % 2;
        if (esc)
          return orig;
        if (void 0 === process.env[name])
          throw new Error("Failed to replace env in config: " + orig);
        return process.env[name];
      });
    }
    function validate(cl) {
      cl.list.forEach(function(conf) {
        nopt.clean(conf, configDefs.types);
      });
      nopt.clean(cl.root, configDefs.types);
    }
  }
});

// node_modules/npm/node_modules/graceful-fs/fs.js
var require_fs2 = __commonJS({
  "node_modules/npm/node_modules/graceful-fs/fs.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    module2.exports = clone2(fs);
    function clone2(obj2) {
      if (obj2 === null || typeof obj2 !== "object")
        return obj2;
      if (obj2 instanceof Object)
        var copy = { __proto__: obj2.__proto__ };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj2).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj2, key));
      });
      return copy;
    }
  }
});

// browser-external:constants
var require_constants = __commonJS({
  "browser-external:constants"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "constants" has been externalized for browser compatibility. Cannot access "constants.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/npm/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/npm/node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var fs = require_fs2();
    var constants = require_constants();
    var origCwd = process.cwd;
    var cwd = null;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    module2.exports = patch;
    function patch(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      if (!fs2.lchmod) {
        fs2.lchmod = function(path, mode, cb2) {
          if (cb2)
            process.nextTick(cb2);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (!fs2.lchown) {
        fs2.lchown = function(path, uid, gid, cb2) {
          if (cb2)
            process.nextTick(cb2);
        };
        fs2.lchownSync = function() {
        };
      }
      if (process.platform === "win32") {
        fs2.rename = /* @__PURE__ */ function(fs$rename) {
          return function(from, to, cb2) {
            var start = Date.now();
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 1e3) {
                return fs$rename(from, to, CB);
              }
              if (cb2)
                cb2(er);
            });
          };
        }(fs2.rename);
      }
      fs2.read = /* @__PURE__ */ function(fs$read) {
        return function(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _3, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
        };
      }(fs2.read);
      fs2.readSync = /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
    }
    function patchLchmod(fs2) {
      fs2.lchmod = function(path, mode, callback) {
        fs2.open(
          path,
          constants.O_WRONLY | constants.O_SYMLINK,
          mode,
          function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs2.fchmod(fd, mode, function(err2) {
              fs2.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          }
        );
      };
      fs2.lchmodSync = function(path, mode) {
        var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret2;
        try {
          ret2 = fs2.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs2.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs2.closeSync(fd);
          }
        }
        return ret2;
      };
    }
    function patchLutimes(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs2.lutimes = function(path, at, mt, cb2) {
          fs2.open(path, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb2)
                cb2(er);
              return;
            }
            fs2.futimes(fd, at, mt, function(er2) {
              fs2.close(fd, function(er22) {
                if (cb2)
                  cb2(er2 || er22);
              });
            });
          });
        };
        fs2.lutimesSync = function(path, at, mt) {
          var fd = fs2.openSync(path, constants.O_SYMLINK);
          var ret2;
          var threw = true;
          try {
            ret2 = fs2.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret2;
        };
      } else {
        fs2.lutimes = function(_a, _b, _c, cb2) {
          if (cb2)
            process.nextTick(cb2);
        };
        fs2.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb2) {
        return orig.call(fs, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb2)
            cb2.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb2) {
        return orig.call(fs, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb2)
            cb2.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// node_modules/npm/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/npm/node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require_stream().Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys2 = Object.keys(options);
        for (var index = 0, length = keys2.length; index < length; index++) {
          var key = keys2[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys2 = Object.keys(options);
        for (var index = 0, length = keys2.length; index < length; index++) {
          var key = keys2[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/npm/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/npm/node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs = require_fs();
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var queue = [];
    var util = require_util();
    function noop2() {
    }
    var debug = noop2;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(queue);
        require_assert().equal(queue.length, 0);
      });
    }
    module2.exports = patch(require_fs2());
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
      module2.exports = patch(fs);
    }
    module2.exports.close = fs.close = /* @__PURE__ */ function(fs$close) {
      return function(fd, cb2) {
        return fs$close.call(fs, fd, function(err) {
          if (!err)
            retry();
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        });
      };
    }(fs.close);
    module2.exports.closeSync = fs.closeSync = /* @__PURE__ */ function(fs$closeSync) {
      return function(fd) {
        var rval = fs$closeSync.apply(fs, arguments);
        retry();
        return rval;
      };
    }(fs.closeSync);
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.FileReadStream = ReadStream;
      fs2.FileWriteStream = WriteStream;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb2) {
        if (typeof options === "function")
          cb2 = options, options = null;
        return go$readFile(path, options, cb2);
        function go$readFile(path2, options2, cb3) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb3]]);
            else {
              if (typeof cb3 === "function")
                cb3.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb2) {
        if (typeof options === "function")
          cb2 = options, options = null;
        return go$writeFile(path, data, options, cb2);
        function go$writeFile(path2, data2, options2, cb3) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb3]]);
            else {
              if (typeof cb3 === "function")
                cb3.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb2) {
        if (typeof options === "function")
          cb2 = options, options = null;
        return go$appendFile(path, data, options, cb2);
        function go$appendFile(path2, data2, options2, cb3) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb3]]);
            else {
              if (typeof cb3 === "function")
                cb3.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      function readdir(path, cb2) {
        return go$readdir(path, cb2);
        function go$readdir() {
          return fs$readdir(path, function(err, files) {
            if (files && files.sort)
              files.sort();
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readdir, [path, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
      var fs$WriteStream = fs2.WriteStream;
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
      fs2.ReadStream = ReadStream;
      fs2.WriteStream = WriteStream;
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb2) {
        if (typeof mode === "function")
          cb2 = mode, mode = null;
        return go$open(path, flags, mode, cb2);
        function go$open(path2, flags2, mode2, cb3) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb3]]);
            else {
              if (typeof cb3 === "function")
                cb3.apply(this, arguments);
              retry();
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      queue.push(elem);
    }
    function retry() {
      var elem = queue.shift();
      if (elem) {
        debug("RETRY", elem[0].name, elem[1]);
        elem[0].apply(null, elem[1]);
      }
    }
  }
});

// node_modules/npm/node_modules/which/node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/npm/node_modules/which/node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require_fs();
    function checkPathExt(path, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function isexe(path, options, cb2) {
      fs.stat(path, function(er, st) {
        cb2(er, er ? false : checkPathExt(path, options));
      });
    }
    function sync(path, options) {
      fs.statSync(path);
      return checkPathExt(path, options);
    }
  }
});

// node_modules/npm/node_modules/which/node_modules/isexe/access.js
var require_access = __commonJS({
  "node_modules/npm/node_modules/which/node_modules/isexe/access.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require_fs();
    function isexe(path, _3, cb2) {
      fs.access(path, fs.X_OK, function(er) {
        cb2(er, !er);
      });
    }
    function sync(path, _3) {
      fs.accessSync(path, fs.X_OK);
      return true;
    }
  }
});

// node_modules/npm/node_modules/which/node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/npm/node_modules/which/node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require_fs();
    function isexe(path, options, cb2) {
      fs.stat(path, function(er, st) {
        cb2(er, er ? false : checkMode(st, options));
      });
    }
    function sync(path, options) {
      return checkMode(fs.statSync(path), options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret2 = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret2;
    }
  }
});

// node_modules/npm/node_modules/which/node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/npm/node_modules/which/node_modules/isexe/index.js"(exports2, module2) {
    var fs = require_fs();
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else if (typeof fs.access === "function") {
      core = require_access();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path, options, cb2) {
      if (typeof options === "function") {
        cb2 = options;
        options = {};
      }
      if (!cb2) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject2) {
          isexe(path, options || {}, function(er, is) {
            if (er) {
              reject2(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb2(er, is);
      });
    }
    function sync(path, options) {
      try {
        return core.sync(path, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/npm/node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/npm/node_modules/which/which.js"(exports2, module2) {
    module2.exports = which;
    which.sync = whichSync;
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path = require_path();
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var fs = require_fs();
    function getNotFoundError(cmd) {
      var er = new Error("not found: " + cmd);
      er.code = "ENOENT";
      return er;
    }
    function getPathInfo(cmd, opt) {
      var colon = opt.colon || COLON;
      var pathEnv = opt.path || process.env.PATH || "";
      var pathExt = [""];
      pathEnv = pathEnv.split(colon);
      var pathExtExe = "";
      if (isWindows) {
        pathEnv.unshift(process.cwd());
        pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
        pathExt = pathExtExe.split(colon);
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
        pathEnv = [""];
      return {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
      };
    }
    function which(cmd, opt, cb2) {
      if (typeof opt === "function") {
        cb2 = opt;
        opt = {};
      }
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      (function F(i, l2) {
        if (i === l2) {
          if (opt.all && found.length)
            return cb2(null, found);
          else
            return cb2(getNotFoundError(cmd));
        }
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        ;
        (function E(ii, ll) {
          if (ii === ll)
            return F(i + 1, l2);
          var ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, function(er, is) {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext);
              else
                return cb2(null, p + ext);
            }
            return E(ii + 1, ll);
          });
        })(0, pathExt.length);
      })(0, pathEnv.length);
    }
    function whichSync(cmd, opt) {
      opt = opt || {};
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      for (var i = 0, l2 = pathEnv.length; i < l2; i++) {
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        for (var j = 0, ll = pathExt.length; j < ll; j++) {
          var cur = p + pathExt[j];
          var is;
          try {
            is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      throw getNotFoundError(cmd);
    }
  }
});

// node_modules/npm/node_modules/npm-registry-client/index.js
var require_npm_registry_client = __commonJS({
  "node_modules/npm/node_modules/npm-registry-client/index.js"(exports2, module2) {
    module2.exports = RegClient;
    var join = require_path().join;
    var fs = require_graceful_fs();
    var npmlog;
    try {
      npmlog = require_log();
    } catch (er) {
      npmlog = {
        error: noop2,
        warn: noop2,
        info: noop2,
        verbose: noop2,
        silly: noop2,
        http: noop2,
        pause: noop2,
        resume: noop2
      };
    }
    function noop2() {
    }
    function RegClient(config) {
      this.config = Object.create(config || {});
      this.config.proxy = this.config.proxy || {};
      if (!this.config.proxy.https && this.config.proxy.http) {
        this.config.proxy.https = this.config.proxy.http;
      }
      this.config.ssl = this.config.ssl || {};
      if (this.config.ssl.strict === void 0)
        this.config.ssl.strict = true;
      this.config.retry = this.config.retry || {};
      if (typeof this.config.retry.retries !== "number")
        this.config.retry.retries = 2;
      if (typeof this.config.retry.factor !== "number")
        this.config.retry.factor = 10;
      if (typeof this.config.retry.minTimeout !== "number")
        this.config.retry.minTimeout = 1e4;
      if (typeof this.config.retry.maxTimeout !== "number")
        this.config.retry.maxTimeout = 6e4;
      if (typeof this.config.maxSockets !== "number")
        this.config.maxSockets = 50;
      this.config.userAgent = this.config.userAgent || "node/" + process.version;
      this.config.defaultTag = this.config.defaultTag || "latest";
      this.log = this.config.log || npmlog;
      delete this.config.log;
      var client = this;
      fs.readdirSync(join(__dirname, "lib")).forEach(function(f2) {
        var entry = join(__dirname, "lib", f2);
        var stat = fs.statSync(entry);
        if (stat.isDirectory()) {
          var groupName = f2.replace(/-([a-z])/, dashToCamel);
          fs.readdirSync(entry).forEach(function(f3) {
            if (!f3.match(/\.js$/))
              return;
            if (!client[groupName]) {
              client[groupName] = Object.create(client);
            }
            var name2 = f3.replace(/\.js$/, "").replace(/-([a-z])/, dashToCamel);
            client[groupName][name2] = __require(join(entry, f3));
          });
          return;
        }
        if (!f2.match(/\.js$/))
          return;
        var name = f2.replace(/\.js$/, "").replace(/-([a-z])/, dashToCamel);
        client[name] = __require(entry);
      });
    }
    function dashToCamel(_3, l2) {
      return l2.toUpperCase();
    }
  }
});

// node_modules/npm/node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/npm/node_modules/chownr/chownr.js"(exports2, module2) {
    module2.exports = chownr;
    chownr.sync = chownrSync;
    var fs = require_fs();
    var path = require_path();
    function chownr(p, uid, gid, cb2) {
      fs.readdir(p, function(er, children) {
        if (er && er.code !== "ENOTDIR")
          return cb2(er);
        if (er || !children.length)
          return fs.chown(p, uid, gid, cb2);
        var len = children.length, errState = null;
        children.forEach(function(child) {
          var pathChild = path.resolve(p, child);
          fs.lstat(pathChild, function(er2, stats) {
            if (er2)
              return cb2(er2);
            if (!stats.isSymbolicLink())
              chownr(pathChild, uid, gid, then);
            else
              then();
          });
        });
        function then(er2) {
          if (errState)
            return;
          if (er2)
            return cb2(errState = er2);
          if (--len === 0)
            return fs.chown(p, uid, gid, cb2);
        }
      });
    }
    function chownrSync(p, uid, gid) {
      var children;
      try {
        children = fs.readdirSync(p);
      } catch (er) {
        if (er && er.code === "ENOTDIR")
          return fs.chownSync(p, uid, gid);
        throw er;
      }
      if (!children.length)
        return fs.chownSync(p, uid, gid);
      children.forEach(function(child) {
        var pathChild = path.resolve(p, child);
        var stats = fs.lstatSync(pathChild);
        if (!stats.isSymbolicLink())
          chownrSync(pathChild, uid, gid);
      });
      return fs.chownSync(p, uid, gid);
    }
  }
});

// node_modules/npm/node_modules/dezalgo/node_modules/asap/browser-raw.js
var require_browser_raw = __commonJS({
  "node_modules/npm/node_modules/dezalgo/node_modules/asap/browser-raw.js"(exports2, module2) {
    "use strict";
    module2.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var requestFlush;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;
    if (typeof BrowserMutationObserver === "function") {
      requestFlush = makeRequestCallFromMutationObserver(flush);
    } else {
      requestFlush = makeRequestCallFromTimer(flush);
    }
    rawAsap.requestFlush = requestFlush;
    function makeRequestCallFromMutationObserver(callback) {
      var toggle = 1;
      var observer = new BrowserMutationObserver(callback);
      var node = document.createTextNode("");
      observer.observe(node, { characterData: true });
      return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
      };
    }
    function makeRequestCallFromTimer(callback) {
      return function requestCall() {
        var timeoutHandle = setTimeout(handleTimer, 0);
        var intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
          clearTimeout(timeoutHandle);
          clearInterval(intervalHandle);
          callback();
        }
      };
    }
    rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
  }
});

// node_modules/npm/node_modules/dezalgo/node_modules/asap/browser-asap.js
var require_browser_asap = __commonJS({
  "node_modules/npm/node_modules/dezalgo/node_modules/asap/browser-asap.js"(exports2, module2) {
    "use strict";
    var rawAsap = require_browser_raw();
    var freeTasks = [];
    var pendingErrors = [];
    var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
    function throwFirstError() {
      if (pendingErrors.length) {
        throw pendingErrors.shift();
      }
    }
    module2.exports = asap;
    function asap(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
    }
    RawTask.prototype.call = function() {
      try {
        this.task.call();
      } catch (error) {
        if (asap.onerror) {
          asap.onerror(error);
        } else {
          pendingErrors.push(error);
          requestErrorThrow();
        }
      } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
      }
    };
  }
});

// node_modules/npm/node_modules/dezalgo/dezalgo.js
var require_dezalgo = __commonJS({
  "node_modules/npm/node_modules/dezalgo/dezalgo.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(dezalgo);
    var asap = require_browser_asap();
    function dezalgo(cb2) {
      var sync = true;
      asap(function() {
        sync = false;
      });
      return function zalgoSafe() {
        var args = arguments;
        var me = this;
        if (sync)
          asap(function() {
            cb2.apply(me, args);
          });
        else
          cb2.apply(me, args);
      };
    }
  }
});

// node_modules/npm/node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/npm/node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb2) {
      if (reqs[key]) {
        reqs[key].push(cb2);
        return null;
      } else {
        reqs[key] = [cb2];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice2(arguments);
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args);
        }
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      });
    }
    function slice2(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/npm/lib/utils/correct-mkdir.js
var require_correct_mkdir = __commonJS({
  "node_modules/npm/lib/utils/correct-mkdir.js"(exports2, module2) {
    var chownr = require_chownr();
    var dezalgo = require_dezalgo();
    var fs = require_graceful_fs();
    var inflight = require_inflight();
    var log = require_log();
    var mkdirp = require_mkdirp();
    var stats = {};
    var effectiveOwner;
    module2.exports = function correctMkdir(path, cb2) {
      cb2 = dezalgo(cb2);
      cb2 = inflight("correctMkdir:" + path, cb2);
      if (!cb2) {
        return log.verbose("correctMkdir", path, "correctMkdir already in flight; waiting");
      } else {
        log.verbose("correctMkdir", path, "correctMkdir not in flight; initializing");
      }
      if (stats[path])
        return cb2(null, stats[path]);
      fs.stat(path, function(er, st) {
        if (er)
          return makeDirectory(path, cb2);
        if (!st.isDirectory()) {
          log.error("correctMkdir", "invalid dir %s", path);
          return cb2(er);
        }
        var ownerStats = calculateOwner();
        if (st.uid !== ownerStats.uid) {
          stats[path] = ownerStats;
          setPermissions(path, ownerStats, cb2);
        } else {
          stats[path] = st;
          cb2(null, stats[path]);
        }
      });
    };
    function calculateOwner() {
      if (!effectiveOwner) {
        effectiveOwner = { uid: 0, gid: 0 };
        if (!process.getuid) {
          return effectiveOwner;
        }
        effectiveOwner.uid = +process.getuid();
        effectiveOwner.gid = +process.getgid();
        if (effectiveOwner.uid === 0) {
          if (process.env.SUDO_UID)
            effectiveOwner.uid = +process.env.SUDO_UID;
          if (process.env.SUDO_GID)
            effectiveOwner.gid = +process.env.SUDO_GID;
        }
      }
      return effectiveOwner;
    }
    function makeDirectory(path, cb2) {
      cb2 = inflight("makeDirectory:" + path, cb2);
      if (!cb2) {
        return log.verbose("makeDirectory", path, "creation already in flight; waiting");
      } else {
        log.verbose("makeDirectory", path, "creation not in flight; initializing");
      }
      var owner = calculateOwner();
      if (!process.getuid) {
        return mkdirp(path, function(er) {
          log.verbose("makeCacheDir", "UID & GID are irrelevant on", process.platform);
          stats[path] = owner;
          return cb2(er, stats[path]);
        });
      }
      if (owner.uid !== 0 || !process.env.HOME) {
        log.silly(
          "makeDirectory",
          path,
          "uid:",
          owner.uid,
          "gid:",
          owner.gid
        );
        stats[path] = owner;
        mkdirp(path, afterMkdir);
      } else {
        fs.stat(process.env.HOME, function(er, st) {
          if (er) {
            log.error("makeDirectory", "homeless?");
            return cb2(er);
          }
          log.silly(
            "makeDirectory",
            path,
            "uid:",
            st.uid,
            "gid:",
            st.gid
          );
          stats[path] = st;
          mkdirp(path, afterMkdir);
        });
      }
      function afterMkdir(er, made) {
        if (er || !stats[path] || isNaN(stats[path].uid) || isNaN(stats[path].gid)) {
          return cb2(er, stats[path]);
        }
        if (!made)
          return cb2(er, stats[path]);
        setPermissions(made, stats[path], cb2);
      }
    }
    function setPermissions(path, st, cb2) {
      chownr(path, st.uid, st.gid, function(er) {
        if (er && er.code === "ENOENT")
          return cb2(null, st);
        return cb2(er, st);
      });
    }
  }
});

// node_modules/npm/lib/cache/get-stat.js
var require_get_stat = __commonJS({
  "node_modules/npm/lib/cache/get-stat.js"(exports2, module2) {
    var npm = require_npm();
    var correctMkdir = require_correct_mkdir();
    module2.exports = function getCacheStat(cb2) {
      correctMkdir(npm.cache, cb2);
    };
  }
});

// node_modules/npm/node_modules/npm-cache-filename/index.js
var require_npm_cache_filename = __commonJS({
  "node_modules/npm/node_modules/npm-cache-filename/index.js"(exports2, module2) {
    var url = require_url();
    var path = require_path();
    module2.exports = cf;
    function cf(root2, u) {
      if (!u)
        return cf.bind(null, root2);
      ;
      u = url.parse(u);
      ;
      var h = u.host.replace(/:/g, "_");
      ;
      var revre = /(\?rev=|\?.*?&rev=|\/-rev\/).*$/;
      ;
      var parts = u.path.replace(revre, "").split("/").slice(1);
      ;
      if (u.hash && u.hash.length > 1) {
        parts.push(u.hash.slice(1));
        ;
      }
      ;
      ;
      var p = [root2, h].concat(parts.map(function(part) {
        return encodeURIComponent(part).replace(/%/g, "_");
        ;
      }));
      ;
      return path.join.apply(path, p);
      ;
    }
  }
});

// node_modules/npm/node_modules/glob/node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/npm/node_modules/glob/node_modules/fs.realpath/old.js"(exports2) {
    var pathModule = require_path();
    var isWindows = process.platform === "win32";
    var fs = require_fs();
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb2) {
      return typeof cb2 === "function" ? cb2 : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result2 = nextPartRe.exec(p);
        previous = current;
        current += result2[0];
        base = previous + result2[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb2) {
      if (typeof cb2 !== "function") {
        cb2 = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb2.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb2(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb2(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result2 = nextPartRe.exec(p);
        previous = current;
        current += result2[0];
        base = previous + result2[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb2(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb2(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb2(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/npm/node_modules/glob/node_modules/fs.realpath/index.js
var require_fs3 = __commonJS({
  "node_modules/npm/node_modules/glob/node_modules/fs.realpath/index.js"(exports2, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require_fs();
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb2) {
      if (ok) {
        return origRealpath(p, cache, cb2);
      }
      if (typeof cache === "function") {
        cb2 = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result2) {
        if (newError(er)) {
          old.realpath(p, cache, cb2);
        } else {
          cb2(er, result2);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/npm/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/npm/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/npm/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/npm/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/index.js"(exports2, module2) {
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range2(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range2;
    function range2(a, b, str) {
      var begs, beg, left, right, result2;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result2) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result2 = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result2 = [left, right];
        }
      }
      return result2;
    }
  }
});

// node_modules/npm/node_modules/minimatch/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/npm/node_modules/minimatch/node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = /^(.*,)+(.+)?$/.test(m.body);
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/npm/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/npm/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = { sep: "/" };
    try {
      path = require_path();
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter2;
    function filter2(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate2 = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l2 = pattern.length; i < l2 && pattern.charAt(i) === "!"; i++) {
        negate2 = !negate2;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate2;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_3, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f2) {
        return mm.match(f2);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f2, partial2) {
      this.debug("match", f2, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f2 === "";
      if (f2 === "/" && partial2)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f2 = f2.split(path.sep).join("/");
      }
      f2 = f2.split(slashSplit);
      this.debug(this.pattern, "split", f2);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f2.length - 1; i >= 0; i--) {
        filename = f2[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f2;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial2);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial2) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f2 = file[fi];
        this.debug(pattern, p, f2);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f2]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial2)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial2) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f2.toLowerCase() === p.toLowerCase();
          } else {
            hit = f2 === p;
          }
          this.debug("string match", p, f2, hit);
        } else {
          hit = f2.match(p);
          this.debug("pattern match", p, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial2;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/npm/node_modules/glob/node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/npm/node_modules/glob/node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result2 = splitDeviceRe.exec(path);
      var device = result2[1] || "";
      var isUnc = !!device && device.charAt(1) !== ":";
      return !!result2[2] || isUnc;
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/npm/node_modules/glob/common.js
var require_common = __commonJS({
  "node_modules/npm/node_modules/glob/common.js"(exports2) {
    exports2.alphasort = alphasort;
    exports2.alphasorti = alphasorti;
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj2, field) {
      return Object.prototype.hasOwnProperty.call(obj2, field);
    }
    var path = require_path();
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasorti(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    }
    function alphasort(a, b) {
      return a.localeCompare(b);
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = makeAbs(self2, self2.cwd);
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l2 = self2.matches.length; i < l2; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(self2.nocase ? alphasorti : alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f2) {
      var abs = f2;
      if (f2.charAt(0) === "/") {
        abs = path.join(self2.root, f2);
      } else if (isAbsolute(f2) || f2 === "") {
        abs = f2;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f2);
      } else {
        abs = path.resolve(f2);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/npm/node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/npm/node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs = require_fs();
    var rp = require_fs3();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require_util();
    var path = require_path();
    var assert = require_assert();
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate2 = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate2 && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this.matches[index][e] = true;
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[this._makeAbs(e)];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = fs.lstatSync(abs);
      } catch (er) {
        return null;
      }
      var isSym = lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f2, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f2);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this.matches[index][prefix] = true;
    };
    GlobSync.prototype._stat = function(f2) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = fs.lstatSync(abs);
        } catch (er) {
          return false;
        }
        if (lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c !== "DIR")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f2) {
      return common.makeAbs(this, f2);
    };
  }
});

// node_modules/npm/node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/npm/node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var fs = require_fs();
    var rp = require_fs3();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits2 = require_inherits_browser();
    var EE = require_events().EventEmitter;
    var path = require_path();
    var assert = require_assert();
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require_util();
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb2) {
      if (typeof options === "function")
        cb2 = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb2)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb2);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys2 = Object.keys(add);
      var i = keys2.length;
      while (i--) {
        origin[keys2[i]] = add[keys2[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits2(Glob, EE);
    function Glob(pattern, options, cb2) {
      if (typeof options === "function") {
        cb2 = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb2)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb2);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb2 === "function") {
        cb2 = once(cb2);
        this.on("error", cb2);
        this.on("end", function(matches) {
          cb2(null, matches);
        });
      }
      var self2 = this;
      var n = this.minimatch.set.length;
      this._processing = 0;
      this.matches = new Array(n);
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb2) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb2();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb2();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb2();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f2) {
      return common.makeAbs(this, f2);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq2 = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq2.length; i++) {
            var e = eq2[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb2) {
      assert(this instanceof Glob);
      assert(typeof cb2 === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb2]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb2);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb2();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb2);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb2);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb2) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb2);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb2) {
      if (!entries)
        return cb2();
      var pn = remain[0];
      var negate2 = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate2 && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb2();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb2();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb2);
      }
      cb2();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (this.matches[index][e])
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = this._makeAbs(e);
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      if (this.mark)
        e = this._mark(e);
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb2) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb2);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er)
          return cb2();
        var isSym = lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb2();
        } else
          self2._readdir(abs, false, cb2);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb2) {
      if (this.aborted)
        return;
      cb2 = inflight("readdir\0" + abs + "\0" + inGlobStar, cb2);
      if (!cb2)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb2);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb2();
        if (Array.isArray(c))
          return cb2(null, c);
      }
      var self2 = this;
      fs.readdir(abs, readdirCb(this, abs, cb2));
    };
    function readdirCb(self2, abs, cb2) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb2);
        else
          self2._readdirEntries(abs, entries, cb2);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb2) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb2(null, entries);
    };
    Glob.prototype._readdirError = function(f2, er, cb2) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f2);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb2();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb2) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb2);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb2) {
      if (!entries)
        return cb2();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb2);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb2();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb2);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb2);
      }
      cb2();
    };
    Glob.prototype._processSimple = function(prefix, index, cb2) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb2);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb2) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb2();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb2();
    };
    Glob.prototype._stat = function(f2, cb2) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return cb2();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb2(null, c);
        if (needDir && c === "FILE")
          return cb2();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb2(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb2();
          else
            return cb2(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f2, abs, null, lstat, cb2);
            else
              self2._stat2(f2, abs, er2, stat2, cb2);
          });
        } else {
          self2._stat2(f2, abs, er, lstat, cb2);
        }
      }
    };
    Glob.prototype._stat2 = function(f2, abs, er, stat, cb2) {
      if (er) {
        this.statCache[abs] = false;
        return cb2();
      }
      var needDir = f2.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && !stat.isDirectory())
        return cb2(null, false, stat);
      var c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c !== "DIR")
        return cb2();
      return cb2(null, c, stat);
    };
  }
});

// node_modules/npm/node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/npm/node_modules/rimraf/rimraf.js"(exports2, module2) {
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
    var assert = require_assert();
    var path = require_path();
    var fs = require_fs();
    var glob = require_glob();
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    function defaults(options) {
      var methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach(function(m) {
        options[m] = options[m] || fs[m];
        m = m + "Sync";
        options[m] = options[m] || fs[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    }
    function rimraf(p, options, cb2) {
      if (typeof options === "function") {
        cb2 = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb2, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      var busyTries = 0;
      var errState = null;
      var n = 0;
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, function(er, stat) {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
      function next(er) {
        errState = errState || er;
        if (--n === 0)
          cb2(errState);
      }
      function afterGlob(er, results) {
        if (er)
          return cb2(er);
        n = results.length;
        if (n === 0)
          return cb2();
        results.forEach(function(p2) {
          rimraf_(p2, options, function CB(er2) {
            if (er2) {
              if (isWindows && (er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                var time = busyTries * 100;
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, time);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          });
        });
      }
    }
    function rimraf_(p, options, cb2) {
      assert(p);
      assert(options);
      assert(typeof cb2 === "function");
      options.lstat(p, function(er, st) {
        if (er && er.code === "ENOENT")
          return cb2(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb2);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb2);
        options.unlink(p, function(er2) {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb2(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb2) : rmdir(p, options, er2, cb2);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb2);
          }
          return cb2(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb2) {
      assert(p);
      assert(options);
      assert(typeof cb2 === "function");
      if (er)
        assert(er instanceof Error);
      options.chmod(p, 666, function(er2) {
        if (er2)
          cb2(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, function(er3, stats) {
            if (er3)
              cb2(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb2);
            else
              options.unlink(p, cb2);
          });
      });
    }
    function fixWinEPERMSync(p, options, er) {
      assert(p);
      assert(options);
      if (er)
        assert(er instanceof Error);
      try {
        options.chmodSync(p, 666);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      try {
        var stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    }
    function rmdir(p, options, originalEr, cb2) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      assert(typeof cb2 === "function");
      options.rmdir(p, function(er) {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb2);
        else if (er && er.code === "ENOTDIR")
          cb2(originalEr);
        else
          cb2(er);
      });
    }
    function rmkids(p, options, cb2) {
      assert(p);
      assert(options);
      assert(typeof cb2 === "function");
      options.readdir(p, function(er, files) {
        if (er)
          return cb2(er);
        var n = files.length;
        if (n === 0)
          return options.rmdir(p, cb2);
        var errState;
        files.forEach(function(f2) {
          rimraf(path.join(p, f2), options, function(er2) {
            if (errState)
              return;
            if (er2)
              return cb2(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb2);
          });
        });
      });
    }
    function rimrafSync(p, options) {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      var results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (var i = 0; i < results.length; i++) {
        var p = results[i];
        try {
          var st = options.lstatSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p, options, null);
          else
            options.unlinkSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p, options, er);
        }
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach(function(f2) {
        rimrafSync(path.join(p, f2), options);
      });
      options.rmdirSync(p, options);
    }
  }
});

// node_modules/npm/node_modules/slide/lib/async-map.js
var require_async_map = __commonJS({
  "node_modules/npm/node_modules/slide/lib/async-map.js"(exports2, module2) {
    module2.exports = asyncMap;
    function asyncMap() {
      var steps = Array.prototype.slice.call(arguments), list = steps.shift() || [], cb_ = steps.pop();
      if (typeof cb_ !== "function")
        throw new Error(
          "No callback provided to asyncMap"
        );
      if (!list)
        return cb_(null, []);
      if (!Array.isArray(list))
        list = [list];
      var n = steps.length, data = [], errState = null, l2 = list.length, a = l2 * n;
      if (!a)
        return cb_(null, []);
      function cb2(er) {
        if (er && !errState)
          errState = er;
        var argLen = arguments.length;
        for (var i = 1; i < argLen; i++)
          if (arguments[i] !== void 0) {
            data[i - 1] = (data[i - 1] || []).concat(arguments[i]);
          }
        if (list.length > l2) {
          var newList = list.slice(l2);
          a += (list.length - l2) * n;
          l2 = list.length;
          process.nextTick(function() {
            newList.forEach(function(ar) {
              steps.forEach(function(fn) {
                fn(ar, cb2);
              });
            });
          });
        }
        if (--a === 0)
          cb_.apply(null, [errState].concat(data));
      }
      list.forEach(function(ar) {
        steps.forEach(function(fn) {
          fn(ar, cb2);
        });
      });
    }
  }
});

// node_modules/npm/node_modules/slide/lib/bind-actor.js
var require_bind_actor = __commonJS({
  "node_modules/npm/node_modules/slide/lib/bind-actor.js"(exports2, module2) {
    module2.exports = bindActor;
    function bindActor() {
      var args = Array.prototype.slice.call(arguments), obj2 = null, fn;
      if (typeof args[0] === "object") {
        obj2 = args.shift();
        fn = args.shift();
        if (typeof fn === "string")
          fn = obj2[fn];
      } else
        fn = args.shift();
      return function(cb2) {
        fn.apply(obj2, args.concat(cb2));
      };
    }
  }
});

// node_modules/npm/node_modules/slide/lib/chain.js
var require_chain = __commonJS({
  "node_modules/npm/node_modules/slide/lib/chain.js"(exports2, module2) {
    module2.exports = chain2;
    var bindActor = require_bind_actor();
    chain2.first = {};
    chain2.last = {};
    function chain2(things, cb2) {
      var res = [];
      (function LOOP(i, len) {
        if (i >= len)
          return cb2(null, res);
        if (Array.isArray(things[i]))
          things[i] = bindActor.apply(
            null,
            things[i].map(function(i2) {
              return i2 === chain2.first ? res[0] : i2 === chain2.last ? res[res.length - 1] : i2;
            })
          );
        if (!things[i])
          return LOOP(i + 1, len);
        things[i](function(er, data) {
          if (er)
            return cb2(er, res);
          if (data !== void 0)
            res = res.concat(data);
          LOOP(i + 1, len);
        });
      })(0, things.length);
    }
  }
});

// node_modules/npm/node_modules/slide/lib/slide.js
var require_slide = __commonJS({
  "node_modules/npm/node_modules/slide/lib/slide.js"(exports2) {
    exports2.asyncMap = require_async_map();
    exports2.bindActor = require_bind_actor();
    exports2.chain = require_chain();
  }
});

// node_modules/npm/node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "node_modules/npm/node_modules/imurmurhash/imurmurhash.js"(exports2, module2) {
    (function() {
      var cache;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed);
        if (typeof key === "string" && key.length > 0) {
          m.hash(key);
        }
        if (m !== this) {
          return m;
        }
      }
      ;
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch (this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
            k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        this.rem = len + this.rem & 3;
        len -= this.rem;
        if (len > 0) {
          h1 = this.h1;
          while (1) {
            k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196 & 4294967295;
            if (i >= len) {
              break;
            }
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
            top = key.charCodeAt(i++);
            k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          }
          k1 = 0;
          switch (this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        this.k1 = k1;
        return this;
      };
      MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
      };
      MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === "number" ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
      };
      cache = new MurmurHash3();
      if (typeof module2 != "undefined") {
        module2.exports = MurmurHash3;
      } else {
        this.MurmurHash3 = MurmurHash3;
      }
    })();
  }
});

// node_modules/npm/node_modules/write-file-atomic/index.js
var require_write_file_atomic = __commonJS({
  "node_modules/npm/node_modules/write-file-atomic/index.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var chain2 = require_slide().chain;
    var MurmurHash3 = require_imurmurhash();
    function murmurhex() {
      var hash = new MurmurHash3();
      for (var ii = 0; ii < arguments.length; ++ii)
        hash.hash("" + arguments[ii]);
      return hash.result();
    }
    var invocations = 0;
    var getTmpname = function(filename) {
      return filename + "." + murmurhex(__filename, process.pid, ++invocations);
    };
    module2.exports = function writeFile(filename, data, options, callback) {
      if (options instanceof Function) {
        callback = options;
        options = null;
      }
      if (!options)
        options = {};
      var tmpfile = getTmpname(filename);
      chain2([
        [fs, fs.writeFile, tmpfile, data, options],
        options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid],
        [fs, fs.rename, tmpfile, filename]
      ], function(err) {
        err ? fs.unlink(tmpfile, function() {
          callback(err);
        }) : callback();
      });
    };
    module2.exports.sync = function writeFileSync(filename, data, options) {
      if (!options)
        options = {};
      var tmpfile = getTmpname(filename);
      try {
        fs.writeFileSync(tmpfile, data, options);
        if (options.chown)
          fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
        fs.renameSync(tmpfile, filename);
      } catch (err) {
        try {
          fs.unlinkSync(tmpfile);
        } catch (e) {
        }
        throw err;
      }
    };
  }
});

// node_modules/npm/lib/cache/caching-client.js
var require_caching_client = __commonJS({
  "node_modules/npm/lib/cache/caching-client.js"(exports2, module2) {
    module2.exports = CachingRegistryClient;
    var path = require_path();
    var fs = require_graceful_fs();
    var url = require_url();
    var assert = require_assert();
    var inherits2 = require_util().inherits;
    var RegistryClient = require_npm_registry_client();
    var npm = require_npm();
    var log = require_log();
    var getCacheStat = require_get_stat();
    var cacheFile = require_npm_cache_filename();
    var mkdirp = require_mkdirp();
    var rimraf = require_rimraf();
    var chownr = require_chownr();
    var writeFile = require_write_file_atomic();
    function CachingRegistryClient(config) {
      RegistryClient.call(this, adaptConfig(config));
      this._mapToCache = cacheFile(config.get("cache"));
      this._request = this.request;
      this.request = this._invalidatingRequest;
      this.get = get2;
    }
    inherits2(CachingRegistryClient, RegistryClient);
    CachingRegistryClient.prototype._invalidatingRequest = function(uri, params, cb2) {
      var client = this;
      this._request.call(this, uri, params, function() {
        var args = arguments;
        var method = params.method;
        if (method !== "HEAD" && method !== "GET") {
          var invalidated = client._mapToCache(uri);
          log.verbose("request", "invalidating", invalidated, "on", method);
          return rimraf(invalidated, function() {
            cb2.apply(void 0, args);
          });
        }
        cb2.apply(void 0, args);
      });
    };
    function get2(uri, params, cb2) {
      assert(typeof uri === "string", "must pass registry URI to get");
      assert(params && typeof params === "object", "must pass params to get");
      assert(typeof cb2 === "function", "must pass callback to get");
      var parsed = url.parse(uri);
      assert(
        parsed.protocol === "http:" || parsed.protocol === "https:",
        "must have a URL that starts with http: or https:"
      );
      var cacheBase = cacheFile(npm.config.get("cache"))(uri);
      var cachePath = path.join(cacheBase, ".cache.json");
      if (uri.match(/\?write=true$/)) {
        log.verbose("get", "GET as part of write; not caching result");
        return get_.call(this, uri, cachePath, params, cb2);
      }
      var client = this;
      fs.stat(cachePath, function(er, stat) {
        if (!er) {
          fs.readFile(cachePath, function(er2, data) {
            try {
              data = JSON.parse(data);
            } catch (ex) {
              data = null;
            }
            params.stat = stat;
            params.data = data;
            get_.call(client, uri, cachePath, params, cb2);
          });
        } else {
          get_.call(client, uri, cachePath, params, cb2);
        }
      });
    }
    function get_(uri, cachePath, params, cb2) {
      var staleOk = params.staleOk === void 0 ? false : params.staleOk, timeout = params.timeout === void 0 ? -1 : params.timeout, data = params.data, stat = params.stat, etag, lastModified;
      timeout = Math.min(timeout, npm.config.get("cache-max") || 0);
      timeout = Math.max(timeout, npm.config.get("cache-min") || -Infinity);
      if (process.env.COMP_CWORD !== void 0 && process.env.COMP_LINE !== void 0 && process.env.COMP_POINT !== void 0) {
        timeout = Math.max(timeout, 6e4);
      }
      if (data) {
        if (data._etag)
          etag = data._etag;
        if (data._lastModified)
          lastModified = data._lastModified;
        if (stat && timeout && timeout > 0) {
          if ((Date.now() - stat.mtime.getTime()) / 1e3 < timeout) {
            log.verbose("get", uri, "not expired, no request");
            delete data._etag;
            delete data._lastModified;
            return cb2(null, data, JSON.stringify(data), { statusCode: 304 });
          }
          if (staleOk) {
            log.verbose("get", uri, "staleOk, background update");
            delete data._etag;
            delete data._lastModified;
            process.nextTick(
              cb2.bind(null, null, data, JSON.stringify(data), { statusCode: 304 })
            );
            cb2 = function() {
            };
          }
        }
      }
      var options = {
        etag,
        lastModified,
        follow: params.follow,
        auth: params.auth
      };
      this.request(uri, options, function(er, remoteData, raw, response) {
        if (er && cachePath && data && !data.error) {
          er = null;
          response = { statusCode: 304 };
        }
        if (response) {
          log.silly("get", "cb", [response.statusCode, response.headers]);
          if (response.statusCode === 304 && (etag || lastModified)) {
            remoteData = data;
            log.verbose(etag ? "etag" : "lastModified", uri + " from cache");
          }
        }
        data = remoteData;
        if (!data)
          er = er || new Error("failed to fetch from registry: " + uri);
        if (er)
          return cb2(er, data, raw, response);
        saveToCache(cachePath, data, saved);
        function saved() {
          delete data._etag;
          delete data._lastModified;
          cb2(er, data, raw, response);
        }
        function saveToCache(cachePath2, data2, saved2) {
          log.verbose("get", "saving", data2.name, "to", cachePath2);
          getCacheStat(function(er2, st) {
            mkdirp(path.dirname(cachePath2), function(er3, made) {
              if (er3)
                return saved2();
              writeFile(cachePath2, JSON.stringify(data2), function(er4) {
                if (er4)
                  return saved2();
                chownr(made || cachePath2, st.uid, st.gid, saved2);
              });
            });
          });
        }
      });
    }
    function adaptConfig(config) {
      return {
        proxy: {
          http: config.get("proxy"),
          https: config.get("https-proxy"),
          localAddress: config.get("local-address")
        },
        ssl: {
          certificate: config.get("cert"),
          key: config.get("key"),
          ca: config.get("ca"),
          strict: config.get("strict-ssl")
        },
        retry: {
          retries: config.get("fetch-retries"),
          factor: config.get("fetch-retry-factor"),
          minTimeout: config.get("fetch-retry-mintimeout"),
          maxTimeout: config.get("fetch-retry-maxtimeout")
        },
        userAgent: config.get("user-agent"),
        log,
        defaultTag: config.get("tag"),
        couchToken: config.get("_token"),
        maxSockets: config.get("maxsockets")
      };
    }
  }
});

// node_modules/npm/node_modules/char-spinner/spin.js
var require_spin = __commonJS({
  "node_modules/npm/node_modules/char-spinner/spin.js"(exports2, module2) {
    module2.exports = spinner;
    function spinner(opt) {
      opt = opt || {};
      var str = opt.stream || process.stderr;
      var tty = typeof opt.tty === "boolean" ? opt.tty : true;
      var string = opt.string || "/-\\|";
      var ms = typeof opt.interval === "number" ? opt.interval : 50;
      if (ms < 0)
        ms = 0;
      if (tty && !str.isTTY)
        return false;
      var CR = str.isTTY ? "\x1B[0G" : "\r";
      var CLEAR = str.isTTY ? "\x1B[2K" : "\r \r";
      var s = 0;
      var sprite = string.split("");
      var wrote = false;
      var delay = typeof opt.delay === "number" ? opt.delay : 2;
      var interval = setInterval(function() {
        if (--delay >= 0)
          return;
        s = ++s % sprite.length;
        var c = sprite[s];
        str.write(c + CR);
        wrote = true;
      }, ms);
      var unref = typeof opt.unref === "boolean" ? opt.unref : true;
      if (unref && typeof interval.unref === "function") {
        interval.unref();
      }
      var cleanup = typeof opt.cleanup === "boolean" ? opt.cleanup : true;
      if (cleanup) {
        process.on("exit", function() {
          if (wrote) {
            str.write(CLEAR);
          }
        });
      }
      module2.exports.clear = function() {
        str.write(CLEAR);
      };
      return interval;
    }
    module2.exports.clear = function() {
    };
  }
});

// browser-external:tty
var require_tty = __commonJS({
  "browser-external:tty"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tty" has been externalized for browser compatibility. Cannot access "tty.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/npm/node_modules/fs-write-stream-atomic/node_modules/iferr/index.js
var require_iferr = __commonJS({
  "node_modules/npm/node_modules/fs-write-stream-atomic/node_modules/iferr/index.js"(exports2, module2) {
    (function() {
      var exports3, iferr, printerr, throwerr, tiferr, __slice = [].slice;
      iferr = function(fail, succ) {
        return function() {
          var a, err;
          err = arguments[0], a = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (err != null) {
            return fail(err);
          } else {
            return typeof succ === "function" ? succ.apply(null, a) : void 0;
          }
        };
      };
      tiferr = function(fail, succ) {
        return iferr(fail, function() {
          var a, err;
          a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          try {
            return succ.apply(null, a);
          } catch (_error) {
            err = _error;
            return fail(err);
          }
        });
      };
      throwerr = iferr.bind(null, function(err) {
        throw err;
      });
      printerr = iferr(function(err) {
        return console.error(err.stack || err);
      });
      module2.exports = exports3 = iferr;
      exports3.iferr = iferr;
      exports3.tiferr = tiferr;
      exports3.throwerr = throwerr;
      exports3.printerr = printerr;
    }).call(exports2);
  }
});

// node_modules/npm/node_modules/fs-write-stream-atomic/index.js
var require_fs_write_stream_atomic = __commonJS({
  "node_modules/npm/node_modules/fs-write-stream-atomic/index.js"(exports2, module2) {
    var fs = require_graceful_fs();
    var Writable = require_readable().Writable;
    var util = require_util();
    var MurmurHash3 = require_imurmurhash();
    var iferr = require_iferr();
    function murmurhex() {
      var hash = MurmurHash3("");
      for (var ii = 0; ii < arguments.length; ++ii) {
        hash.hash(hash + arguments[ii]);
      }
      return hash.result();
    }
    var invocations = 0;
    function getTmpname(filename) {
      return filename + "." + murmurhex(__filename, process.pid, ++invocations);
    }
    var setImmediate2 = global.setImmediate || setTimeout;
    module2.exports = WriteStreamAtomic;
    util.inherits(WriteStreamAtomic, Writable);
    function WriteStreamAtomic(path, options) {
      if (!(this instanceof WriteStreamAtomic)) {
        return new WriteStreamAtomic(path, options);
      }
      Writable.call(this, options);
      this.__atomicTarget = path;
      this.__atomicTmp = getTmpname(path);
      this.__atomicChown = options && options.chown;
      this.__atomicClosed = false;
      this.__atomicStream = fs.WriteStream(this.__atomicTmp, options);
      this.__atomicStream.once("open", handleOpen(this));
      this.__atomicStream.once("close", handleClose(this));
      this.__atomicStream.once("error", handleError(this));
    }
    WriteStreamAtomic.prototype.emit = function(event) {
      if (event === "finish")
        return this.__atomicStream.end();
      return Writable.prototype.emit.apply(this, arguments);
    };
    WriteStreamAtomic.prototype._write = function(buffer, encoding, cb2) {
      var flushed = this.__atomicStream.write(buffer, encoding);
      if (flushed)
        return cb2();
      this.__atomicStream.once("drain", cb2);
    };
    function handleOpen(writeStream) {
      return function(fd) {
        writeStream.emit("open", fd);
      };
    }
    function handleClose(writeStream) {
      return function() {
        if (writeStream.__atomicClosed)
          return;
        writeStream.__atomicClosed = true;
        if (writeStream.__atomicChown) {
          var uid = writeStream.__atomicChown.uid;
          var gid = writeStream.__atomicChown.gid;
          return fs.chown(writeStream.__atomicTmp, uid, gid, iferr(cleanup, moveIntoPlace));
        } else {
          moveIntoPlace();
        }
      };
      function cleanup(err) {
        fs.unlink(writeStream.__atomicTmp, function() {
          writeStream.emit("error", err);
          writeStream.emit("close");
        });
      }
      function moveIntoPlace() {
        fs.rename(writeStream.__atomicTmp, writeStream.__atomicTarget, iferr(cleanup, end));
      }
      function end() {
        Writable.prototype.emit.call(writeStream, "finish");
        setImmediate2(function() {
          writeStream.emit("close");
        });
      }
    }
    function handleError(writeStream) {
      return function(er) {
        cleanupSync();
        writeStream.emit("error", er);
        writeStream.__atomicClosed = true;
        writeStream.emit("close");
      };
      function cleanupSync() {
        try {
          fs.unlinkSync(writeStream.__atomicTmp);
        } finally {
          return;
        }
      }
    }
  }
});

// node_modules/npm/node_modules/validate-npm-package-name/node_modules/builtins/builtins.json
var require_builtins = __commonJS({
  "node_modules/npm/node_modules/validate-npm-package-name/node_modules/builtins/builtins.json"(exports2, module2) {
    module2.exports = [
      "assert",
      "buffer",
      "child_process",
      "cluster",
      "constants",
      "crypto",
      "dns",
      "domain",
      "events",
      "fs",
      "http",
      "https",
      "module",
      "net",
      "os",
      "path",
      "punycode",
      "querystring",
      "repl",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "tty",
      "dgram",
      "url",
      "util",
      "vm",
      "zlib"
    ];
  }
});

// node_modules/npm/node_modules/validate-npm-package-name/index.js
var require_validate_npm_package_name = __commonJS({
  "node_modules/npm/node_modules/validate-npm-package-name/index.js"(exports2, module2) {
    var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$");
    var builtins = require_builtins();
    var blacklist = [
      "node_modules",
      "favicon.ico"
    ];
    var validate = module2.exports = function(name) {
      var warnings = [];
      var errors = [];
      if (name === null) {
        errors.push("name cannot be null");
        return done(warnings, errors);
      }
      if (name === void 0) {
        errors.push("name cannot be undefined");
        return done(warnings, errors);
      }
      if (typeof name !== "string") {
        errors.push("name must be a string");
        return done(warnings, errors);
      }
      if (!name.length) {
        errors.push("name length must be greater than zero");
      }
      if (name.match(/^\./)) {
        errors.push("name cannot start with a period");
      }
      if (name.match(/^_/)) {
        errors.push("name cannot start with an underscore");
      }
      if (name.trim() !== name) {
        errors.push("name cannot contain leading or trailing spaces");
      }
      blacklist.forEach(function(blacklistedName) {
        if (name.toLowerCase() === blacklistedName) {
          errors.push(blacklistedName + " is a blacklisted name");
        }
      });
      builtins.forEach(function(builtin) {
        if (name.toLowerCase() === builtin) {
          warnings.push(builtin + " is a core module name");
        }
      });
      if (name.length > 214) {
        warnings.push("name can no longer contain more than 214 characters");
      }
      if (name.toLowerCase() !== name) {
        warnings.push("name can no longer contain capital letters");
      }
      if (encodeURIComponent(name) !== name) {
        var nameMatch = name.match(scopedPackagePattern);
        if (nameMatch) {
          var user = nameMatch[1];
          var pkg = nameMatch[2];
          if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
            return done(warnings, errors);
          }
        }
        errors.push("name can only contain URL-friendly characters");
      }
      return done(warnings, errors);
    };
    validate.scopedPackagePattern = scopedPackagePattern;
    var done = function(warnings, errors) {
      var result2 = {
        validForNewPackages: errors.length === 0 && warnings.length === 0,
        validForOldPackages: errors.length === 0,
        warnings,
        errors
      };
      if (!result2.warnings.length)
        delete result2.warnings;
      if (!result2.errors.length)
        delete result2.errors;
      return result2;
    };
  }
});

// node_modules/npm/lib/utils/error-handler.js
var require_error_handler = __commonJS({
  "node_modules/npm/lib/utils/error-handler.js"(exports2, module2) {
    module2.exports = errorHandler;
    var cbCalled = false;
    var log = require_log();
    var npm = require_npm();
    var rm = require_rimraf();
    var itWorked = false;
    var path = require_path();
    var wroteLogFile = false;
    var exitCode = 0;
    var rollbacks = npm.rollbacks;
    var chain2 = require_slide().chain;
    var writeStreamAtomic = require_fs_write_stream_atomic();
    var nameValidator = require_validate_npm_package_name();
    process.on("exit", function(code) {
      if (!npm.config || !npm.config.loaded)
        return;
      if (code)
        itWorked = false;
      if (itWorked)
        log.info("ok");
      else {
        if (!cbCalled) {
          log.error("", "cb() never called!");
        }
        if (wroteLogFile) {
          if (log.levels[log.level] <= log.levels.error)
            console.error("");
          log.error(
            "",
            [
              "Please include the following file with any support request:",
              "    " + path.resolve("npm-debug.log")
            ].join("\n")
          );
          wroteLogFile = false;
        }
        if (code) {
          log.error("code", code);
        }
      }
      var doExit = npm.config.get("_exit");
      if (doExit) {
        if (exitCode === 0 && !itWorked) {
          exitCode = 1;
        }
        if (exitCode !== 0)
          process.exit(exitCode);
      } else {
        itWorked = false;
      }
    });
    function exit(code, noLog) {
      exitCode = exitCode || process.exitCode || code;
      var doExit = npm.config ? npm.config.get("_exit") : true;
      log.verbose("exit", [code, doExit]);
      if (log.level === "silent")
        noLog = true;
      if (rollbacks.length) {
        chain2(rollbacks.map(function(f2) {
          return function(cb2) {
            npm.commands.unbuild([f2], true, cb2);
          };
        }), function(er) {
          if (er) {
            log.error("error rolling back", er);
            if (!code)
              errorHandler(er);
            else if (noLog)
              rm("npm-debug.log", reallyExit.bind(null, er));
            else
              writeLogFile(reallyExit.bind(this, er));
          } else {
            if (!noLog && code)
              writeLogFile(reallyExit);
            else
              rm("npm-debug.log", reallyExit);
          }
        });
        rollbacks.length = 0;
      } else if (code && !noLog)
        writeLogFile(reallyExit);
      else
        rm("npm-debug.log", reallyExit);
      function reallyExit(er) {
        if (er && !code)
          code = typeof er.errno === "number" ? er.errno : 1;
        log.record.length = 0;
        itWorked = !code;
        if (!doExit)
          process.emit("exit", code);
        npm.spinner.stop();
      }
    }
    function errorHandler(er) {
      if (!npm.config || !npm.config.loaded) {
        er = er || new Error("Exit prior to config file resolving.");
        console.error(er.stack || er.message);
      }
      if (cbCalled) {
        er = er || new Error("Callback called more than once.");
      }
      cbCalled = true;
      if (!er)
        return exit(0);
      if (typeof er === "string") {
        log.error("", er);
        return exit(1, true);
      } else if (!(er instanceof Error)) {
        log.error("weird error", er);
        return exit(1, true);
      }
      var m = er.code || er.message.match(/^(?:Error: )?(E[A-Z]+)/);
      if (m && !er.code)
        er.code = m;
      [
        "type",
        "fstream_path",
        "fstream_unc_path",
        "fstream_type",
        "fstream_class",
        "fstream_finish_call",
        "fstream_linkpath",
        "stack",
        "fstream_stack",
        "statusCode",
        "pkgid"
      ].forEach(function(k) {
        var v = er[k];
        if (!v)
          return;
        if (k === "fstream_stack")
          v = v.join("\n");
        log.verbose(k, v);
      });
      log.verbose("cwd", process.cwd());
      var os = require_os();
      log.error("", os.type() + " " + os.release());
      log.error("argv", process.argv.map(JSON.stringify).join(" "));
      log.error("node", process.version);
      log.error("npm ", "v" + npm.version);
      [
        "file",
        "path",
        "code",
        "errno",
        "syscall"
      ].forEach(function(k) {
        var v = er[k];
        if (v)
          log.error(k, v);
      });
      if (log.levels[log.level] <= log.levels.error)
        console.error("");
      switch (er.code) {
        case "ECONNREFUSED":
          log.error("", er);
          log.error("", [
            "\nIf you are behind a proxy, please make sure that the",
            "'proxy' config is set properly.  See: 'npm help config'"
          ].join("\n"));
          break;
        case "EACCES":
        case "EPERM":
          log.error("", er);
          log.error("", [
            "\nPlease try running this command again as root/Administrator."
          ].join("\n"));
          break;
        case "ELIFECYCLE":
          log.error("", er.message);
          log.error("", [
            "",
            "Failed at the " + er.pkgid + " " + er.stage + " script '" + er.script + "'.",
            "This is most likely a problem with the " + er.pkgname + " package,",
            "not with npm itself.",
            "Tell the author that this fails on your system:",
            "    " + er.script,
            "You can get information on how to open an issue for this project with:",
            "    npm bugs " + er.pkgname,
            "Or if that isn't available, you can get their info via:",
            ,
            "    npm owner ls " + er.pkgname,
            "There is likely additional logging output above."
          ].join("\n"));
          break;
        case "ENOGIT":
          log.error("", er.message);
          log.error("", [
            "",
            "Failed using git.",
            "This is most likely not a problem with npm itself.",
            "Please check if you have git installed and in your PATH."
          ].join("\n"));
          break;
        case "EJSONPARSE":
          log.error("", er.message);
          log.error("", "File: " + er.file);
          log.error("", [
            "Failed to parse package.json data.",
            "package.json must be actual JSON, not just JavaScript.",
            "",
            "This is not a bug in npm.",
            "Tell the package author to fix their package.json file."
          ].join("\n"), "JSON.parse");
          break;
        case "E404":
          var msg = [er.message];
          if (er.pkgid && er.pkgid !== "-") {
            msg.push("", "'" + er.pkgid + "' is not in the npm registry.");
            var valResult = nameValidator(er.pkgid);
            if (valResult.validForNewPackages) {
              msg.push("You should bug the author to publish it (or use the name yourself!)");
            } else {
              msg.push("Your package name is not valid, because", "");
              var errorsArray = (valResult.errors || []).concat(valResult.warnings || []);
              errorsArray.forEach(function(item, idx) {
                msg.push(" " + (idx + 1) + ". " + item);
              });
            }
            if (er.parent) {
              msg.push("It was specified as a dependency of '" + er.parent + "'");
            }
            msg.push(
              "\nNote that you can also install from a",
              "tarball, folder, http url, or git url."
            );
          }
          msg[0] = msg[0].replace(/^404\s+/, "");
          log.error("404", msg.join("\n"));
          break;
        case "EPUBLISHCONFLICT":
          log.error("publish fail", [
            "Cannot publish over existing version.",
            "Update the 'version' field in package.json and try again.",
            "",
            "To automatically increment version numbers, see:",
            "    npm help version"
          ].join("\n"));
          break;
        case "EISGIT":
          log.error("git", [
            er.message,
            "    " + er.path,
            "Refusing to remove it. Update manually,",
            "or move it out of the way first."
          ].join("\n"));
          break;
        case "ECYCLE":
          log.error("cycle", [
            er.message,
            "While installing: " + er.pkgid,
            "Found a pathological dependency case that npm cannot solve.",
            "Please report this to the package author."
          ].join("\n"));
          break;
        case "EBADPLATFORM":
          log.error("notsup", [
            er.message,
            "Not compatible with your operating system or architecture: " + er.pkgid,
            "Valid OS:    " + er.os.join(","),
            "Valid Arch:  " + er.cpu.join(","),
            "Actual OS:   " + process.platform,
            "Actual Arch: " + process.arch
          ].join("\n"));
          break;
        case "EEXIST":
          log.error([
            er.message,
            "File exists: " + er.path,
            "Move it away, and try again."
          ].join("\n"));
          break;
        case "ENEEDAUTH":
          log.error("need auth", [
            er.message,
            "You need to authorize this machine using `npm adduser`"
          ].join("\n"));
          break;
        case "EPEERINVALID":
          var peerErrors = Object.keys(er.peersDepending).map(function(peer) {
            return "Peer " + peer + " wants " + er.packageName + "@" + er.peersDepending[peer];
          });
          log.error("peerinvalid", [er.message].concat(peerErrors).join("\n"));
          break;
        case "ECONNRESET":
        case "ENOTFOUND":
        case "ETIMEDOUT":
        case "EAI_FAIL":
          log.error("network", [
            er.message,
            "This is most likely not a problem with npm itself",
            "and is related to network connectivity.",
            "In most cases you are behind a proxy or have bad network settings.",
            "\nIf you are behind a proxy, please make sure that the",
            "'proxy' config is set properly.  See: 'npm help config'"
          ].join("\n"));
          break;
        case "ENOPACKAGEJSON":
          log.error("package.json", [
            er.message,
            "This is most likely not a problem with npm itself.",
            "npm can't find a package.json file in your current directory."
          ].join("\n"));
          break;
        case "ETARGET":
          var msg = [
            er.message,
            "This is most likely not a problem with npm itself.",
            "In most cases you or one of your dependencies are requesting",
            "a package version that doesn't exist."
          ];
          if (er.parent) {
            msg.push("\nIt was specified as a dependency of '" + er.parent + "'\n");
          }
          log.error("notarget", msg.join("\n"));
          break;
        case "ENOTSUP":
          if (er.required) {
            log.error("notsup", [
              er.message,
              "Not compatible with your version of node/npm: " + er.pkgid,
              "Required: " + JSON.stringify(er.required),
              "Actual:   " + JSON.stringify({
                npm: npm.version,
                node: npm.config.get("node-version")
              })
            ].join("\n"));
            break;
          }
        case "ENOSPC":
          log.error("nospc", [
            er.message,
            "This is most likely not a problem with npm itself",
            "and is related to insufficient space on your system."
          ].join("\n"));
          break;
        case "EROFS":
          log.error("rofs", [
            er.message,
            "This is most likely not a problem with npm itself",
            "and is related to the file system being read-only.",
            "\nOften virtualized file systems, or other file systems",
            "that don't support symlinks, give this error."
          ].join("\n"));
          break;
        case "ENOENT":
          log.error("enoent", [
            er.message,
            "This is most likely not a problem with npm itself",
            "and is related to npm not being able to find a file.",
            er.file ? "\nCheck if the file '" + er.file + "' is present." : ""
          ].join("\n"));
          break;
        case "EISDIR":
          log.error("eisdir", [
            er.message,
            "This is most likely not a problem with npm itself",
            "and is related to npm not being able to find a package.json in",
            "a package you are trying to install."
          ].join("\n"));
          break;
        default:
          log.error("", er.message || er);
          log.error("", [
            "",
            "If you need help, you may report this error at:",
            "    <https://github.com/npm/npm/issues>"
          ].join("\n"));
          break;
      }
      exit(typeof er.errno === "number" ? er.errno : 1);
    }
    var writingLogFile = false;
    function writeLogFile(cb2) {
      if (writingLogFile)
        return cb2();
      writingLogFile = true;
      wroteLogFile = true;
      var fstr = writeStreamAtomic("npm-debug.log"), os = require_os(), out = "";
      log.record.forEach(function(m) {
        var pref = [m.id, m.level];
        if (m.prefix)
          pref.push(m.prefix);
        pref = pref.join(" ");
        m.message.trim().split(/\r?\n/).map(function(line) {
          return (pref + " " + line).trim();
        }).forEach(function(line) {
          out += line + os.EOL;
        });
      });
      fstr.end(out);
      fstr.on("close", cb2);
    }
  }
});

// node_modules/npm/bin/npm-cli.js
var require_npm_cli = __commonJS({
  "node_modules/npm/bin/npm-cli.js"() {
    (function() {
      if (typeof WScript !== "undefined") {
        WScript.echo("npm does not work when run\nwith the Windows Scripting Host\n\n'cd' to a different directory,\nor type 'npm.cmd <args>',\nor type 'node npm <args>'.");
        WScript.quit(1);
        return;
      }
      process.title = "npm";
      var log = require_log();
      log.pause();
      log.info("it worked if it ends with", "ok");
      var path = require_path(), npm = require_npm(), npmconf = require_core(), errorHandler = require_error_handler(), configDefs = npmconf.defs, shorthands = configDefs.shorthands, types = configDefs.types, nopt = require_nopt();
      if (path.basename(process.argv[1]).slice(-1) === "g") {
        process.argv.splice(1, 1, "npm", "-g");
      }
      log.verbose("cli", process.argv);
      var conf = nopt(types, shorthands);
      npm.argv = conf.argv.remain;
      if (npm.deref(npm.argv[0]))
        npm.command = npm.argv.shift();
      else
        conf.usage = true;
      if (conf.version) {
        console.log(npm.version);
        return;
      }
      if (conf.versions) {
        npm.command = "version";
        conf.usage = false;
        npm.argv = [];
      }
      log.info("using", "npm@%s", npm.version);
      log.info("using", "node@%s", process.version);
      process.on("uncaughtException", errorHandler);
      if (conf.usage && npm.command !== "help") {
        npm.argv.unshift(npm.command);
        npm.command = "help";
      }
      conf._exit = true;
      npm.load(conf, function(er) {
        if (er)
          return errorHandler(er);
        npm.commands[npm.command](npm.argv, errorHandler);
      });
    })();
  }
});

// node_modules/npm/lib/npm.js
var require_npm = __commonJS({
  "node_modules/npm/lib/npm.js"(exports2, module2) {
    (function() {
      if (typeof WScript !== "undefined") {
        WScript.echo("npm does not work when run\nwith the Windows Scripting Host\n\n'cd' to a different directory,\nor type 'npm.cmd <args>',\nor type 'node npm <args>'.");
        WScript.quit(1);
        return;
      }
      var EventEmitter = require_events().EventEmitter, npm = module2.exports = new EventEmitter(), npmconf = require_core(), log = require_log(), gfs = require_graceful_fs(), fs = gfs.gracefulify(require_fs()), path = require_path(), abbrev = require_abbrev(), which = require_which(), CachingRegClient = require_caching_client(), charSpin = require_spin();
      npm.config = {
        loaded: false,
        get: function() {
          throw new Error("npm.load() required");
        },
        set: function() {
          throw new Error("npm.load() required");
        }
      };
      npm.commands = {};
      npm.rollbacks = [];
      try {
        var j = JSON.parse(fs.readFileSync(
          path.join(__dirname, "../package.json")
        ) + "");
        npm.version = j.version;
      } catch (ex) {
        try {
          log.info("error reading version", ex);
        } catch (er) {
        }
        npm.version = ex;
      }
      var commandCache = {}, aliases = {
        "rm": "uninstall",
        "r": "uninstall",
        "un": "uninstall",
        "unlink": "uninstall",
        "remove": "uninstall",
        "rb": "rebuild",
        "list": "ls",
        "la": "ls",
        "ll": "ls",
        "ln": "link",
        "i": "install",
        "isntall": "install",
        "up": "update",
        "upgrade": "update",
        "c": "config",
        "dist-tags": "dist-tag",
        "info": "view",
        "show": "view",
        "find": "search",
        "s": "search",
        "se": "search",
        "author": "owner",
        "home": "docs",
        "issues": "bugs",
        "unstar": "star",
        "apihelp": "help",
        "login": "adduser",
        "add-user": "adduser",
        "tst": "test",
        "t": "test",
        "find-dupes": "dedupe",
        "ddp": "dedupe",
        "v": "view",
        "verison": "version"
      }, aliasNames = Object.keys(aliases), cmdList = [
        "install",
        "uninstall",
        "cache",
        "config",
        "set",
        "get",
        "update",
        "outdated",
        "prune",
        "pack",
        "dedupe",
        "rebuild",
        "link",
        "publish",
        "star",
        "stars",
        "tag",
        "adduser",
        "logout",
        "unpublish",
        "owner",
        "access",
        "team",
        "deprecate",
        "shrinkwrap",
        "help",
        "help-search",
        "ls",
        "search",
        "view",
        "init",
        "version",
        "edit",
        "explore",
        "docs",
        "repo",
        "bugs",
        "faq",
        "root",
        "prefix",
        "bin",
        "whoami",
        "dist-tag",
        "ping",
        "test",
        "stop",
        "start",
        "restart",
        "run-script",
        "completion"
      ], plumbing = [
        "build",
        "unbuild",
        "xmas",
        "substack",
        "visnup"
      ], littleGuys = ["isntall", "verison"], fullList = cmdList.concat(aliasNames).filter(function(c) {
        return plumbing.indexOf(c) === -1;
      }), abbrevs = abbrev(fullList);
      fullList = npm.fullList = fullList.filter(function(c) {
        return littleGuys.indexOf(c) === -1;
      });
      npm.spinner = {
        int: null,
        started: false,
        start: function() {
          if (npm.spinner.int)
            return;
          var c = npm.config.get("spin");
          if (!c)
            return;
          var stream = npm.config.get("logstream");
          var opt = { tty: c !== "always", stream };
          opt.cleanup = !npm.spinner.started;
          npm.spinner.int = charSpin(opt);
          npm.spinner.started = true;
        },
        stop: function() {
          clearInterval(npm.spinner.int);
          npm.spinner.int = null;
        }
      };
      Object.keys(abbrevs).concat(plumbing).forEach(function addCommand(c) {
        Object.defineProperty(npm.commands, c, { get: function() {
          if (!loaded)
            throw new Error(
              "Call npm.load(config, cb) before using this command.\nSee the README.md or cli.js for example usage."
            );
          var a = npm.deref(c);
          if (c === "la" || c === "ll") {
            npm.config.set("long", true);
          }
          npm.command = c;
          if (commandCache[a])
            return commandCache[a];
          var cmd = __require(__dirname + "/" + a + ".js");
          commandCache[a] = function() {
            var args = Array.prototype.slice.call(arguments, 0);
            if (typeof args[args.length - 1] !== "function") {
              args.push(defaultCb);
            }
            if (args.length === 1)
              args.unshift([]);
            npm.registry.version = npm.version;
            if (!npm.registry.refer) {
              npm.registry.refer = [a].concat(args[0]).map(function(arg) {
                if (arg && arg.match && arg.match(/\/|\\/)) {
                  return "[REDACTED]";
                } else {
                  return arg;
                }
              }).filter(function(arg) {
                return arg && arg.match;
              }).join(" ");
            }
            cmd.apply(npm, args);
          };
          Object.keys(cmd).forEach(function(k) {
            commandCache[a][k] = cmd[k];
          });
          return commandCache[a];
        }, enumerable: fullList.indexOf(c) !== -1, configurable: true });
        if (c.match(/\-([a-z])/)) {
          addCommand(c.replace(/\-([a-z])/g, function(a, b) {
            return b.toUpperCase();
          }));
        }
      });
      function defaultCb(er, data) {
        if (er)
          console.error(er.stack || er.message);
        else
          console.log(data);
      }
      npm.deref = function(c) {
        if (!c)
          return "";
        if (c.match(/[A-Z]/))
          c = c.replace(/([A-Z])/g, function(m) {
            return "-" + m.toLowerCase();
          });
        if (plumbing.indexOf(c) !== -1)
          return c;
        var a = abbrevs[c];
        if (aliases[a])
          a = aliases[a];
        return a;
      };
      var loaded = false, loading = false, loadErr = null, loadListeners = [];
      function loadCb(er) {
        loadListeners.forEach(function(cb2) {
          process.nextTick(cb2.bind(npm, er, npm));
        });
        loadListeners.length = 0;
      }
      npm.load = function(cli, cb_) {
        if (!cb_ && typeof cli === "function")
          cb_ = cli, cli = {};
        if (!cb_)
          cb_ = function() {
          };
        if (!cli)
          cli = {};
        loadListeners.push(cb_);
        if (loaded || loadErr)
          return cb2(loadErr);
        if (loading)
          return;
        loading = true;
        var onload = true;
        function cb2(er) {
          if (loadErr)
            return;
          loadErr = er;
          if (er)
            return cb_(er);
          if (npm.config.get("force")) {
            log.warn("using --force", "I sure hope you know what you are doing.");
          }
          npm.config.loaded = true;
          loaded = true;
          loadCb(loadErr = er);
          onload = onload && npm.config.get("onload-script");
          if (onload) {
            try {
              __require(onload);
            } catch (err) {
              log.warn("onload-script", "failed to require onload script", onload);
              log.warn("onload-script", err);
            }
            onload = false;
          }
        }
        log.pause();
        load(npm, cli, cb2);
      };
      function load(npm2, cli, cb2) {
        which(process.argv[0], function(er, node) {
          if (!er && node.toUpperCase() !== process.execPath.toUpperCase()) {
            log.verbose("node symlink", node);
            process.execPath = node;
            process.installPrefix = path.resolve(node, "..", "..");
          }
          var builtin = path.resolve(__dirname, "..", "npmrc");
          npmconf.load(cli, builtin, function(er2, config) {
            if (er2 === config)
              er2 = null;
            npm2.config = config;
            if (er2)
              return cb2(er2);
            if (!config.get("global") && config.sources.project && config.sources.project.type !== "ini") {
              log.verbose(
                "config",
                "Skipping project config: %s. (matches userconfig)",
                config.localPrefix + "/.npmrc"
              );
            }
            var ua = config.get("user-agent") || "";
            ua = ua.replace(/\{node-version\}/gi, process.version);
            ua = ua.replace(/\{npm-version\}/gi, npm2.version);
            ua = ua.replace(/\{platform\}/gi, process.platform);
            ua = ua.replace(/\{arch\}/gi, process.arch);
            config.set("user-agent", ua);
            var color = config.get("color");
            log.level = config.get("loglevel");
            log.heading = config.get("heading") || "npm";
            log.stream = config.get("logstream");
            switch (color) {
              case "always":
                log.enableColor();
                npm2.color = true;
                break;
              case false:
                log.disableColor();
                npm2.color = false;
                break;
              default:
                var tty = require_tty();
                if (process.stdout.isTTY)
                  npm2.color = true;
                else if (!tty.isatty)
                  npm2.color = true;
                else if (tty.isatty(1))
                  npm2.color = true;
                else
                  npm2.color = false;
                break;
            }
            log.resume();
            npm2.registry = new CachingRegClient(npm2.config);
            var umask = npm2.config.get("umask");
            npm2.modes = {
              exec: 511 & ~umask,
              file: 438 & ~umask,
              umask
            };
            var gp = Object.getOwnPropertyDescriptor(config, "globalPrefix");
            Object.defineProperty(npm2, "globalPrefix", gp);
            var lp = Object.getOwnPropertyDescriptor(config, "localPrefix");
            Object.defineProperty(npm2, "localPrefix", lp);
            return cb2(null, npm2);
          });
        });
      }
      Object.defineProperty(
        npm,
        "prefix",
        {
          get: function() {
            return npm.config.get("global") ? npm.globalPrefix : npm.localPrefix;
          },
          set: function(r) {
            var k = npm.config.get("global") ? "globalPrefix" : "localPrefix";
            return npm[k] = r;
          },
          enumerable: true
        }
      );
      Object.defineProperty(
        npm,
        "bin",
        {
          get: function() {
            if (npm.config.get("global"))
              return npm.globalBin;
            return path.resolve(npm.root, ".bin");
          },
          enumerable: true
        }
      );
      Object.defineProperty(
        npm,
        "globalBin",
        {
          get: function() {
            var b = npm.globalPrefix;
            if (process.platform !== "win32")
              b = path.resolve(b, "bin");
            return b;
          }
        }
      );
      Object.defineProperty(
        npm,
        "dir",
        {
          get: function() {
            if (npm.config.get("global"))
              return npm.globalDir;
            return path.resolve(npm.prefix, "node_modules");
          },
          enumerable: true
        }
      );
      Object.defineProperty(
        npm,
        "globalDir",
        {
          get: function() {
            return process.platform !== "win32" ? path.resolve(npm.globalPrefix, "lib", "node_modules") : path.resolve(npm.globalPrefix, "node_modules");
          },
          enumerable: true
        }
      );
      Object.defineProperty(
        npm,
        "root",
        { get: function() {
          return npm.dir;
        } }
      );
      Object.defineProperty(
        npm,
        "cache",
        {
          get: function() {
            return npm.config.get("cache");
          },
          set: function(r) {
            return npm.config.set("cache", r);
          },
          enumerable: true
        }
      );
      var tmpFolder;
      var rand = require_crypto().randomBytes(4).toString("hex");
      Object.defineProperty(
        npm,
        "tmp",
        {
          get: function() {
            if (!tmpFolder)
              tmpFolder = "npm-" + process.pid + "-" + rand;
            return path.resolve(npm.config.get("tmp"), tmpFolder);
          },
          enumerable: true
        }
      );
      Object.getOwnPropertyNames(npm.commands).forEach(function(n) {
        if (npm.hasOwnProperty(n) || n === "config")
          return;
        Object.defineProperty(npm, n, { get: function() {
          return function() {
            var args = Array.prototype.slice.call(arguments, 0), cb2 = defaultCb;
            if (args.length === 1 && Array.isArray(args[0])) {
              args = args[0];
            }
            if (typeof args[args.length - 1] === "function") {
              cb2 = args.pop();
            }
            npm.commands[n](args, cb2);
          };
        }, enumerable: false, configurable: true });
      });
      if (__require.main === module2) {
        require_npm_cli();
      }
    })();
  }
});

// node_modules/pkghub/dist/npm.js
var require_npm2 = __commonJS({
  "node_modules/pkghub/dist/npm.js"(exports2) {
    "use strict";
    var _interopRequireWildcard = function(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.load = load;
    exports2.ls = ls;
    exports2.install = install;
    var _npm = require_npm();
    var _npm2 = _interopRequireWildcard(_npm);
    var _import = (init_index_all(), __toCommonJS(index_all_exports));
    var _import2 = _interopRequireWildcard(_import);
    var _Promise = require_bluebird();
    var _Promise2 = _interopRequireWildcard(_Promise);
    var config = {
      loglevel: "silent",
      parseable: true
    };
    function load() {
      return new _Promise2["default"](function(res, rej) {
        _npm2["default"].load(config, function(err, n) {
          if (err)
            return rej(err);
          return res(n);
        });
      });
    }
    function ls() {
      return load().then(function(npmInstance) {
        return new _Promise2["default"](function(res, rej) {
          npmInstance.commands.ls([], true, function(err, modules) {
            if (err)
              return rej(err);
            return res(modules);
          });
        });
      });
    }
    function install(modules, dir) {
      return load().then(function(n) {
        return new _Promise2["default"](function(res, rej) {
          if (!_import2["default"].isArray(modules))
            return rej(new Error("Modules name must be array"));
          var params = dir ? [dir, modules, callback] : [modules, callback];
          return n.commands.install.apply(n, params);
          function callback(err, result2) {
            if (err) {
              return rej(err);
            }
            return res(result2);
          }
        });
      });
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map2 = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match2 = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range2(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range2;
    function range2(a, b, str) {
      var begs, beg, left, right, result2;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result2) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result2 = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result2 = [left, right];
        }
      }
      return result2;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion2 = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map2();
    var balanced = require_balanced_match2();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/pkghub/node_modules/minimatch/minimatch.js
var require_minimatch2 = __commonJS({
  "node_modules/pkghub/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = { sep: "/" };
    try {
      path = require_path();
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion2();
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter2;
    function filter2(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate2 = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l2 = pattern.length; i < l2 && pattern.charAt(i) === "!"; i++) {
        negate2 = !negate2;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate2;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new Error("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var plType;
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            plType = stateChar;
            patternListStack.push({
              type: plType,
              start: i - 1,
              reStart: re.length
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            re += ")";
            var pl = patternListStack.pop();
            plType = pl.type;
            switch (plType) {
              case "!":
                negativeLists.push(pl);
                re += ")[^/]*?)";
                pl.reEnd = re.length;
                break;
              case "?":
              case "+":
              case "*":
                re += plType;
                break;
              case "@":
                break;
            }
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + 3);
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function(_3, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      var regExp = new RegExp("^" + re + "$", flags);
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f2) {
        return mm.match(f2);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f2, partial2) {
      this.debug("match", f2, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f2 === "";
      if (f2 === "/" && partial2)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f2 = f2.split(path.sep).join("/");
      }
      f2 = f2.split(slashSplit);
      this.debug(this.pattern, "split", f2);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f2.length - 1; i >= 0; i--) {
        filename = f2[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f2;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial2);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial2) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f2 = file[fi];
        this.debug(pattern, p, f2);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f2]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial2)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial2) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f2.toLowerCase() === p.toLowerCase();
          } else {
            hit = f2 === p;
          }
          this.debug("string match", p, f2, hit);
        } else {
          hit = f2.match(p);
          this.debug("pattern match", p, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial2;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser2 = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor2, superCtor) {
        if (superCtor) {
          ctor2.super_ = superCtor;
          ctor2.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor2,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor2, superCtor) {
        if (superCtor) {
          ctor2.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor2.prototype = new TempCtor();
          ctor2.prototype.constructor = ctor2;
        }
      };
    }
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute2 = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result2 = splitDeviceRe.exec(path);
      var device = result2[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result2[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/pkghub/node_modules/glob/common.js
var require_common2 = __commonJS({
  "node_modules/pkghub/node_modules/glob/common.js"(exports2) {
    exports2.alphasort = alphasort;
    exports2.alphasorti = alphasorti;
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj2, field) {
      return Object.prototype.hasOwnProperty.call(obj2, field);
    }
    var path = require_path();
    var minimatch = require_minimatch2();
    var isAbsolute = require_path_is_absolute2();
    var Minimatch = minimatch.Minimatch;
    function alphasorti(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    }
    function alphasort(a, b) {
      return a.localeCompare(b);
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern);
      }
      return {
        matcher: new Minimatch(pattern),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = options.cwd;
        self2.changedCwd = path.resolve(options.cwd) !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = options.nonegate === false ? false : true;
      options.nocomment = options.nocomment === false ? false : true;
      deprecationWarning(options);
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    exports2.deprecationWarned;
    function deprecationWarning(options) {
      if (!options.nonegate || !options.nocomment) {
        if (process.noDeprecation !== true && !exports2.deprecationWarned) {
          var msg = "glob WARNING: comments and negation will be disabled in v6";
          if (process.throwDeprecation)
            throw new Error(msg);
          else if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
          exports2.deprecationWarned = true;
        }
      }
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l2 = self2.matches.length; i < l2; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(self2.nocase ? alphasorti : alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            return !/\/$/.test(e);
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f2) {
      var abs = f2;
      if (f2.charAt(0) === "/") {
        abs = path.join(self2.root, f2);
      } else if (isAbsolute(f2) || f2 === "") {
        abs = f2;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f2);
      } else {
        abs = path.resolve(f2);
      }
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/pkghub/node_modules/glob/sync.js
var require_sync2 = __commonJS({
  "node_modules/pkghub/node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs = require_fs();
    var minimatch = require_minimatch2();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob2().Glob;
    var util = require_util();
    var path = require_path();
    var assert = require_assert();
    var isAbsolute = require_path_is_absolute2();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = fs.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate2 = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate2 && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this.matches[index][e] = true;
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[this._makeAbs(e)];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = fs.lstatSync(abs);
      } catch (er) {
        return null;
      }
      var isSym = lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f2, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          this.cache[this._makeAbs(f2)] = "FILE";
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this.matches[index][prefix] = true;
    };
    GlobSync.prototype._stat = function(f2) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = fs.lstatSync(abs);
        } catch (er) {
          return false;
        }
        if (lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c !== "DIR")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f2) {
      return common.makeAbs(this, f2);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy2 = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb2) {
      if (fn && cb2)
        return wrappy(fn)(cb2);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret2 = fn.apply(this, args);
        var cb3 = args[args.length - 1];
        if (typeof ret2 === "function" && ret2 !== cb3) {
          Object.keys(cb3).forEach(function(k) {
            ret2[k] = cb3[k];
          });
        }
        return ret2;
      }
    }
  }
});

// node_modules/once/once.js
var require_once2 = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy2();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f2 = function() {
        if (f2.called)
          return f2.value;
        f2.called = true;
        return f2.value = fn.apply(this, arguments);
      };
      f2.called = false;
      return f2;
    }
    function onceStrict(fn) {
      var f2 = function() {
        if (f2.called)
          throw new Error(f2.onceError);
        f2.called = true;
        return f2.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f2.onceError = name + " shouldn't be called more than once";
      f2.called = false;
      return f2;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight2 = __commonJS({
  "node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy2();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once2();
    module2.exports = wrappy(inflight);
    function inflight(key, cb2) {
      if (reqs[key]) {
        reqs[key].push(cb2);
        return null;
      } else {
        reqs[key] = [cb2];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice2(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice2(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/pkghub/node_modules/glob/glob.js
var require_glob2 = __commonJS({
  "node_modules/pkghub/node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var fs = require_fs();
    var minimatch = require_minimatch2();
    var Minimatch = minimatch.Minimatch;
    var inherits2 = require_inherits_browser2();
    var EE = require_events().EventEmitter;
    var path = require_path();
    var assert = require_assert();
    var isAbsolute = require_path_is_absolute2();
    var globSync = require_sync2();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight2();
    var util = require_util();
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once2();
    function glob(pattern, options, cb2) {
      if (typeof options === "function")
        cb2 = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb2)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb2);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    glob.hasMagic = function(pattern, options_) {
      var options = util._extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits2(Glob, EE);
    function Glob(pattern, options, cb2) {
      if (typeof options === "function") {
        cb2 = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb2)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb2);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb2 === "function") {
        cb2 = once(cb2);
        this.on("error", cb2);
        this.on("end", function(matches) {
          cb2(null, matches);
        });
      }
      var self2 = this;
      var n = this.minimatch.set.length;
      this._processing = 0;
      this.matches = new Array(n);
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      function done() {
        --self2._processing;
        if (self2._processing <= 0)
          self2._finish();
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb2) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb2();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb2();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        fs.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb2();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f2) {
      return common.makeAbs(this, f2);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq2 = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq2.length; i++) {
            var e = eq2[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb2) {
      assert(this instanceof Glob);
      assert(typeof cb2 === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb2]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb2);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb2();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb2);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb2);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb2) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb2);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb2) {
      if (!entries)
        return cb2();
      var pn = remain[0];
      var negate2 = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate2 && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb2();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb2();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb2);
      }
      cb2();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (this.matches[index][e])
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = this._makeAbs(e);
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      if (this.mark)
        e = this._mark(e);
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb2) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb2);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er)
          return cb2();
        var isSym = lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb2();
        } else
          self2._readdir(abs, false, cb2);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb2) {
      if (this.aborted)
        return;
      cb2 = inflight("readdir\0" + abs + "\0" + inGlobStar, cb2);
      if (!cb2)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb2);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb2();
        if (Array.isArray(c))
          return cb2(null, c);
      }
      var self2 = this;
      fs.readdir(abs, readdirCb(this, abs, cb2));
    };
    function readdirCb(self2, abs, cb2) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb2);
        else
          self2._readdirEntries(abs, entries, cb2);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb2) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb2(null, entries);
    };
    Glob.prototype._readdirError = function(f2, er, cb2) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          this.cache[this._makeAbs(f2)] = "FILE";
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb2();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb2) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb2);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb2) {
      if (!entries)
        return cb2();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb2);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb2();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb2);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb2);
      }
      cb2();
    };
    Glob.prototype._processSimple = function(prefix, index, cb2) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb2);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb2) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb2();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb2();
    };
    Glob.prototype._stat = function(f2, cb2) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return cb2();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb2(null, c);
        if (needDir && c === "FILE")
          return cb2();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb2(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb2();
          else
            return cb2(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f2, abs, null, lstat, cb2);
            else
              self2._stat2(f2, abs, er2, stat2, cb2);
          });
        } else {
          self2._stat2(f2, abs, er, lstat, cb2);
        }
      }
    };
    Glob.prototype._stat2 = function(f2, abs, er, stat, cb2) {
      if (er) {
        this.statCache[abs] = false;
        return cb2();
      }
      var needDir = f2.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && !stat.isDirectory())
        return cb2(null, false, stat);
      var c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c !== "DIR")
        return cb2();
      return cb2(null, c, stat);
    };
  }
});

// node_modules/pkghub/dist/finder.js
var require_finder = __commonJS({
  "node_modules/pkghub/dist/finder.js"(exports2) {
    "use strict";
    var _interopRequireWildcard = function(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.split = split;
    exports2.read = read;
    var _fs = require_fs();
    var _fs2 = _interopRequireWildcard(_fs);
    var _path = require_path();
    var _path2 = _interopRequireWildcard(_path);
    var _glob = require_glob2();
    var _glob2 = _interopRequireWildcard(_glob);
    function split(name, isFilename) {
      if (!name || name.indexOf("/") === -1) {
        return;
      }
      if (!isFilename) {
        return name.substr(0, name.indexOf("/"));
      }
      return name.substr(name.indexOf("/") + 1);
    }
    function read(abs, name) {
      if (!abs) {
        return null;
      }
      var dir = _path2["default"].join(abs, name);
      var file = {
        name,
        dir,
        exist: _fs2["default"].existsSync(dir)
      };
      if (file.exist) {
        return file;
      }
      try {
        file.availables = _glob2["default"].sync(file.dir + "*");
      } catch (err) {
        file.err = err;
      }
      return file;
    }
  }
});

// node_modules/pkghub/dist/pkghub.js
var require_pkghub = __commonJS({
  "node_modules/pkghub/dist/pkghub.js"(exports2, module2) {
    "use strict";
    var _interopRequireWildcard = function(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    };
    var _classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _import = (init_index_all(), __toCommonJS(index_all_exports));
    var _import2 = _interopRequireWildcard(_import);
    var _Promise = require_bluebird();
    var _Promise2 = _interopRequireWildcard(_Promise);
    var _import3 = require_npm2();
    var npm = _interopRequireWildcard(_import3);
    var _import4 = require_finder();
    var finder = _interopRequireWildcard(_import4);
    var defaults = {
      devider: "-",
      includes: ["name", "version", "logo", "styles", "fonts", "javascripts", "static", "screenshot", "description", "main", "repository", "keywords", "author", "license", "bugs", "readme", "path", "depth", "realPath", "view engine"]
    };
    var pkgHub = function() {
      function pkgHub2() {
        var devider = arguments[0] === void 0 ? "-" : arguments[0];
        _classCallCheck(this, pkgHub2);
        this.module = {};
        this.module.dependencies = {};
        this.settings = _import2["default"].clone(defaults);
        this.settings.devider = devider;
      }
      _createClass(pkgHub2, [{
        key: "config",
        value: function config() {
          var params = arguments[0] === void 0 ? {} : arguments[0];
          this.settings = _import2["default"].extend(defaults, params);
          return this.settings;
        }
      }, {
        key: "list",
        // 列出所有依赖模块
        value: function list() {
          var _this = this;
          return npm.ls().then(function(packages) {
            var modules = _import2["default"].clone(packages);
            var dependencies = modules.dependencies;
            if (dependencies) {
              delete modules.dependencies;
              _import2["default"].each(dependencies, function(module3, name) {
                dependencies[name] = wash(module3);
              });
            }
            modules = wash(modules);
            modules.dependencies = dependencies;
            _this.module = modules;
            _this.cached = /* @__PURE__ */ new Date();
            return _Promise2["default"].resolve(modules);
          });
        }
      }, {
        key: "keywords",
        value: function keywords(shortcut, name) {
          var devider = this.settings.devider;
          var shortcuts = {
            __pkghub_addons: name + devider,
            __pkghub_plugins: name + devider + "plugin" + devider,
            __pkghub_themes: name + devider + "theme" + devider
          };
          return shortcuts[shortcut];
        }
      }, {
        key: "find",
        // 这里要加一层缓存，不要每次都去 list 一遍模块
        // 因为 npm 有个问题同时调用两次 load list 会报错。
        // 这样的话如果在路由里使用基本不现实
        value: function find2(name, modules) {
          var _this2 = this;
          return new _Promise2["default"](function(resolve, reject2) {
            var pkg = modules.dependencies[name];
            if (pkg)
              return resolve(pkg);
            var pkgname = finder.split(name);
            var filename = finder.split(name, "filename");
            if (pkgname && filename) {
              var m = modules.dependencies[pkgname] || null;
              if (!m || !m.realPath)
                return reject2(new Error("No module " + pkgname + " was found"));
              return resolve({
                module: m,
                file: finder.read(m.realPath, filename)
              });
            }
            var result2 = {};
            var keyword = _this2.keywords(name, modules.name) || name;
            Object.keys(modules.dependencies).forEach(function(name2) {
              if (name2.indexOf(keyword) > -1)
                result2[name2] = modules.dependencies[name2];
            });
            if (_import2["default"].isEmpty(result2))
              return reject2("No module " + name + " was found");
            var availables = Object.keys(result2);
            if (availables.length === 1)
              return resolve(result2[availables[0]]);
            return resolve(result2);
          });
        }
      }, {
        key: "load",
        // 加载某一个模块
        // 模块名称可以是全名，也可以是部分名
        // 模块名称可以包涵名称和子文件，比如 candy 或 candy/template.html
        // e.g: name = 'candy/tpl.html', file === tpl.html;
        value: function load(name, force) {
          var _this3 = this;
          var cache = this.module;
          if (this.cached && !force) {
            return this.find(name, cache);
          }
          return this.list().then(function(modules) {
            if (!modules.dependencies)
              return _Promise2["default"].reject(new Error("No module " + name + " was found"));
            return _this3.find(name, modules);
          });
        }
      }, {
        key: "addons",
        // 返回一个模块的相关模块，包括插件和主题
        // e.g: candy-editor 是 candy 的插件，此例中，插件包涵 `candy-` 字符串
        value: function addons() {
          return this.load("__pkghub_addons");
        }
      }, {
        key: "plugins",
        // 返回一个模块的插件列表
        // 某个包的插件是以 devider 分割的模块名字
        // e.g: candy-editor 是 candy 的插件，此例中，插件包涵 `candy-plugin` 字符串
        value: function plugins() {
          return this.load("__pkghub_plugins");
        }
      }, {
        key: "themes",
        // 返回一个模块的主题列表
        // e.g:  candy-theme-balbala 会被返回
        value: function themes() {
          return this.load("__pkghub_themes");
        }
      }, {
        key: "install",
        // 安装一个包，并返回所有依赖
        value: function install(modules, dir) {
          var _this4 = this;
          if (_import2["default"].isString(modules))
            modules = [modules];
          return npm.install(modules, dir).then(function(logs) {
            return _this4.list();
          });
        }
      }]);
      return pkgHub2;
    }();
    exports2["default"] = pkgHub;
    function wash(obj2) {
      var washed = {};
      defaults.includes.forEach(function(key) {
        if (obj2[key])
          washed[key] = obj2[key];
      });
      return washed;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/bluebird/js/browser/bluebird.js
var require_bluebird2 = __commonJS({
  "node_modules/bluebird/js/browser/bluebird.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f2;
        "undefined" != typeof window ? f2 = window : "undefined" != typeof global ? f2 = global : "undefined" != typeof self && (f2 = self), f2.Promise = e();
      }
    }(function() {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f2 = new Error("Cannot find module '" + o2 + "'");
              throw f2.code = "MODULE_NOT_FOUND", f2;
            }
            var l2 = n[o2] = { exports: {} };
            t[o2][0].call(l2.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l2, l2.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var SomePromiseArray = Promise2._SomePromiseArray;
          function any(promises) {
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(1);
            ret2.setUnwrap();
            ret2.init();
            return promise;
          }
          Promise2.any = function(promises) {
            return any(promises);
          };
          Promise2.prototype.any = function() {
            return any(this);
          };
        };
      }, {}], 2: [function(_dereq_2, module2, exports2) {
        "use strict";
        var firstLineError;
        try {
          throw new Error();
        } catch (e) {
          firstLineError = e;
        }
        var schedule = _dereq_2("./schedule.js");
        var Queue = _dereq_2("./queue.js");
        var util = _dereq_2("./util.js");
        function Async() {
          this._isTickUsed = false;
          this._lateQueue = new Queue(16);
          this._normalQueue = new Queue(16);
          this._trampolineEnabled = true;
          var self2 = this;
          this.drainQueues = function() {
            self2._drainQueues();
          };
          this._schedule = schedule.isStatic ? schedule(this.drainQueues) : schedule;
        }
        Async.prototype.disableTrampolineIfNecessary = function() {
          if (util.hasDevTools) {
            this._trampolineEnabled = false;
          }
        };
        Async.prototype.enableTrampoline = function() {
          if (!this._trampolineEnabled) {
            this._trampolineEnabled = true;
            this._schedule = function(fn) {
              setTimeout(fn, 0);
            };
          }
        };
        Async.prototype.haveItemsQueued = function() {
          return this._normalQueue.length() > 0;
        };
        Async.prototype.throwLater = function(fn, arg) {
          if (arguments.length === 1) {
            arg = fn;
            fn = function() {
              throw arg;
            };
          }
          if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
              fn(arg);
            }, 0);
          } else
            try {
              this._schedule(function() {
                fn(arg);
              });
            } catch (e) {
              throw new Error("No async scheduler available\n\n    See http://goo.gl/m3OTXk\n");
            }
        };
        function AsyncInvokeLater(fn, receiver, arg) {
          this._lateQueue.push(fn, receiver, arg);
          this._queueTick();
        }
        function AsyncInvoke(fn, receiver, arg) {
          this._normalQueue.push(fn, receiver, arg);
          this._queueTick();
        }
        function AsyncSettlePromises(promise) {
          this._normalQueue._pushOne(promise);
          this._queueTick();
        }
        if (!util.hasDevTools) {
          Async.prototype.invokeLater = AsyncInvokeLater;
          Async.prototype.invoke = AsyncInvoke;
          Async.prototype.settlePromises = AsyncSettlePromises;
        } else {
          if (schedule.isStatic) {
            schedule = function(fn) {
              setTimeout(fn, 0);
            };
          }
          Async.prototype.invokeLater = function(fn, receiver, arg) {
            if (this._trampolineEnabled) {
              AsyncInvokeLater.call(this, fn, receiver, arg);
            } else {
              this._schedule(function() {
                setTimeout(function() {
                  fn.call(receiver, arg);
                }, 100);
              });
            }
          };
          Async.prototype.invoke = function(fn, receiver, arg) {
            if (this._trampolineEnabled) {
              AsyncInvoke.call(this, fn, receiver, arg);
            } else {
              this._schedule(function() {
                fn.call(receiver, arg);
              });
            }
          };
          Async.prototype.settlePromises = function(promise) {
            if (this._trampolineEnabled) {
              AsyncSettlePromises.call(this, promise);
            } else {
              this._schedule(function() {
                promise._settlePromises();
              });
            }
          };
        }
        Async.prototype.invokeFirst = function(fn, receiver, arg) {
          this._normalQueue.unshift(fn, receiver, arg);
          this._queueTick();
        };
        Async.prototype._drainQueue = function(queue) {
          while (queue.length() > 0) {
            var fn = queue.shift();
            if (typeof fn !== "function") {
              fn._settlePromises();
              continue;
            }
            var receiver = queue.shift();
            var arg = queue.shift();
            fn.call(receiver, arg);
          }
        };
        Async.prototype._drainQueues = function() {
          this._drainQueue(this._normalQueue);
          this._reset();
          this._drainQueue(this._lateQueue);
        };
        Async.prototype._queueTick = function() {
          if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
          }
        };
        Async.prototype._reset = function() {
          this._isTickUsed = false;
        };
        module2.exports = new Async();
        module2.exports.firstLineError = firstLineError;
      }, { "./queue.js": 28, "./schedule.js": 31, "./util.js": 38 }], 3: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise) {
          var rejectThis = function(_3, e) {
            this._reject(e);
          };
          var targetRejected = function(e, context) {
            context.promiseRejectionQueued = true;
            context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
          };
          var bindingResolved = function(thisArg, context) {
            if (this._isPending()) {
              this._resolveCallback(context.target);
            }
          };
          var bindingRejected = function(e, context) {
            if (!context.promiseRejectionQueued)
              this._reject(e);
          };
          Promise2.prototype.bind = function(thisArg) {
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._propagateFrom(this, 1);
            var target = this._target();
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              var context = {
                promiseRejectionQueued: false,
                promise: ret2,
                target,
                bindingPromise: maybePromise
              };
              target._then(INTERNAL, targetRejected, ret2._progress, ret2, context);
              maybePromise._then(
                bindingResolved,
                bindingRejected,
                ret2._progress,
                ret2,
                context
              );
            } else {
              ret2._resolveCallback(target);
            }
            return ret2;
          };
          Promise2.prototype._setBoundTo = function(obj2) {
            if (obj2 !== void 0) {
              this._bitField = this._bitField | 131072;
              this._boundTo = obj2;
            } else {
              this._bitField = this._bitField & ~131072;
            }
          };
          Promise2.prototype._isBound = function() {
            return (this._bitField & 131072) === 131072;
          };
          Promise2.bind = function(thisArg, value) {
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              maybePromise._then(function() {
                ret2._resolveCallback(value);
              }, ret2._reject, ret2._progress, ret2, null);
            } else {
              ret2._resolveCallback(value);
            }
            return ret2;
          };
        };
      }, {}], 4: [function(_dereq_2, module2, exports2) {
        "use strict";
        var old;
        if (typeof Promise !== "undefined")
          old = Promise;
        function noConflict() {
          try {
            if (Promise === bluebird)
              Promise = old;
          } catch (e) {
          }
          return bluebird;
        }
        var bluebird = _dereq_2("./promise.js")();
        bluebird.noConflict = noConflict;
        module2.exports = bluebird;
      }, { "./promise.js": 23 }], 5: [function(_dereq_2, module2, exports2) {
        "use strict";
        var cr = Object.create;
        if (cr) {
          var callerCache = cr(null);
          var getterCache = cr(null);
          callerCache[" size"] = getterCache[" size"] = 0;
        }
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util.js");
          var canEvaluate2 = util.canEvaluate;
          var isIdentifier2 = util.isIdentifier;
          var getMethodCaller;
          var getGetter;
          if (false) {
            var makeMethodCaller = function(methodName) {
              return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
            };
            var makeGetter = function(propertyName) {
              return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
            };
            var getCompiled = function(name, compiler, cache) {
              var ret2 = cache[name];
              if (typeof ret2 !== "function") {
                if (!isIdentifier2(name)) {
                  return null;
                }
                ret2 = compiler(name);
                cache[name] = ret2;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                  var keys2 = Object.keys(cache);
                  for (var i = 0; i < 256; ++i)
                    delete cache[keys2[i]];
                  cache[" size"] = keys2.length - 256;
                }
              }
              return ret2;
            };
            getMethodCaller = function(name) {
              return getCompiled(name, makeMethodCaller, callerCache);
            };
            getGetter = function(name) {
              return getCompiled(name, makeGetter, getterCache);
            };
          }
          function ensureMethod(obj2, methodName) {
            var fn;
            if (obj2 != null)
              fn = obj2[methodName];
            if (typeof fn !== "function") {
              var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
              throw new Promise2.TypeError(message);
            }
            return fn;
          }
          function caller(obj2) {
            var methodName = this.pop();
            var fn = ensureMethod(obj2, methodName);
            return fn.apply(obj2, this);
          }
          Promise2.prototype.call = function(methodName) {
            var $_len = arguments.length;
            var args = new Array($_len - 1);
            for (var $_i = 1; $_i < $_len; ++$_i) {
              args[$_i - 1] = arguments[$_i];
            }
            if (false) {
              if (canEvaluate2) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                  return this._then(
                    maybeCaller,
                    void 0,
                    void 0,
                    args,
                    void 0
                  );
                }
              }
            }
            args.push(methodName);
            return this._then(caller, void 0, void 0, args, void 0);
          };
          function namedGetter(obj2) {
            return obj2[this];
          }
          function indexedGetter(obj2) {
            var index = +this;
            if (index < 0)
              index = Math.max(0, index + obj2.length);
            return obj2[index];
          }
          Promise2.prototype.get = function(propertyName) {
            var isIndex = typeof propertyName === "number";
            var getter;
            if (!isIndex) {
              if (canEvaluate2) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
              } else {
                getter = namedGetter;
              }
            } else {
              getter = indexedGetter;
            }
            return this._then(getter, void 0, void 0, propertyName, void 0);
          };
        };
      }, { "./util.js": 38 }], 6: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var errors = _dereq_2("./errors.js");
          var async = _dereq_2("./async.js");
          var CancellationError = errors.CancellationError;
          Promise2.prototype._cancel = function(reason) {
            if (!this.isCancellable())
              return this;
            var parent;
            var promiseToReject = this;
            while ((parent = promiseToReject._cancellationParent) !== void 0 && parent.isCancellable()) {
              promiseToReject = parent;
            }
            this._unsetCancellable();
            promiseToReject._target()._rejectCallback(reason, false, true);
          };
          Promise2.prototype.cancel = function(reason) {
            if (!this.isCancellable())
              return this;
            if (reason === void 0)
              reason = new CancellationError();
            async.invokeLater(this._cancel, this, reason);
            return this;
          };
          Promise2.prototype.cancellable = function() {
            if (this._cancellable())
              return this;
            async.enableTrampoline();
            this._setCancellable();
            this._cancellationParent = void 0;
            return this;
          };
          Promise2.prototype.uncancellable = function() {
            var ret2 = this.then();
            ret2._unsetCancellable();
            return ret2;
          };
          Promise2.prototype.fork = function(didFulfill, didReject, didProgress) {
            var ret2 = this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
            ret2._setCancellable();
            ret2._cancellationParent = void 0;
            return ret2;
          };
        };
      }, { "./async.js": 2, "./errors.js": 13 }], 7: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
          var stackFramePattern = null;
          var formatStack = null;
          var indentStackFrames = false;
          var warn;
          function CapturedTrace(parent) {
            this._parent = parent;
            var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
            captureStackTrace(this, CapturedTrace);
            if (length > 32)
              this.uncycle();
          }
          util.inherits(CapturedTrace, Error);
          CapturedTrace.prototype.uncycle = function() {
            var length = this._length;
            if (length < 2)
              return;
            var nodes = [];
            var stackToIndex = {};
            for (var i = 0, node = this; node !== void 0; ++i) {
              nodes.push(node);
              node = node._parent;
            }
            length = this._length = i;
            for (var i = length - 1; i >= 0; --i) {
              var stack = nodes[i].stack;
              if (stackToIndex[stack] === void 0) {
                stackToIndex[stack] = i;
              }
            }
            for (var i = 0; i < length; ++i) {
              var currentStack = nodes[i].stack;
              var index = stackToIndex[currentStack];
              if (index !== void 0 && index !== i) {
                if (index > 0) {
                  nodes[index - 1]._parent = void 0;
                  nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = void 0;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                if (index < length - 1) {
                  cycleEdgeNode._parent = nodes[index + 1];
                  cycleEdgeNode._parent.uncycle();
                  cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                  cycleEdgeNode._parent = void 0;
                  cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                  nodes[j]._length = currentChildLength;
                  currentChildLength++;
                }
                return;
              }
            }
          };
          CapturedTrace.prototype.parent = function() {
            return this._parent;
          };
          CapturedTrace.prototype.hasParent = function() {
            return this._parent !== void 0;
          };
          CapturedTrace.prototype.attachExtraTrace = function(error) {
            if (error.__stackCleaned__)
              return;
            this.uncycle();
            var parsed = CapturedTrace.parseStackAndMessage(error);
            var message = parsed.message;
            var stacks = [parsed.stack];
            var trace = this;
            while (trace !== void 0) {
              stacks.push(cleanStack(trace.stack.split("\n")));
              trace = trace._parent;
            }
            removeCommonRoots(stacks);
            removeDuplicateOrEmptyJumps(stacks);
            util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
            util.notEnumerableProp(error, "__stackCleaned__", true);
          };
          function reconstructStack(message, stacks) {
            for (var i = 0; i < stacks.length - 1; ++i) {
              stacks[i].push("From previous event:");
              stacks[i] = stacks[i].join("\n");
            }
            if (i < stacks.length) {
              stacks[i] = stacks[i].join("\n");
            }
            return message + "\n" + stacks.join("\n");
          }
          function removeDuplicateOrEmptyJumps(stacks) {
            for (var i = 0; i < stacks.length; ++i) {
              if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
              }
            }
          }
          function removeCommonRoots(stacks) {
            var current = stacks[0];
            for (var i = 1; i < stacks.length; ++i) {
              var prev = stacks[i];
              var currentLastIndex = current.length - 1;
              var currentLastLine = current[currentLastIndex];
              var commonRootMeetPoint = -1;
              for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                  commonRootMeetPoint = j;
                  break;
                }
              }
              for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                  current.pop();
                  currentLastIndex--;
                } else {
                  break;
                }
              }
              current = prev;
            }
          }
          function cleanStack(stack) {
            var ret2 = [];
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              var isTraceLine = stackFramePattern.test(line) || "    (No stack trace)" === line;
              var isInternalFrame = isTraceLine && shouldIgnore(line);
              if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                  line = "    " + line;
                }
                ret2.push(line);
              }
            }
            return ret2;
          }
          function stackFramesAsArray(error) {
            var stack = error.stack.replace(/\s+$/g, "").split("\n");
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
              }
            }
            if (i > 0) {
              stack = stack.slice(i);
            }
            return stack;
          }
          CapturedTrace.parseStackAndMessage = function(error) {
            var stack = error.stack;
            var message = error.toString();
            stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
            return {
              message,
              stack: cleanStack(stack)
            };
          };
          CapturedTrace.formatAndLogError = function(error, title) {
            if (typeof console !== "undefined") {
              var message;
              if (typeof error === "object" || typeof error === "function") {
                var stack = error.stack;
                message = title + formatStack(stack, error);
              } else {
                message = title + String(error);
              }
              if (typeof warn === "function") {
                warn(message);
              } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
              }
            }
          };
          CapturedTrace.unhandledRejection = function(reason) {
            CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
          };
          CapturedTrace.isSupported = function() {
            return typeof captureStackTrace === "function";
          };
          CapturedTrace.fireRejectionEvent = function(name, localHandler, reason, promise) {
            var localEventFired = false;
            try {
              if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                  localHandler(promise);
                } else {
                  localHandler(reason, promise);
                }
              }
            } catch (e) {
              async.throwLater(e);
            }
            var globalEventFired = false;
            try {
              globalEventFired = fireGlobalEvent(name, reason, promise);
            } catch (e) {
              globalEventFired = true;
              async.throwLater(e);
            }
            var domEventFired = false;
            if (fireDomEvent) {
              try {
                domEventFired = fireDomEvent(name.toLowerCase(), {
                  reason,
                  promise
                });
              } catch (e) {
                domEventFired = true;
                async.throwLater(e);
              }
            }
            if (!globalEventFired && !localEventFired && !domEventFired && name === "unhandledRejection") {
              CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
            }
          };
          function formatNonError(obj2) {
            var str;
            if (typeof obj2 === "function") {
              str = "[function " + (obj2.name || "anonymous") + "]";
            } else {
              str = obj2.toString();
              var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
              if (ruselessToString.test(str)) {
                try {
                  var newStr = JSON.stringify(obj2);
                  str = newStr;
                } catch (e) {
                }
              }
              if (str.length === 0) {
                str = "(empty array)";
              }
            }
            return "(<" + snip(str) + ">, no stack trace)";
          }
          function snip(str) {
            var maxChars = 41;
            if (str.length < maxChars) {
              return str;
            }
            return str.substr(0, maxChars - 3) + "...";
          }
          var shouldIgnore = function() {
            return false;
          };
          var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function parseLineInfo(line) {
            var matches = line.match(parseLineInfoRegex);
            if (matches) {
              return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
              };
            }
          }
          CapturedTrace.setBounds = function(firstLineError, lastLineError) {
            if (!CapturedTrace.isSupported())
              return;
            var firstStackLines = firstLineError.stack.split("\n");
            var lastStackLines = lastLineError.stack.split("\n");
            var firstIndex = -1;
            var lastIndex = -1;
            var firstFileName;
            var lastFileName;
            for (var i = 0; i < firstStackLines.length; ++i) {
              var result2 = parseLineInfo(firstStackLines[i]);
              if (result2) {
                firstFileName = result2.fileName;
                firstIndex = result2.line;
                break;
              }
            }
            for (var i = 0; i < lastStackLines.length; ++i) {
              var result2 = parseLineInfo(lastStackLines[i]);
              if (result2) {
                lastFileName = result2.fileName;
                lastIndex = result2.line;
                break;
              }
            }
            if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
              return;
            }
            shouldIgnore = function(line) {
              if (bluebirdFramePattern.test(line))
                return true;
              var info = parseLineInfo(line);
              if (info) {
                if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                  return true;
                }
              }
              return false;
            };
          };
          var captureStackTrace = function stackDetection() {
            var v8stackFramePattern = /^\s*at\s*/;
            var v8stackFormatter = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if (error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
              Error.stackTraceLimit = Error.stackTraceLimit + 6;
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              var captureStackTrace2 = Error.captureStackTrace;
              shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
              };
              return function(receiver, ignoreUntil) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                captureStackTrace2(receiver, ignoreUntil);
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
              };
            }
            var err = new Error();
            if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
              stackFramePattern = /@/;
              formatStack = v8stackFormatter;
              indentStackFrames = true;
              return function captureStackTrace3(o) {
                o.stack = new Error().stack;
              };
            }
            var hasStackAfterThrow;
            try {
              throw new Error();
            } catch (e) {
              hasStackAfterThrow = "stack" in e;
            }
            if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              return function captureStackTrace3(o) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                try {
                  throw new Error();
                } catch (e) {
                  o.stack = e.stack;
                }
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
              };
            }
            formatStack = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            return null;
          }([]);
          var fireDomEvent;
          var fireGlobalEvent = function() {
            if (util.isNode) {
              return function(name, reason, promise) {
                if (name === "rejectionHandled") {
                  return process.emit(name, promise);
                } else {
                  return process.emit(name, reason, promise);
                }
              };
            } else {
              var customEventWorks = false;
              var anyEventWorks = true;
              try {
                var ev = new self.CustomEvent("test");
                customEventWorks = ev instanceof CustomEvent;
              } catch (e) {
              }
              if (!customEventWorks) {
                try {
                  var event = document.createEvent("CustomEvent");
                  event.initCustomEvent("testingtheevent", false, true, {});
                  self.dispatchEvent(event);
                } catch (e) {
                  anyEventWorks = false;
                }
              }
              if (anyEventWorks) {
                fireDomEvent = function(type, detail) {
                  var event2;
                  if (customEventWorks) {
                    event2 = new self.CustomEvent(type, {
                      detail,
                      bubbles: false,
                      cancelable: true
                    });
                  } else if (self.dispatchEvent) {
                    event2 = document.createEvent("CustomEvent");
                    event2.initCustomEvent(type, false, true, detail);
                  }
                  return event2 ? !self.dispatchEvent(event2) : false;
                };
              }
              var toWindowMethodNameMap = {};
              toWindowMethodNameMap["unhandledRejection"] = "onunhandledRejection".toLowerCase();
              toWindowMethodNameMap["rejectionHandled"] = "onrejectionHandled".toLowerCase();
              return function(name, reason, promise) {
                var methodName = toWindowMethodNameMap[name];
                var method = self[methodName];
                if (!method)
                  return false;
                if (name === "rejectionHandled") {
                  method.call(self, promise);
                } else {
                  method.call(self, reason, promise);
                }
                return true;
              };
            }
          }();
          if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
            warn = function(message) {
              console.warn(message);
            };
            if (util.isNode && process.stderr.isTTY) {
              warn = function(message) {
                process.stderr.write("\x1B[31m" + message + "\x1B[39m\n");
              };
            } else if (!util.isNode && typeof new Error().stack === "string") {
              warn = function(message) {
                console.warn("%c" + message, "color: red");
              };
            }
          }
          return CapturedTrace;
        };
      }, { "./async.js": 2, "./util.js": 38 }], 8: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(NEXT_FILTER) {
          var util = _dereq_2("./util.js");
          var errors = _dereq_2("./errors.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var keys2 = _dereq_2("./es5.js").keys;
          var TypeError2 = errors.TypeError;
          function CatchFilter(instances, callback, promise) {
            this._instances = instances;
            this._callback = callback;
            this._promise = promise;
          }
          function safePredicate(predicate, e) {
            var safeObject = {};
            var retfilter = tryCatch2(predicate).call(safeObject, e);
            if (retfilter === errorObj2)
              return retfilter;
            var safeKeys = keys2(safeObject);
            if (safeKeys.length) {
              errorObj2.e = new TypeError2("Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n");
              return errorObj2;
            }
            return retfilter;
          }
          CatchFilter.prototype.doFilter = function(e) {
            var cb2 = this._callback;
            var promise = this._promise;
            var boundTo = promise._boundValue();
            for (var i = 0, len = this._instances.length; i < len; ++i) {
              var item = this._instances[i];
              var itemIsErrorType = item === Error || item != null && item.prototype instanceof Error;
              if (itemIsErrorType && e instanceof item) {
                var ret2 = tryCatch2(cb2).call(boundTo, e);
                if (ret2 === errorObj2) {
                  NEXT_FILTER.e = ret2.e;
                  return NEXT_FILTER;
                }
                return ret2;
              } else if (typeof item === "function" && !itemIsErrorType) {
                var shouldHandle = safePredicate(item, e);
                if (shouldHandle === errorObj2) {
                  e = errorObj2.e;
                  break;
                } else if (shouldHandle) {
                  var ret2 = tryCatch2(cb2).call(boundTo, e);
                  if (ret2 === errorObj2) {
                    NEXT_FILTER.e = ret2.e;
                    return NEXT_FILTER;
                  }
                  return ret2;
                }
              }
            }
            NEXT_FILTER.e = e;
            return NEXT_FILTER;
          };
          return CatchFilter;
        };
      }, { "./errors.js": 13, "./es5.js": 14, "./util.js": 38 }], 9: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, CapturedTrace, isDebugging) {
          var contextStack = [];
          function Context() {
            this._trace = new CapturedTrace(peekContext());
          }
          Context.prototype._pushContext = function() {
            if (!isDebugging())
              return;
            if (this._trace !== void 0) {
              contextStack.push(this._trace);
            }
          };
          Context.prototype._popContext = function() {
            if (!isDebugging())
              return;
            if (this._trace !== void 0) {
              contextStack.pop();
            }
          };
          function createContext() {
            if (isDebugging())
              return new Context();
          }
          function peekContext() {
            var lastIndex = contextStack.length - 1;
            if (lastIndex >= 0) {
              return contextStack[lastIndex];
            }
            return void 0;
          }
          Promise2.prototype._peekContext = peekContext;
          Promise2.prototype._pushContext = Context.prototype._pushContext;
          Promise2.prototype._popContext = Context.prototype._popContext;
          return createContext;
        };
      }, {}], 10: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, CapturedTrace) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var Warning = _dereq_2("./errors.js").Warning;
          var util = _dereq_2("./util.js");
          var canAttachTrace2 = util.canAttachTrace;
          var unhandledRejectionHandled;
          var possiblyUnhandledRejection;
          var debugging = util.isNode && (!!process.env["BLUEBIRD_DEBUG"] || true);
          if (util.isNode && process.env["BLUEBIRD_DEBUG"] == 0)
            debugging = false;
          if (debugging) {
            async.disableTrampolineIfNecessary();
          }
          Promise2.prototype._ignoreRejections = function() {
            this._unsetRejectionIsUnhandled();
            this._bitField = this._bitField | 16777216;
          };
          Promise2.prototype._ensurePossibleRejectionHandled = function() {
            if ((this._bitField & 16777216) !== 0)
              return;
            this._setRejectionIsUnhandled();
            async.invokeLater(this._notifyUnhandledRejection, this, void 0);
          };
          Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
            CapturedTrace.fireRejectionEvent(
              "rejectionHandled",
              unhandledRejectionHandled,
              void 0,
              this
            );
          };
          Promise2.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var reason = this._getCarriedStackTrace() || this._settledValue;
              this._setUnhandledRejectionIsNotified();
              CapturedTrace.fireRejectionEvent(
                "unhandledRejection",
                possiblyUnhandledRejection,
                reason,
                this
              );
            }
          };
          Promise2.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 524288;
          };
          Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & ~524288;
          };
          Promise2.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 524288) > 0;
          };
          Promise2.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 2097152;
          };
          Promise2.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & ~2097152;
            if (this._isUnhandledRejectionNotified()) {
              this._unsetUnhandledRejectionIsNotified();
              this._notifyUnhandledRejectionIsHandled();
            }
          };
          Promise2.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 2097152) > 0;
          };
          Promise2.prototype._setCarriedStackTrace = function(capturedTrace) {
            this._bitField = this._bitField | 1048576;
            this._fulfillmentHandler0 = capturedTrace;
          };
          Promise2.prototype._isCarryingStackTrace = function() {
            return (this._bitField & 1048576) > 0;
          };
          Promise2.prototype._getCarriedStackTrace = function() {
            return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : void 0;
          };
          Promise2.prototype._captureStackTrace = function() {
            if (debugging) {
              this._trace = new CapturedTrace(this._peekContext());
            }
            return this;
          };
          Promise2.prototype._attachExtraTrace = function(error, ignoreSelf) {
            if (debugging && canAttachTrace2(error)) {
              var trace = this._trace;
              if (trace !== void 0) {
                if (ignoreSelf)
                  trace = trace._parent;
              }
              if (trace !== void 0) {
                trace.attachExtraTrace(error);
              } else if (!error.__stackCleaned__) {
                var parsed = CapturedTrace.parseStackAndMessage(error);
                util.notEnumerableProp(
                  error,
                  "stack",
                  parsed.message + "\n" + parsed.stack.join("\n")
                );
                util.notEnumerableProp(error, "__stackCleaned__", true);
              }
            }
          };
          Promise2.prototype._warn = function(message) {
            var warning = new Warning(message);
            var ctx = this._peekContext();
            if (ctx) {
              ctx.attachExtraTrace(warning);
            } else {
              var parsed = CapturedTrace.parseStackAndMessage(warning);
              warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
            }
            CapturedTrace.formatAndLogError(warning, "");
          };
          Promise2.onPossiblyUnhandledRejection = function(fn) {
            var domain = getDomain();
            possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : void 0;
          };
          Promise2.onUnhandledRejectionHandled = function(fn) {
            var domain = getDomain();
            unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : void 0;
          };
          Promise2.longStackTraces = function() {
            if (async.haveItemsQueued() && debugging === false) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n");
            }
            debugging = CapturedTrace.isSupported();
            if (debugging) {
              async.disableTrampolineIfNecessary();
            }
          };
          Promise2.hasLongStackTraces = function() {
            return debugging && CapturedTrace.isSupported();
          };
          if (!CapturedTrace.isSupported()) {
            Promise2.longStackTraces = function() {
            };
            debugging = false;
          }
          return function() {
            return debugging;
          };
        };
      }, { "./async.js": 2, "./errors.js": 13, "./util.js": 38 }], 11: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util.js");
        var isPrimitive2 = util.isPrimitive;
        module2.exports = function(Promise2) {
          var returner = function() {
            return this;
          };
          var thrower2 = function() {
            throw this;
          };
          var returnUndefined = function() {
          };
          var throwUndefined = function() {
            throw void 0;
          };
          var wrapper = function(value, action) {
            if (action === 1) {
              return function() {
                throw value;
              };
            } else if (action === 2) {
              return function() {
                return value;
              };
            }
          };
          Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
            if (value === void 0)
              return this.then(returnUndefined);
            if (isPrimitive2(value)) {
              return this._then(
                wrapper(value, 2),
                void 0,
                void 0,
                void 0,
                void 0
              );
            } else if (value instanceof Promise2) {
              value._ignoreRejections();
            }
            return this._then(returner, void 0, void 0, value, void 0);
          };
          Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
            if (reason === void 0)
              return this.then(throwUndefined);
            if (isPrimitive2(reason)) {
              return this._then(
                wrapper(reason, 1),
                void 0,
                void 0,
                void 0,
                void 0
              );
            }
            return this._then(thrower2, void 0, void 0, reason, void 0);
          };
        };
      }, { "./util.js": 38 }], 12: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseReduce = Promise2.reduce;
          Promise2.prototype.each = function(fn) {
            return PromiseReduce(this, fn, null, INTERNAL);
          };
          Promise2.each = function(promises, fn) {
            return PromiseReduce(promises, fn, null, INTERNAL);
          };
        };
      }, {}], 13: [function(_dereq_2, module2, exports2) {
        "use strict";
        var es52 = _dereq_2("./es5.js");
        var Objectfreeze = es52.freeze;
        var util = _dereq_2("./util.js");
        var inherits2 = util.inherits;
        var notEnumerableProp2 = util.notEnumerableProp;
        function subError(nameProperty, defaultMessage) {
          function SubError(message) {
            if (!(this instanceof SubError))
              return new SubError(message);
            notEnumerableProp2(
              this,
              "message",
              typeof message === "string" ? message : defaultMessage
            );
            notEnumerableProp2(this, "name", nameProperty);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            } else {
              Error.call(this);
            }
          }
          inherits2(SubError, Error);
          return SubError;
        }
        var _TypeError, _RangeError;
        var Warning = subError("Warning", "warning");
        var CancellationError = subError("CancellationError", "cancellation error");
        var TimeoutError = subError("TimeoutError", "timeout error");
        var AggregateError = subError("AggregateError", "aggregate error");
        try {
          _TypeError = TypeError;
          _RangeError = RangeError;
        } catch (e) {
          _TypeError = subError("TypeError", "type error");
          _RangeError = subError("RangeError", "range error");
        }
        var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
        for (var i = 0; i < methods.length; ++i) {
          if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
          }
        }
        es52.defineProperty(AggregateError.prototype, "length", {
          value: 0,
          configurable: false,
          writable: true,
          enumerable: true
        });
        AggregateError.prototype["isOperational"] = true;
        var level = 0;
        AggregateError.prototype.toString = function() {
          var indent = Array(level * 4 + 1).join(" ");
          var ret2 = "\n" + indent + "AggregateError of:\n";
          level++;
          indent = Array(level * 4 + 1).join(" ");
          for (var i2 = 0; i2 < this.length; ++i2) {
            var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
              lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret2 += str + "\n";
          }
          level--;
          return ret2;
        };
        function OperationalError(message) {
          if (!(this instanceof OperationalError))
            return new OperationalError(message);
          notEnumerableProp2(this, "name", "OperationalError");
          notEnumerableProp2(this, "message", message);
          this.cause = message;
          this["isOperational"] = true;
          if (message instanceof Error) {
            notEnumerableProp2(this, "message", message.message);
            notEnumerableProp2(this, "stack", message.stack);
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        inherits2(OperationalError, Error);
        var errorTypes = Error["__BluebirdErrorTypes__"];
        if (!errorTypes) {
          errorTypes = Objectfreeze({
            CancellationError,
            TimeoutError,
            OperationalError,
            RejectionError: OperationalError,
            AggregateError
          });
          notEnumerableProp2(Error, "__BluebirdErrorTypes__", errorTypes);
        }
        module2.exports = {
          Error,
          TypeError: _TypeError,
          RangeError: _RangeError,
          CancellationError: errorTypes.CancellationError,
          OperationalError: errorTypes.OperationalError,
          TimeoutError: errorTypes.TimeoutError,
          AggregateError: errorTypes.AggregateError,
          Warning
        };
      }, { "./es5.js": 14, "./util.js": 38 }], 14: [function(_dereq_2, module2, exports2) {
        var isES5 = function() {
          "use strict";
          return this === void 0;
        }();
        if (isES5) {
          module2.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5,
            propertyIsWritable: function(obj2, prop) {
              var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
              return !!(!descriptor || descriptor.writable || descriptor.set);
            }
          };
        } else {
          var has3 = {}.hasOwnProperty;
          var str = {}.toString;
          var proto = {}.constructor.prototype;
          var ObjectKeys = function(o) {
            var ret2 = [];
            for (var key in o) {
              if (has3.call(o, key)) {
                ret2.push(key);
              }
            }
            return ret2;
          };
          var ObjectGetDescriptor = function(o, key) {
            return { value: o[key] };
          };
          var ObjectDefineProperty = function(o, key, desc) {
            o[key] = desc.value;
            return o;
          };
          var ObjectFreeze = function(obj2) {
            return obj2;
          };
          var ObjectGetPrototypeOf = function(obj2) {
            try {
              return Object(obj2).constructor.prototype;
            } catch (e) {
              return proto;
            }
          };
          var ArrayIsArray = function(obj2) {
            try {
              return str.call(obj2) === "[object Array]";
            } catch (e) {
              return false;
            }
          };
          module2.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5,
            propertyIsWritable: function() {
              return true;
            }
          };
        }
      }, {}], 15: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseMap = Promise2.map;
          Promise2.prototype.filter = function(fn, options) {
            return PromiseMap(this, fn, options, INTERNAL);
          };
          Promise2.filter = function(promises, fn, options) {
            return PromiseMap(promises, fn, options, INTERNAL);
          };
        };
      }, {}], 16: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, NEXT_FILTER, tryConvertToPromise) {
          var util = _dereq_2("./util.js");
          var isPrimitive2 = util.isPrimitive;
          var thrower2 = util.thrower;
          function returnThis() {
            return this;
          }
          function throwThis() {
            throw this;
          }
          function return$(r) {
            return function() {
              return r;
            };
          }
          function throw$(r) {
            return function() {
              throw r;
            };
          }
          function promisedFinally(ret2, reasonOrValue, isFulfilled) {
            var then;
            if (isPrimitive2(reasonOrValue)) {
              then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
            } else {
              then = isFulfilled ? returnThis : throwThis;
            }
            return ret2._then(then, thrower2, void 0, reasonOrValue, void 0);
          }
          function finallyHandler(reasonOrValue) {
            var promise = this.promise;
            var handler = this.handler;
            var ret2 = promise._isBound() ? handler.call(promise._boundValue()) : handler();
            if (ret2 !== void 0) {
              var maybePromise = tryConvertToPromise(ret2, promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                return promisedFinally(
                  maybePromise,
                  reasonOrValue,
                  promise.isFulfilled()
                );
              }
            }
            if (promise.isRejected()) {
              NEXT_FILTER.e = reasonOrValue;
              return NEXT_FILTER;
            } else {
              return reasonOrValue;
            }
          }
          function tapHandler(value) {
            var promise = this.promise;
            var handler = this.handler;
            var ret2 = promise._isBound() ? handler.call(promise._boundValue(), value) : handler(value);
            if (ret2 !== void 0) {
              var maybePromise = tryConvertToPromise(ret2, promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, value, true);
              }
            }
            return value;
          }
          Promise2.prototype._passThroughHandler = function(handler, isFinally) {
            if (typeof handler !== "function")
              return this.then();
            var promiseAndHandler = {
              promise: this,
              handler
            };
            return this._then(
              isFinally ? finallyHandler : tapHandler,
              isFinally ? finallyHandler : void 0,
              void 0,
              promiseAndHandler,
              void 0
            );
          };
          Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
            return this._passThroughHandler(handler, true);
          };
          Promise2.prototype.tap = function(handler) {
            return this._passThroughHandler(handler, false);
          };
        };
      }, { "./util.js": 38 }], 17: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise) {
          var errors = _dereq_2("./errors.js");
          var TypeError2 = errors.TypeError;
          var util = _dereq_2("./util.js");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var yieldHandlers = [];
          function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
            for (var i = 0; i < yieldHandlers2.length; ++i) {
              traceParent._pushContext();
              var result2 = tryCatch2(yieldHandlers2[i])(value);
              traceParent._popContext();
              if (result2 === errorObj2) {
                traceParent._pushContext();
                var ret2 = Promise2.reject(errorObj2.e);
                traceParent._popContext();
                return ret2;
              }
              var maybePromise = tryConvertToPromise(result2, traceParent);
              if (maybePromise instanceof Promise2)
                return maybePromise;
            }
            return null;
          }
          function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
            var promise = this._promise = new Promise2(INTERNAL);
            promise._captureStackTrace();
            this._stack = stack;
            this._generatorFunction = generatorFunction;
            this._receiver = receiver;
            this._generator = void 0;
            this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
          }
          PromiseSpawn.prototype.promise = function() {
            return this._promise;
          };
          PromiseSpawn.prototype._run = function() {
            this._generator = this._generatorFunction.call(this._receiver);
            this._receiver = this._generatorFunction = void 0;
            this._next(void 0);
          };
          PromiseSpawn.prototype._continue = function(result2) {
            if (result2 === errorObj2) {
              return this._promise._rejectCallback(result2.e, false, true);
            }
            var value = result2.value;
            if (result2.done === true) {
              this._promise._resolveCallback(value);
            } else {
              var maybePromise = tryConvertToPromise(value, this._promise);
              if (!(maybePromise instanceof Promise2)) {
                maybePromise = promiseFromYieldHandler(
                  maybePromise,
                  this._yieldHandlers,
                  this._promise
                );
                if (maybePromise === null) {
                  this._throw(
                    new TypeError2(
                      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                    )
                  );
                  return;
                }
              }
              maybePromise._then(
                this._next,
                this._throw,
                void 0,
                this,
                null
              );
            }
          };
          PromiseSpawn.prototype._throw = function(reason) {
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            var result2 = tryCatch2(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
            this._continue(result2);
          };
          PromiseSpawn.prototype._next = function(value) {
            this._promise._pushContext();
            var result2 = tryCatch2(this._generator.next).call(this._generator, value);
            this._promise._popContext();
            this._continue(result2);
          };
          Promise2.coroutine = function(generatorFunction, options) {
            if (typeof generatorFunction !== "function") {
              throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n");
            }
            var yieldHandler = Object(options).yieldHandler;
            var PromiseSpawn$ = PromiseSpawn;
            var stack = new Error().stack;
            return function() {
              var generator = generatorFunction.apply(this, arguments);
              var spawn = new PromiseSpawn$(
                void 0,
                void 0,
                yieldHandler,
                stack
              );
              spawn._generator = generator;
              spawn._next(void 0);
              return spawn.promise();
            };
          };
          Promise2.coroutine.addYieldHandler = function(fn) {
            if (typeof fn !== "function")
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            yieldHandlers.push(fn);
          };
          Promise2.spawn = function(generatorFunction) {
            if (typeof generatorFunction !== "function") {
              return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n");
            }
            var spawn = new PromiseSpawn(generatorFunction, this);
            var ret2 = spawn.promise();
            spawn._run(Promise2.spawn);
            return ret2;
          };
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 18: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL) {
          var util = _dereq_2("./util.js");
          var canEvaluate2 = util.canEvaluate;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var reject2;
          if (false) {
            if (canEvaluate2) {
              var thenCallback = function(i2) {
                return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
              };
              var caller = function(count) {
                var values2 = [];
                for (var i2 = 1; i2 <= count; ++i2)
                  values2.push("holder.p" + i2);
                return new Function("holder", "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ".replace(/values/g, values2.join(", ")));
              };
              var thenCallbacks = [];
              var callers = [void 0];
              for (var i = 1; i <= 5; ++i) {
                thenCallbacks.push(thenCallback(i));
                callers.push(caller(i));
              }
              var Holder = function(total, fn) {
                this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                this.fn = fn;
                this.total = total;
                this.now = 0;
              };
              Holder.prototype.callers = callers;
              Holder.prototype.checkFulfillment = function(promise) {
                var now = this.now;
                now++;
                var total = this.total;
                if (now >= total) {
                  var handler = this.callers[total];
                  promise._pushContext();
                  var ret2 = tryCatch2(handler)(this);
                  promise._popContext();
                  if (ret2 === errorObj2) {
                    promise._rejectCallback(ret2.e, false, true);
                  } else {
                    promise._resolveCallback(ret2);
                  }
                } else {
                  this.now = now;
                }
              };
              var reject2 = function(reason) {
                this._reject(reason);
              };
            }
          }
          Promise2.join = function() {
            var last2 = arguments.length - 1;
            var fn;
            if (last2 > 0 && typeof arguments[last2] === "function") {
              fn = arguments[last2];
              if (false) {
                if (last2 < 6 && canEvaluate2) {
                  var ret2 = new Promise2(INTERNAL);
                  ret2._captureStackTrace();
                  var holder = new Holder(last2, fn);
                  var callbacks = thenCallbacks;
                  for (var i2 = 0; i2 < last2; ++i2) {
                    var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                    if (maybePromise instanceof Promise2) {
                      maybePromise = maybePromise._target();
                      if (maybePromise._isPending()) {
                        maybePromise._then(
                          callbacks[i2],
                          reject2,
                          void 0,
                          ret2,
                          holder
                        );
                      } else if (maybePromise._isFulfilled()) {
                        callbacks[i2].call(
                          ret2,
                          maybePromise._value(),
                          holder
                        );
                      } else {
                        ret2._reject(maybePromise._reason());
                      }
                    } else {
                      callbacks[i2].call(ret2, maybePromise, holder);
                    }
                  }
                  return ret2;
                }
              }
            }
            var $_len = arguments.length;
            var args = new Array($_len);
            for (var $_i = 0; $_i < $_len; ++$_i) {
              args[$_i] = arguments[$_i];
            }
            if (fn)
              args.pop();
            var ret2 = new PromiseArray(args).promise();
            return fn !== void 0 ? ret2.spread(fn) : ret2;
          };
        };
      }, { "./util.js": 38 }], 19: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var PENDING = {};
          var EMPTY_ARRAY = [];
          function MappingPromiseArray(promises, fn, limit, _filter) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            var domain = getDomain();
            this._callback = domain === null ? fn : domain.bind(fn);
            this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
            this._limit = limit;
            this._inFlight = 0;
            this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
            async.invoke(init, this, void 0);
          }
          util.inherits(MappingPromiseArray, PromiseArray);
          function init() {
            this._init$(void 0, -2);
          }
          MappingPromiseArray.prototype._init = function() {
          };
          MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values2 = this._values;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var limit = this._limit;
            if (values2[index] === PENDING) {
              values2[index] = value;
              if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved())
                  return;
              }
            } else {
              if (limit >= 1 && this._inFlight >= limit) {
                values2[index] = value;
                this._queue.push(index);
                return;
              }
              if (preservedValues !== null)
                preservedValues[index] = value;
              var callback = this._callback;
              var receiver = this._promise._boundValue();
              this._promise._pushContext();
              var ret2 = tryCatch2(callback).call(receiver, value, index, length);
              this._promise._popContext();
              if (ret2 === errorObj2)
                return this._reject(ret2.e);
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  if (limit >= 1)
                    this._inFlight++;
                  values2[index] = PENDING;
                  return maybePromise._proxyPromiseArray(this, index);
                } else if (maybePromise._isFulfilled()) {
                  ret2 = maybePromise._value();
                } else {
                  return this._reject(maybePromise._reason());
                }
              }
              values2[index] = ret2;
            }
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= length) {
              if (preservedValues !== null) {
                this._filter(values2, preservedValues);
              } else {
                this._resolve(values2);
              }
            }
          };
          MappingPromiseArray.prototype._drainQueue = function() {
            var queue = this._queue;
            var limit = this._limit;
            var values2 = this._values;
            while (queue.length > 0 && this._inFlight < limit) {
              if (this._isResolved())
                return;
              var index = queue.pop();
              this._promiseFulfilled(values2[index], index);
            }
          };
          MappingPromiseArray.prototype._filter = function(booleans, values2) {
            var len = values2.length;
            var ret2 = new Array(len);
            var j = 0;
            for (var i = 0; i < len; ++i) {
              if (booleans[i])
                ret2[j++] = values2[i];
            }
            ret2.length = j;
            this._resolve(ret2);
          };
          MappingPromiseArray.prototype.preservedValues = function() {
            return this._preservedValues;
          };
          function map2(promises, fn, options, _filter) {
            var limit = typeof options === "object" && options !== null ? options.concurrency : 0;
            limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
            return new MappingPromiseArray(promises, fn, limit, _filter);
          }
          Promise2.prototype.map = function(fn, options) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            return map2(this, fn, options, null).promise();
          };
          Promise2.map = function(promises, fn, options, _filter) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            return map2(promises, fn, options, _filter).promise();
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 20: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          Promise2.method = function(fn) {
            if (typeof fn !== "function") {
              throw new Promise2.TypeError("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            return function() {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._pushContext();
              var value = tryCatch2(fn).apply(this, arguments);
              ret2._popContext();
              ret2._resolveFromSyncValue(value);
              return ret2;
            };
          };
          Promise2.attempt = Promise2["try"] = function(fn, args, ctx) {
            if (typeof fn !== "function") {
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._pushContext();
            var value = util.isArray(args) ? tryCatch2(fn).apply(ctx, args) : tryCatch2(fn).call(ctx, args);
            ret2._popContext();
            ret2._resolveFromSyncValue(value);
            return ret2;
          };
          Promise2.prototype._resolveFromSyncValue = function(value) {
            if (value === util.errorObj) {
              this._rejectCallback(value.e, false, true);
            } else {
              this._resolveCallback(value, true);
            }
          };
        };
      }, { "./util.js": 38 }], 21: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util.js");
          var async = _dereq_2("./async.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function spreadAdapter(val, nodeback) {
            var promise = this;
            if (!util.isArray(val))
              return successAdapter.call(promise, val, nodeback);
            var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function successAdapter(val, nodeback) {
            var promise = this;
            var receiver = promise._boundValue();
            var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function errorAdapter(reason, nodeback) {
            var promise = this;
            if (!reason) {
              var target = promise._target();
              var newReason = target._getCarriedStackTrace();
              newReason.cause = reason;
              reason = newReason;
            }
            var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
            if (typeof nodeback == "function") {
              var adapter = successAdapter;
              if (options !== void 0 && Object(options).spread) {
                adapter = spreadAdapter;
              }
              this._then(
                adapter,
                errorAdapter,
                void 0,
                this,
                nodeback
              );
            }
            return this;
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 22: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray) {
          var util = _dereq_2("./util.js");
          var async = _dereq_2("./async.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          Promise2.prototype.progressed = function(handler) {
            return this._then(void 0, void 0, handler, void 0, void 0);
          };
          Promise2.prototype._progress = function(progressValue) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._target()._progressUnchecked(progressValue);
          };
          Promise2.prototype._progressHandlerAt = function(index) {
            return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2];
          };
          Promise2.prototype._doProgressWith = function(progression) {
            var progressValue = progression.value;
            var handler = progression.handler;
            var promise = progression.promise;
            var receiver = progression.receiver;
            var ret2 = tryCatch2(handler).call(receiver, progressValue);
            if (ret2 === errorObj2) {
              if (ret2.e != null && ret2.e.name !== "StopProgressPropagation") {
                var trace = util.canAttachTrace(ret2.e) ? ret2.e : new Error(util.toString(ret2.e));
                promise._attachExtraTrace(trace);
                promise._progress(ret2.e);
              }
            } else if (ret2 instanceof Promise2) {
              ret2._then(promise._progress, null, null, promise, void 0);
            } else {
              promise._progress(ret2);
            }
          };
          Promise2.prototype._progressUnchecked = function(progressValue) {
            var len = this._length();
            var progress = this._progress;
            for (var i = 0; i < len; i++) {
              var handler = this._progressHandlerAt(i);
              var promise = this._promiseAt(i);
              if (!(promise instanceof Promise2)) {
                var receiver = this._receiverAt(i);
                if (typeof handler === "function") {
                  handler.call(receiver, progressValue, promise);
                } else if (receiver instanceof PromiseArray && !receiver._isResolved()) {
                  receiver._promiseProgressed(progressValue, promise);
                }
                continue;
              }
              if (typeof handler === "function") {
                async.invoke(this._doProgressWith, this, {
                  handler,
                  promise,
                  receiver: this._receiverAt(i),
                  value: progressValue
                });
              } else {
                async.invoke(progress, promise, progressValue);
              }
            }
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 23: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var makeSelfResolutionError = function() {
            return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n");
          };
          var reflect = function() {
            return new Promise2.PromiseInspection(this._target());
          };
          var apiRejection = function(msg) {
            return Promise2.reject(new TypeError2(msg));
          };
          var util = _dereq_2("./util.js");
          var getDomain;
          if (util.isNode) {
            getDomain = function() {
              var ret2 = process.domain;
              if (ret2 === void 0)
                ret2 = null;
              return ret2;
            };
          } else {
            getDomain = function() {
              return null;
            };
          }
          util.notEnumerableProp(Promise2, "_getDomain", getDomain);
          var UNDEFINED_BINDING = {};
          var async = _dereq_2("./async.js");
          var errors = _dereq_2("./errors.js");
          var TypeError2 = Promise2.TypeError = errors.TypeError;
          Promise2.RangeError = errors.RangeError;
          Promise2.CancellationError = errors.CancellationError;
          Promise2.TimeoutError = errors.TimeoutError;
          Promise2.OperationalError = errors.OperationalError;
          Promise2.RejectionError = errors.OperationalError;
          Promise2.AggregateError = errors.AggregateError;
          var INTERNAL = function() {
          };
          var APPLY = {};
          var NEXT_FILTER = { e: null };
          var tryConvertToPromise = _dereq_2("./thenables.js")(Promise2, INTERNAL);
          var PromiseArray = _dereq_2("./promise_array.js")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection
          );
          var CapturedTrace = _dereq_2("./captured_trace.js")();
          var isDebugging = _dereq_2("./debuggability.js")(Promise2, CapturedTrace);
          var createContext = _dereq_2("./context.js")(Promise2, CapturedTrace, isDebugging);
          var CatchFilter = _dereq_2("./catch_filter.js")(NEXT_FILTER);
          var PromiseResolver = _dereq_2("./promise_resolver.js");
          var nodebackForPromise = PromiseResolver._nodebackForPromise;
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          function Promise2(resolver) {
            if (typeof resolver !== "function") {
              throw new TypeError2("the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n");
            }
            if (this.constructor !== Promise2) {
              throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n");
            }
            this._bitField = 0;
            this._fulfillmentHandler0 = void 0;
            this._rejectionHandler0 = void 0;
            this._progressHandler0 = void 0;
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._settledValue = void 0;
            if (resolver !== INTERNAL)
              this._resolveFromResolver(resolver);
          }
          Promise2.prototype.toString = function() {
            return "[object Promise]";
          };
          Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
            var len = arguments.length;
            if (len > 1) {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (typeof item === "function") {
                  catchInstances[j++] = item;
                } else {
                  return Promise2.reject(
                    new TypeError2("Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n")
                  );
                }
              }
              catchInstances.length = j;
              fn = arguments[i];
              var catchFilter = new CatchFilter(catchInstances, fn, this);
              return this._then(
                void 0,
                catchFilter.doFilter,
                void 0,
                catchFilter,
                void 0
              );
            }
            return this._then(void 0, fn, void 0, void 0, void 0);
          };
          Promise2.prototype.reflect = function() {
            return this._then(reflect, reflect, void 0, this, void 0);
          };
          Promise2.prototype.then = function(didFulfill, didReject, didProgress) {
            if (isDebugging() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
              var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
              if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
              }
              this._warn(msg);
            }
            return this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
          };
          Promise2.prototype.done = function(didFulfill, didReject, didProgress) {
            var promise = this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
            promise._setIsFinal();
          };
          Promise2.prototype.spread = function(didFulfill, didReject) {
            return this.all()._then(didFulfill, didReject, void 0, APPLY, void 0);
          };
          Promise2.prototype.isCancellable = function() {
            return !this.isResolved() && this._cancellable();
          };
          Promise2.prototype.toJSON = function() {
            var ret2 = {
              isFulfilled: false,
              isRejected: false,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            if (this.isFulfilled()) {
              ret2.fulfillmentValue = this.value();
              ret2.isFulfilled = true;
            } else if (this.isRejected()) {
              ret2.rejectionReason = this.reason();
              ret2.isRejected = true;
            }
            return ret2;
          };
          Promise2.prototype.all = function() {
            return new PromiseArray(this).promise();
          };
          Promise2.prototype.error = function(fn) {
            return this.caught(util.originatesFromRejection, fn);
          };
          Promise2.getNewLibraryCopy = module2.exports;
          Promise2.is = function(val) {
            return val instanceof Promise2;
          };
          Promise2.fromNode = function(fn) {
            var ret2 = new Promise2(INTERNAL);
            var result2 = tryCatch2(fn)(nodebackForPromise(ret2));
            if (result2 === errorObj2) {
              ret2._rejectCallback(result2.e, true, true);
            }
            return ret2;
          };
          Promise2.all = function(promises) {
            return new PromiseArray(promises).promise();
          };
          Promise2.defer = Promise2.pending = function() {
            var promise = new Promise2(INTERNAL);
            return new PromiseResolver(promise);
          };
          Promise2.cast = function(obj2) {
            var ret2 = tryConvertToPromise(obj2);
            if (!(ret2 instanceof Promise2)) {
              var val = ret2;
              ret2 = new Promise2(INTERNAL);
              ret2._fulfillUnchecked(val);
            }
            return ret2;
          };
          Promise2.resolve = Promise2.fulfilled = Promise2.cast;
          Promise2.reject = Promise2.rejected = function(reason) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._rejectCallback(reason, true);
            return ret2;
          };
          Promise2.setScheduler = function(fn) {
            if (typeof fn !== "function")
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var prev = async._schedule;
            async._schedule = fn;
            return prev;
          };
          Promise2.prototype._then = function(didFulfill, didReject, didProgress, receiver, internalData) {
            var haveInternalData = internalData !== void 0;
            var ret2 = haveInternalData ? internalData : new Promise2(INTERNAL);
            if (!haveInternalData) {
              ret2._propagateFrom(this, 4 | 1);
              ret2._captureStackTrace();
            }
            var target = this._target();
            if (target !== this) {
              if (receiver === void 0)
                receiver = this._boundTo;
              if (!haveInternalData)
                ret2._setIsMigrated();
            }
            var callbackIndex = target._addCallbacks(
              didFulfill,
              didReject,
              didProgress,
              ret2,
              receiver,
              getDomain()
            );
            if (target._isResolved() && !target._isSettlePromisesQueued()) {
              async.invoke(
                target._settlePromiseAtPostResolution,
                target,
                callbackIndex
              );
            }
            return ret2;
          };
          Promise2.prototype._settlePromiseAtPostResolution = function(index) {
            if (this._isRejectionUnhandled())
              this._unsetRejectionIsUnhandled();
            this._settlePromiseAt(index);
          };
          Promise2.prototype._length = function() {
            return this._bitField & 131071;
          };
          Promise2.prototype._isFollowingOrFulfilledOrRejected = function() {
            return (this._bitField & 939524096) > 0;
          };
          Promise2.prototype._isFollowing = function() {
            return (this._bitField & 536870912) === 536870912;
          };
          Promise2.prototype._setLength = function(len) {
            this._bitField = this._bitField & -131072 | len & 131071;
          };
          Promise2.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 268435456;
          };
          Promise2.prototype._setRejected = function() {
            this._bitField = this._bitField | 134217728;
          };
          Promise2.prototype._setFollowing = function() {
            this._bitField = this._bitField | 536870912;
          };
          Promise2.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 33554432;
          };
          Promise2.prototype._isFinal = function() {
            return (this._bitField & 33554432) > 0;
          };
          Promise2.prototype._cancellable = function() {
            return (this._bitField & 67108864) > 0;
          };
          Promise2.prototype._setCancellable = function() {
            this._bitField = this._bitField | 67108864;
          };
          Promise2.prototype._unsetCancellable = function() {
            this._bitField = this._bitField & ~67108864;
          };
          Promise2.prototype._setIsMigrated = function() {
            this._bitField = this._bitField | 4194304;
          };
          Promise2.prototype._unsetIsMigrated = function() {
            this._bitField = this._bitField & ~4194304;
          };
          Promise2.prototype._isMigrated = function() {
            return (this._bitField & 4194304) > 0;
          };
          Promise2.prototype._receiverAt = function(index) {
            var ret2 = index === 0 ? this._receiver0 : this[index * 5 - 5 + 4];
            if (ret2 === UNDEFINED_BINDING) {
              return void 0;
            } else if (ret2 === void 0 && this._isBound()) {
              return this._boundValue();
            }
            return ret2;
          };
          Promise2.prototype._promiseAt = function(index) {
            return index === 0 ? this._promise0 : this[index * 5 - 5 + 3];
          };
          Promise2.prototype._fulfillmentHandlerAt = function(index) {
            return index === 0 ? this._fulfillmentHandler0 : this[index * 5 - 5 + 0];
          };
          Promise2.prototype._rejectionHandlerAt = function(index) {
            return index === 0 ? this._rejectionHandler0 : this[index * 5 - 5 + 1];
          };
          Promise2.prototype._boundValue = function() {
            var ret2 = this._boundTo;
            if (ret2 !== void 0) {
              if (ret2 instanceof Promise2) {
                if (ret2.isFulfilled()) {
                  return ret2.value();
                } else {
                  return void 0;
                }
              }
            }
            return ret2;
          };
          Promise2.prototype._migrateCallbacks = function(follower, index) {
            var fulfill = follower._fulfillmentHandlerAt(index);
            var reject2 = follower._rejectionHandlerAt(index);
            var progress = follower._progressHandlerAt(index);
            var promise = follower._promiseAt(index);
            var receiver = follower._receiverAt(index);
            if (promise instanceof Promise2)
              promise._setIsMigrated();
            if (receiver === void 0)
              receiver = UNDEFINED_BINDING;
            this._addCallbacks(fulfill, reject2, progress, promise, receiver, null);
          };
          Promise2.prototype._addCallbacks = function(fulfill, reject2, progress, promise, receiver, domain) {
            var index = this._length();
            if (index >= 131071 - 5) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promise;
              if (receiver !== void 0)
                this._receiver0 = receiver;
              if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill);
              }
              if (typeof reject2 === "function") {
                this._rejectionHandler0 = domain === null ? reject2 : domain.bind(reject2);
              }
              if (typeof progress === "function") {
                this._progressHandler0 = domain === null ? progress : domain.bind(progress);
              }
            } else {
              var base = index * 5 - 5;
              this[base + 3] = promise;
              this[base + 4] = receiver;
              if (typeof fulfill === "function") {
                this[base + 0] = domain === null ? fulfill : domain.bind(fulfill);
              }
              if (typeof reject2 === "function") {
                this[base + 1] = domain === null ? reject2 : domain.bind(reject2);
              }
              if (typeof progress === "function") {
                this[base + 2] = domain === null ? progress : domain.bind(progress);
              }
            }
            this._setLength(index + 1);
            return index;
          };
          Promise2.prototype._setProxyHandlers = function(receiver, promiseSlotValue) {
            var index = this._length();
            if (index >= 131071 - 5) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promiseSlotValue;
              this._receiver0 = receiver;
            } else {
              var base = index * 5 - 5;
              this[base + 3] = promiseSlotValue;
              this[base + 4] = receiver;
            }
            this._setLength(index + 1);
          };
          Promise2.prototype._proxyPromiseArray = function(promiseArray, index) {
            this._setProxyHandlers(promiseArray, index);
          };
          Promise2.prototype._resolveCallback = function(value, shouldBind) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            if (value === this)
              return this._rejectCallback(makeSelfResolutionError(), false, true);
            var maybePromise = tryConvertToPromise(value, this);
            if (!(maybePromise instanceof Promise2))
              return this._fulfill(value);
            var propagationFlags = 1 | (shouldBind ? 4 : 0);
            this._propagateFrom(maybePromise, propagationFlags);
            var promise = maybePromise._target();
            if (promise._isPending()) {
              var len = this._length();
              for (var i = 0; i < len; ++i) {
                promise._migrateCallbacks(this, i);
              }
              this._setFollowing();
              this._setLength(0);
              this._setFollowee(promise);
            } else if (promise._isFulfilled()) {
              this._fulfillUnchecked(promise._value());
            } else {
              this._rejectUnchecked(
                promise._reason(),
                promise._getCarriedStackTrace()
              );
            }
          };
          Promise2.prototype._rejectCallback = function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
            if (!shouldNotMarkOriginatingFromRejection) {
              util.markAsOriginatingFromRejection(reason);
            }
            var trace = util.ensureErrorObject(reason);
            var hasStack = trace === reason;
            this._attachExtraTrace(trace, synchronous ? hasStack : false);
            this._reject(reason, hasStack ? void 0 : trace);
          };
          Promise2.prototype._resolveFromResolver = function(resolver) {
            var promise = this;
            this._captureStackTrace();
            this._pushContext();
            var synchronous = true;
            var r = tryCatch2(resolver)(function(value) {
              if (promise === null)
                return;
              promise._resolveCallback(value);
              promise = null;
            }, function(reason) {
              if (promise === null)
                return;
              promise._rejectCallback(reason, synchronous);
              promise = null;
            });
            synchronous = false;
            this._popContext();
            if (r !== void 0 && r === errorObj2 && promise !== null) {
              promise._rejectCallback(r.e, true, true);
              promise = null;
            }
          };
          Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
            if (promise._isRejected())
              return;
            promise._pushContext();
            var x;
            if (receiver === APPLY && !this._isRejected()) {
              x = tryCatch2(handler).apply(this._boundValue(), value);
            } else {
              x = tryCatch2(handler).call(receiver, value);
            }
            promise._popContext();
            if (x === errorObj2 || x === promise || x === NEXT_FILTER) {
              var err = x === promise ? makeSelfResolutionError() : x.e;
              promise._rejectCallback(err, false, true);
            } else {
              promise._resolveCallback(x);
            }
          };
          Promise2.prototype._target = function() {
            var ret2 = this;
            while (ret2._isFollowing())
              ret2 = ret2._followee();
            return ret2;
          };
          Promise2.prototype._followee = function() {
            return this._rejectionHandler0;
          };
          Promise2.prototype._setFollowee = function(promise) {
            this._rejectionHandler0 = promise;
          };
          Promise2.prototype._cleanValues = function() {
            if (this._cancellable()) {
              this._cancellationParent = void 0;
            }
          };
          Promise2.prototype._propagateFrom = function(parent, flags) {
            if ((flags & 1) > 0 && parent._cancellable()) {
              this._setCancellable();
              this._cancellationParent = parent;
            }
            if ((flags & 4) > 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          };
          Promise2.prototype._fulfill = function(value) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._fulfillUnchecked(value);
          };
          Promise2.prototype._reject = function(reason, carriedStackTrace) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._rejectUnchecked(reason, carriedStackTrace);
          };
          Promise2.prototype._settlePromiseAt = function(index) {
            var promise = this._promiseAt(index);
            var isPromise = promise instanceof Promise2;
            if (isPromise && promise._isMigrated()) {
              promise._unsetIsMigrated();
              return async.invoke(this._settlePromiseAt, this, index);
            }
            var handler = this._isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
            var carriedStackTrace = this._isCarryingStackTrace() ? this._getCarriedStackTrace() : void 0;
            var value = this._settledValue;
            var receiver = this._receiverAt(index);
            this._clearCallbackDataAtIndex(index);
            if (typeof handler === "function") {
              if (!isPromise) {
                handler.call(receiver, value, promise);
              } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
              }
            } else if (receiver instanceof PromiseArray) {
              if (!receiver._isResolved()) {
                if (this._isFulfilled()) {
                  receiver._promiseFulfilled(value, promise);
                } else {
                  receiver._promiseRejected(value, promise);
                }
              }
            } else if (isPromise) {
              if (this._isFulfilled()) {
                promise._fulfill(value);
              } else {
                promise._reject(value, carriedStackTrace);
              }
            }
            if (index >= 4 && (index & 31) === 4)
              async.invokeLater(this._setLength, this, 0);
          };
          Promise2.prototype._clearCallbackDataAtIndex = function(index) {
            if (index === 0) {
              if (!this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = void 0;
              }
              this._rejectionHandler0 = this._progressHandler0 = this._receiver0 = this._promise0 = void 0;
            } else {
              var base = index * 5 - 5;
              this[base + 3] = this[base + 4] = this[base + 0] = this[base + 1] = this[base + 2] = void 0;
            }
          };
          Promise2.prototype._isSettlePromisesQueued = function() {
            return (this._bitField & -1073741824) === -1073741824;
          };
          Promise2.prototype._setSettlePromisesQueued = function() {
            this._bitField = this._bitField | -1073741824;
          };
          Promise2.prototype._unsetSettlePromisesQueued = function() {
            this._bitField = this._bitField & ~-1073741824;
          };
          Promise2.prototype._queueSettlePromises = function() {
            async.settlePromises(this);
            this._setSettlePromisesQueued();
          };
          Promise2.prototype._fulfillUnchecked = function(value) {
            if (value === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._rejectUnchecked(err, void 0);
            }
            this._setFulfilled();
            this._settledValue = value;
            this._cleanValues();
            if (this._length() > 0) {
              this._queueSettlePromises();
            }
          };
          Promise2.prototype._rejectUncheckedCheckError = function(reason) {
            var trace = util.ensureErrorObject(reason);
            this._rejectUnchecked(reason, trace === reason ? void 0 : trace);
          };
          Promise2.prototype._rejectUnchecked = function(reason, trace) {
            if (reason === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._rejectUnchecked(err);
            }
            this._setRejected();
            this._settledValue = reason;
            this._cleanValues();
            if (this._isFinal()) {
              async.throwLater(function(e) {
                if ("stack" in e) {
                  async.invokeFirst(
                    CapturedTrace.unhandledRejection,
                    void 0,
                    e
                  );
                }
                throw e;
              }, trace === void 0 ? reason : trace);
              return;
            }
            if (trace !== void 0 && trace !== reason) {
              this._setCarriedStackTrace(trace);
            }
            if (this._length() > 0) {
              this._queueSettlePromises();
            } else {
              this._ensurePossibleRejectionHandled();
            }
          };
          Promise2.prototype._settlePromises = function() {
            this._unsetSettlePromisesQueued();
            var len = this._length();
            for (var i = 0; i < len; i++) {
              this._settlePromiseAt(i);
            }
          };
          util.notEnumerableProp(
            Promise2,
            "_makeSelfResolutionError",
            makeSelfResolutionError
          );
          _dereq_2("./progress.js")(Promise2, PromiseArray);
          _dereq_2("./method.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./bind.js")(Promise2, INTERNAL, tryConvertToPromise);
          _dereq_2("./finally.js")(Promise2, NEXT_FILTER, tryConvertToPromise);
          _dereq_2("./direct_resolve.js")(Promise2);
          _dereq_2("./synchronous_inspection.js")(Promise2);
          _dereq_2("./join.js")(Promise2, PromiseArray, tryConvertToPromise, INTERNAL);
          Promise2.version = "2.11.0";
          Promise2.Promise = Promise2;
          _dereq_2("./map.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
          _dereq_2("./cancel.js")(Promise2);
          _dereq_2("./using.js")(Promise2, apiRejection, tryConvertToPromise, createContext);
          _dereq_2("./generators.js")(Promise2, apiRejection, INTERNAL, tryConvertToPromise);
          _dereq_2("./nodeify.js")(Promise2);
          _dereq_2("./call_get.js")(Promise2);
          _dereq_2("./props.js")(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
          _dereq_2("./race.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./reduce.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
          _dereq_2("./settle.js")(Promise2, PromiseArray);
          _dereq_2("./some.js")(Promise2, PromiseArray, apiRejection);
          _dereq_2("./promisify.js")(Promise2, INTERNAL);
          _dereq_2("./any.js")(Promise2);
          _dereq_2("./each.js")(Promise2, INTERNAL);
          _dereq_2("./timers.js")(Promise2, INTERNAL);
          _dereq_2("./filter.js")(Promise2, INTERNAL);
          util.toFastProperties(Promise2);
          util.toFastProperties(Promise2.prototype);
          function fillTypes(value) {
            var p = new Promise2(INTERNAL);
            p._fulfillmentHandler0 = value;
            p._rejectionHandler0 = value;
            p._progressHandler0 = value;
            p._promise0 = value;
            p._receiver0 = value;
            p._settledValue = value;
          }
          fillTypes({ a: 1 });
          fillTypes({ b: 2 });
          fillTypes({ c: 3 });
          fillTypes(1);
          fillTypes(function() {
          });
          fillTypes(void 0);
          fillTypes(false);
          fillTypes(new Promise2(INTERNAL));
          CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
          return Promise2;
        };
      }, { "./any.js": 1, "./async.js": 2, "./bind.js": 3, "./call_get.js": 5, "./cancel.js": 6, "./captured_trace.js": 7, "./catch_filter.js": 8, "./context.js": 9, "./debuggability.js": 10, "./direct_resolve.js": 11, "./each.js": 12, "./errors.js": 13, "./filter.js": 15, "./finally.js": 16, "./generators.js": 17, "./join.js": 18, "./map.js": 19, "./method.js": 20, "./nodeify.js": 21, "./progress.js": 22, "./promise_array.js": 24, "./promise_resolver.js": 25, "./promisify.js": 26, "./props.js": 27, "./race.js": 29, "./reduce.js": 30, "./settle.js": 32, "./some.js": 33, "./synchronous_inspection.js": 34, "./thenables.js": 35, "./timers.js": 36, "./using.js": 37, "./util.js": 38 }], 24: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var isArray = util.isArray;
          function toResolutionValue(val) {
            switch (val) {
              case -2:
                return [];
              case -3:
                return {};
            }
          }
          function PromiseArray(values2) {
            var promise = this._promise = new Promise2(INTERNAL);
            var parent;
            if (values2 instanceof Promise2) {
              parent = values2;
              promise._propagateFrom(parent, 1 | 4);
            }
            this._values = values2;
            this._length = 0;
            this._totalResolved = 0;
            this._init(void 0, -2);
          }
          PromiseArray.prototype.length = function() {
            return this._length;
          };
          PromiseArray.prototype.promise = function() {
            return this._promise;
          };
          PromiseArray.prototype._init = function init(_3, resolveValueIfEmpty) {
            var values2 = tryConvertToPromise(this._values, this._promise);
            if (values2 instanceof Promise2) {
              values2 = values2._target();
              this._values = values2;
              if (values2._isFulfilled()) {
                values2 = values2._value();
                if (!isArray(values2)) {
                  var err = new Promise2.TypeError("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n");
                  this.__hardReject__(err);
                  return;
                }
              } else if (values2._isPending()) {
                values2._then(
                  init,
                  this._reject,
                  void 0,
                  this,
                  resolveValueIfEmpty
                );
                return;
              } else {
                this._reject(values2._reason());
                return;
              }
            } else if (!isArray(values2)) {
              this._promise._reject(apiRejection("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n")._reason());
              return;
            }
            if (values2.length === 0) {
              if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
              } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
              }
              return;
            }
            var len = this.getActualLength(values2.length);
            this._length = len;
            this._values = this.shouldCopyValues() ? new Array(len) : this._values;
            var promise = this._promise;
            for (var i = 0; i < len; ++i) {
              var isResolved = this._isResolved();
              var maybePromise = tryConvertToPromise(values2[i], promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (isResolved) {
                  maybePromise._ignoreRejections();
                } else if (maybePromise._isPending()) {
                  maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                  this._promiseFulfilled(maybePromise._value(), i);
                } else {
                  this._promiseRejected(maybePromise._reason(), i);
                }
              } else if (!isResolved) {
                this._promiseFulfilled(maybePromise, i);
              }
            }
          };
          PromiseArray.prototype._isResolved = function() {
            return this._values === null;
          };
          PromiseArray.prototype._resolve = function(value) {
            this._values = null;
            this._promise._fulfill(value);
          };
          PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function(reason) {
            this._values = null;
            this._promise._rejectCallback(reason, false, true);
          };
          PromiseArray.prototype._promiseProgressed = function(progressValue, index) {
            this._promise._progress({
              index,
              value: progressValue
            });
          };
          PromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
            }
          };
          PromiseArray.prototype._promiseRejected = function(reason, index) {
            this._totalResolved++;
            this._reject(reason);
          };
          PromiseArray.prototype.shouldCopyValues = function() {
            return true;
          };
          PromiseArray.prototype.getActualLength = function(len) {
            return len;
          };
          return PromiseArray;
        };
      }, { "./util.js": 38 }], 25: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util.js");
        var maybeWrapAsError2 = util.maybeWrapAsError;
        var errors = _dereq_2("./errors.js");
        var TimeoutError = errors.TimeoutError;
        var OperationalError = errors.OperationalError;
        var haveGetters2 = util.haveGetters;
        var es52 = _dereq_2("./es5.js");
        function isUntypedError(obj2) {
          return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
        }
        var rErrorKey = /^(?:name|message|stack|cause)$/;
        function wrapAsOperationalError(obj2) {
          var ret2;
          if (isUntypedError(obj2)) {
            ret2 = new OperationalError(obj2);
            ret2.name = obj2.name;
            ret2.message = obj2.message;
            ret2.stack = obj2.stack;
            var keys2 = es52.keys(obj2);
            for (var i = 0; i < keys2.length; ++i) {
              var key = keys2[i];
              if (!rErrorKey.test(key)) {
                ret2[key] = obj2[key];
              }
            }
            return ret2;
          }
          util.markAsOriginatingFromRejection(obj2);
          return obj2;
        }
        function nodebackForPromise(promise) {
          return function(err, value) {
            if (promise === null)
              return;
            if (err) {
              var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
              promise._attachExtraTrace(wrapped);
              promise._reject(wrapped);
            } else if (arguments.length > 2) {
              var $_len = arguments.length;
              var args = new Array($_len - 1);
              for (var $_i = 1; $_i < $_len; ++$_i) {
                args[$_i - 1] = arguments[$_i];
              }
              promise._fulfill(args);
            } else {
              promise._fulfill(value);
            }
            promise = null;
          };
        }
        var PromiseResolver;
        if (!haveGetters2) {
          PromiseResolver = function(promise) {
            this.promise = promise;
            this.asCallback = nodebackForPromise(promise);
            this.callback = this.asCallback;
          };
        } else {
          PromiseResolver = function(promise) {
            this.promise = promise;
          };
        }
        if (haveGetters2) {
          var prop = {
            get: function() {
              return nodebackForPromise(this.promise);
            }
          };
          es52.defineProperty(PromiseResolver.prototype, "asCallback", prop);
          es52.defineProperty(PromiseResolver.prototype, "callback", prop);
        }
        PromiseResolver._nodebackForPromise = nodebackForPromise;
        PromiseResolver.prototype.toString = function() {
          return "[object PromiseResolver]";
        };
        PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function(value) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._resolveCallback(value);
        };
        PromiseResolver.prototype.reject = function(reason) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._rejectCallback(reason);
        };
        PromiseResolver.prototype.progress = function(value) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._progress(value);
        };
        PromiseResolver.prototype.cancel = function(err) {
          this.promise.cancel(err);
        };
        PromiseResolver.prototype.timeout = function() {
          this.reject(new TimeoutError("timeout"));
        };
        PromiseResolver.prototype.isResolved = function() {
          return this.promise.isResolved();
        };
        PromiseResolver.prototype.toJSON = function() {
          return this.promise.toJSON();
        };
        module2.exports = PromiseResolver;
      }, { "./errors.js": 13, "./es5.js": 14, "./util.js": 38 }], 26: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var THIS = {};
          var util = _dereq_2("./util.js");
          var nodebackForPromise = _dereq_2("./promise_resolver.js")._nodebackForPromise;
          var withAppended2 = util.withAppended;
          var maybeWrapAsError2 = util.maybeWrapAsError;
          var canEvaluate2 = util.canEvaluate;
          var TypeError2 = _dereq_2("./errors").TypeError;
          var defaultSuffix = "Async";
          var defaultPromisified = { __isPromisified__: true };
          var noCopyProps = [
            "arity",
            "length",
            "name",
            "arguments",
            "caller",
            "callee",
            "prototype",
            "__isPromisified__"
          ];
          var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
          var defaultFilter = function(name) {
            return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
          };
          function propsFilter(key) {
            return !noCopyPropsPattern.test(key);
          }
          function isPromisified(fn) {
            try {
              return fn.__isPromisified__ === true;
            } catch (e) {
              return false;
            }
          }
          function hasPromisified(obj2, key, suffix) {
            var val = util.getDataPropertyOrDefault(
              obj2,
              key + suffix,
              defaultPromisified
            );
            return val ? isPromisified(val) : false;
          }
          function checkValid(ret2, suffix, suffixRegexp) {
            for (var i = 0; i < ret2.length; i += 2) {
              var key = ret2[i];
              if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret2.length; j += 2) {
                  if (ret2[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n".replace("%s", suffix));
                  }
                }
              }
            }
          }
          function promisifiableMethods(obj2, suffix, suffixRegexp, filter2) {
            var keys2 = util.inheritedDataKeys(obj2);
            var ret2 = [];
            for (var i = 0; i < keys2.length; ++i) {
              var key = keys2[i];
              var value = obj2[key];
              var passesDefaultFilter = filter2 === defaultFilter ? true : defaultFilter(key, value, obj2);
              if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter2(key, value, obj2, passesDefaultFilter)) {
                ret2.push(key, value);
              }
            }
            checkValid(ret2, suffix, suffixRegexp);
            return ret2;
          }
          var escapeIdentRegex = function(str) {
            return str.replace(/([$])/, "\\$");
          };
          var makeNodePromisifiedEval;
          if (false) {
            var switchCaseArgumentOrder = function(likelyArgumentCount) {
              var ret2 = [likelyArgumentCount];
              var min2 = Math.max(0, likelyArgumentCount - 1 - 3);
              for (var i = likelyArgumentCount - 1; i >= min2; --i) {
                ret2.push(i);
              }
              for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret2.push(i);
              }
              return ret2;
            };
            var argumentSequence = function(argumentCount) {
              return util.filledRange(argumentCount, "_arg", "");
            };
            var parameterDeclaration = function(parameterCount2) {
              return util.filledRange(
                Math.max(parameterCount2, 3),
                "_arg",
                ""
              );
            };
            var parameterCount = function(fn) {
              if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
              }
              return 0;
            };
            makeNodePromisifiedEval = function(callback, receiver, originalName, fn) {
              var newParameterCount = Math.max(0, parameterCount(fn) - 1);
              var argumentOrder = switchCaseArgumentOrder(newParameterCount);
              var shouldProxyThis = typeof callback === "string" || receiver === THIS;
              function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret2;
                if (shouldProxyThis) {
                  ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                  ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret2.replace("{{args}}", args).replace(", ", comma);
              }
              function generateArgumentSwitchCase() {
                var ret2 = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                  ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }
                ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret2;
              }
              var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
              return new Function(
                "Promise",
                "fn",
                "receiver",
                "withAppended",
                "maybeWrapAsError",
                "nodebackForPromise",
                "tryCatch",
                "errorObj",
                "notEnumerableProp",
                "INTERNAL",
                "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ".replace("Parameters", parameterDeclaration(newParameterCount)).replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode)
              )(
                Promise2,
                fn,
                receiver,
                withAppended2,
                maybeWrapAsError2,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
              );
            };
          }
          function makeNodePromisifiedClosure(callback, receiver, _3, fn) {
            var defaultThis = /* @__PURE__ */ function() {
              return this;
            }();
            var method = callback;
            if (typeof method === "string") {
              callback = fn;
            }
            function promisified() {
              var _receiver = receiver;
              if (receiver === THIS)
                _receiver = this;
              var promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
              var cb2 = typeof method === "string" && this !== defaultThis ? this[method] : callback;
              var fn2 = nodebackForPromise(promise);
              try {
                cb2.apply(_receiver, withAppended2(arguments, fn2));
              } catch (e) {
                promise._rejectCallback(maybeWrapAsError2(e), true, true);
              }
              return promise;
            }
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            return promisified;
          }
          var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
          function promisifyAll(obj2, suffix, filter2, promisifier) {
            var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
            var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter2);
            for (var i = 0, len = methods.length; i < len; i += 2) {
              var key = methods[i];
              var fn = methods[i + 1];
              var promisifiedKey = key + suffix;
              if (promisifier === makeNodePromisified) {
                obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix);
              } else {
                var promisified = promisifier(fn, function() {
                  return makeNodePromisified(key, THIS, key, fn, suffix);
                });
                util.notEnumerableProp(promisified, "__isPromisified__", true);
                obj2[promisifiedKey] = promisified;
              }
            }
            util.toFastProperties(obj2);
            return obj2;
          }
          function promisify(callback, receiver) {
            return makeNodePromisified(callback, receiver, void 0, callback);
          }
          Promise2.promisify = function(fn, receiver) {
            if (typeof fn !== "function") {
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            if (isPromisified(fn)) {
              return fn;
            }
            var ret2 = promisify(fn, arguments.length < 2 ? THIS : receiver);
            util.copyDescriptors(fn, ret2, propsFilter);
            return ret2;
          };
          Promise2.promisifyAll = function(target, options) {
            if (typeof target !== "function" && typeof target !== "object") {
              throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n");
            }
            options = Object(options);
            var suffix = options.suffix;
            if (typeof suffix !== "string")
              suffix = defaultSuffix;
            var filter2 = options.filter;
            if (typeof filter2 !== "function")
              filter2 = defaultFilter;
            var promisifier = options.promisifier;
            if (typeof promisifier !== "function")
              promisifier = makeNodePromisified;
            if (!util.isIdentifier(suffix)) {
              throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n");
            }
            var keys2 = util.inheritedDataKeys(target);
            for (var i = 0; i < keys2.length; ++i) {
              var value = target[keys2[i]];
              if (keys2[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter2, promisifier);
                promisifyAll(value, suffix, filter2, promisifier);
              }
            }
            return promisifyAll(target, suffix, filter2, promisifier);
          };
        };
      }, { "./errors": 13, "./promise_resolver.js": 25, "./util.js": 38 }], 27: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var isObject3 = util.isObject;
          var es52 = _dereq_2("./es5.js");
          function PropertiesPromiseArray(obj2) {
            var keys2 = es52.keys(obj2);
            var len = keys2.length;
            var values2 = new Array(len * 2);
            for (var i = 0; i < len; ++i) {
              var key = keys2[i];
              values2[i] = obj2[key];
              values2[i + len] = key;
            }
            this.constructor$(values2);
          }
          util.inherits(PropertiesPromiseArray, PromiseArray);
          PropertiesPromiseArray.prototype._init = function() {
            this._init$(void 0, -3);
          };
          PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              var val = {};
              var keyOffset = this.length();
              for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
              }
              this._resolve(val);
            }
          };
          PropertiesPromiseArray.prototype._promiseProgressed = function(value, index) {
            this._promise._progress({
              key: this._values[index + this.length()],
              value
            });
          };
          PropertiesPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          PropertiesPromiseArray.prototype.getActualLength = function(len) {
            return len >> 1;
          };
          function props(promises) {
            var ret2;
            var castValue = tryConvertToPromise(promises);
            if (!isObject3(castValue)) {
              return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n");
            } else if (castValue instanceof Promise2) {
              ret2 = castValue._then(
                Promise2.props,
                void 0,
                void 0,
                void 0,
                void 0
              );
            } else {
              ret2 = new PropertiesPromiseArray(castValue).promise();
            }
            if (castValue instanceof Promise2) {
              ret2._propagateFrom(castValue, 4);
            }
            return ret2;
          }
          Promise2.prototype.props = function() {
            return props(this);
          };
          Promise2.props = function(promises) {
            return props(promises);
          };
        };
      }, { "./es5.js": 14, "./util.js": 38 }], 28: [function(_dereq_2, module2, exports2) {
        "use strict";
        function arrayMove(src, srcIndex, dst, dstIndex, len) {
          for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
          }
        }
        function Queue(capacity) {
          this._capacity = capacity;
          this._length = 0;
          this._front = 0;
        }
        Queue.prototype._willBeOverCapacity = function(size2) {
          return this._capacity < size2;
        };
        Queue.prototype._pushOne = function(arg) {
          var length = this.length();
          this._checkCapacity(length + 1);
          var i = this._front + length & this._capacity - 1;
          this[i] = arg;
          this._length = length + 1;
        };
        Queue.prototype._unshiftOne = function(value) {
          var capacity = this._capacity;
          this._checkCapacity(this.length() + 1);
          var front = this._front;
          var i = (front - 1 & capacity - 1 ^ capacity) - capacity;
          this[i] = value;
          this._front = i;
          this._length = this.length() + 1;
        };
        Queue.prototype.unshift = function(fn, receiver, arg) {
          this._unshiftOne(arg);
          this._unshiftOne(receiver);
          this._unshiftOne(fn);
        };
        Queue.prototype.push = function(fn, receiver, arg) {
          var length = this.length() + 3;
          if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver);
            this._pushOne(arg);
            return;
          }
          var j = this._front + length - 3;
          this._checkCapacity(length);
          var wrapMask = this._capacity - 1;
          this[j + 0 & wrapMask] = fn;
          this[j + 1 & wrapMask] = receiver;
          this[j + 2 & wrapMask] = arg;
          this._length = length;
        };
        Queue.prototype.shift = function() {
          var front = this._front, ret2 = this[front];
          this[front] = void 0;
          this._front = front + 1 & this._capacity - 1;
          this._length--;
          return ret2;
        };
        Queue.prototype.length = function() {
          return this._length;
        };
        Queue.prototype._checkCapacity = function(size2) {
          if (this._capacity < size2) {
            this._resizeTo(this._capacity << 1);
          }
        };
        Queue.prototype._resizeTo = function(capacity) {
          var oldCapacity = this._capacity;
          this._capacity = capacity;
          var front = this._front;
          var length = this._length;
          var moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this, 0, this, oldCapacity, moveItemsCount);
        };
        module2.exports = Queue;
      }, {}], 29: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var isArray = _dereq_2("./util.js").isArray;
          var raceLater = function(promise) {
            return promise.then(function(array) {
              return race(array, promise);
            });
          };
          function race(promises, parent) {
            var maybePromise = tryConvertToPromise(promises);
            if (maybePromise instanceof Promise2) {
              return raceLater(maybePromise);
            } else if (!isArray(promises)) {
              return apiRejection("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n");
            }
            var ret2 = new Promise2(INTERNAL);
            if (parent !== void 0) {
              ret2._propagateFrom(parent, 4 | 1);
            }
            var fulfill = ret2._fulfill;
            var reject2 = ret2._reject;
            for (var i = 0, len = promises.length; i < len; ++i) {
              var val = promises[i];
              if (val === void 0 && !(i in promises)) {
                continue;
              }
              Promise2.cast(val)._then(fulfill, reject2, void 0, ret2, null);
            }
            return ret2;
          }
          Promise2.race = function(promises) {
            return race(promises, void 0);
          };
          Promise2.prototype.race = function() {
            return race(this, void 0);
          };
        };
      }, { "./util.js": 38 }], 30: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function ReductionPromiseArray(promises, fn, accum, _each) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            this._preservedValues = _each === INTERNAL ? [] : null;
            this._zerothIsAccum = accum === void 0;
            this._gotAccum = false;
            this._reducingIndex = this._zerothIsAccum ? 1 : 0;
            this._valuesPhase = void 0;
            var maybePromise = tryConvertToPromise(accum, this._promise);
            var rejected = false;
            var isPromise = maybePromise instanceof Promise2;
            if (isPromise) {
              maybePromise = maybePromise._target();
              if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, -1);
              } else if (maybePromise._isFulfilled()) {
                accum = maybePromise._value();
                this._gotAccum = true;
              } else {
                this._reject(maybePromise._reason());
                rejected = true;
              }
            }
            if (!(isPromise || this._zerothIsAccum))
              this._gotAccum = true;
            var domain = getDomain();
            this._callback = domain === null ? fn : domain.bind(fn);
            this._accum = accum;
            if (!rejected)
              async.invoke(init, this, void 0);
          }
          function init() {
            this._init$(void 0, -5);
          }
          util.inherits(ReductionPromiseArray, PromiseArray);
          ReductionPromiseArray.prototype._init = function() {
          };
          ReductionPromiseArray.prototype._resolveEmptyArray = function() {
            if (this._gotAccum || this._zerothIsAccum) {
              this._resolve(this._preservedValues !== null ? [] : this._accum);
            }
          };
          ReductionPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values2 = this._values;
            values2[index] = value;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var isEach = preservedValues !== null;
            var gotAccum = this._gotAccum;
            var valuesPhase = this._valuesPhase;
            var valuesPhaseIndex;
            if (!valuesPhase) {
              valuesPhase = this._valuesPhase = new Array(length);
              for (valuesPhaseIndex = 0; valuesPhaseIndex < length; ++valuesPhaseIndex) {
                valuesPhase[valuesPhaseIndex] = 0;
              }
            }
            valuesPhaseIndex = valuesPhase[index];
            if (index === 0 && this._zerothIsAccum) {
              this._accum = value;
              this._gotAccum = gotAccum = true;
              valuesPhase[index] = valuesPhaseIndex === 0 ? 1 : 2;
            } else if (index === -1) {
              this._accum = value;
              this._gotAccum = gotAccum = true;
            } else {
              if (valuesPhaseIndex === 0) {
                valuesPhase[index] = 1;
              } else {
                valuesPhase[index] = 2;
                this._accum = value;
              }
            }
            if (!gotAccum)
              return;
            var callback = this._callback;
            var receiver = this._promise._boundValue();
            var ret2;
            for (var i = this._reducingIndex; i < length; ++i) {
              valuesPhaseIndex = valuesPhase[i];
              if (valuesPhaseIndex === 2) {
                this._reducingIndex = i + 1;
                continue;
              }
              if (valuesPhaseIndex !== 1)
                return;
              value = values2[i];
              this._promise._pushContext();
              if (isEach) {
                preservedValues.push(value);
                ret2 = tryCatch2(callback).call(receiver, value, i, length);
              } else {
                ret2 = tryCatch2(callback).call(receiver, this._accum, value, i, length);
              }
              this._promise._popContext();
              if (ret2 === errorObj2)
                return this._reject(ret2.e);
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  valuesPhase[i] = 4;
                  return maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                  ret2 = maybePromise._value();
                } else {
                  return this._reject(maybePromise._reason());
                }
              }
              this._reducingIndex = i + 1;
              this._accum = ret2;
            }
            this._resolve(isEach ? preservedValues : this._accum);
          };
          function reduce(promises, fn, initialValue, _each) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
            return array.promise();
          }
          Promise2.prototype.reduce = function(fn, initialValue) {
            return reduce(this, fn, initialValue, null);
          };
          Promise2.reduce = function(promises, fn, initialValue, _each) {
            return reduce(promises, fn, initialValue, _each);
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 31: [function(_dereq_2, module2, exports2) {
        "use strict";
        var schedule;
        var util = _dereq_2("./util");
        var noAsyncScheduler = function() {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/m3OTXk\n");
        };
        if (util.isNode && typeof MutationObserver === "undefined") {
          var GlobalSetImmediate = global.setImmediate;
          var ProcessNextTick = process.nextTick;
          schedule = util.isRecentNode ? function(fn) {
            GlobalSetImmediate.call(global, fn);
          } : function(fn) {
            ProcessNextTick.call(process, fn);
          };
        } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && window.navigator.standalone)) {
          schedule = function(fn) {
            var div = document.createElement("div");
            var observer = new MutationObserver(fn);
            observer.observe(div, { attributes: true });
            return function() {
              div.classList.toggle("foo");
            };
          };
          schedule.isStatic = true;
        } else if (typeof setImmediate !== "undefined") {
          schedule = function(fn) {
            setImmediate(fn);
          };
        } else if (typeof setTimeout !== "undefined") {
          schedule = function(fn) {
            setTimeout(fn, 0);
          };
        } else {
          schedule = noAsyncScheduler;
        }
        module2.exports = schedule;
      }, { "./util": 38 }], 32: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray) {
          var PromiseInspection = Promise2.PromiseInspection;
          var util = _dereq_2("./util.js");
          function SettledPromiseArray(values2) {
            this.constructor$(values2);
          }
          util.inherits(SettledPromiseArray, PromiseArray);
          SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
            this._values[index] = inspection;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
            }
          };
          SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 268435456;
            ret2._settledValue = value;
            this._promiseResolved(index, ret2);
          };
          SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 134217728;
            ret2._settledValue = reason;
            this._promiseResolved(index, ret2);
          };
          Promise2.settle = function(promises) {
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.prototype.settle = function() {
            return new SettledPromiseArray(this).promise();
          };
        };
      }, { "./util.js": 38 }], 33: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection) {
          var util = _dereq_2("./util.js");
          var RangeError2 = _dereq_2("./errors.js").RangeError;
          var AggregateError = _dereq_2("./errors.js").AggregateError;
          var isArray = util.isArray;
          function SomePromiseArray(values2) {
            this.constructor$(values2);
            this._howMany = 0;
            this._unwrap = false;
            this._initialized = false;
          }
          util.inherits(SomePromiseArray, PromiseArray);
          SomePromiseArray.prototype._init = function() {
            if (!this._initialized) {
              return;
            }
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var isArrayResolved = isArray(this._values);
            if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
              this._reject(this._getRangeError(this.length()));
            }
          };
          SomePromiseArray.prototype.init = function() {
            this._initialized = true;
            this._init();
          };
          SomePromiseArray.prototype.setUnwrap = function() {
            this._unwrap = true;
          };
          SomePromiseArray.prototype.howMany = function() {
            return this._howMany;
          };
          SomePromiseArray.prototype.setHowMany = function(count) {
            this._howMany = count;
          };
          SomePromiseArray.prototype._promiseFulfilled = function(value) {
            this._addFulfilled(value);
            if (this._fulfilled() === this.howMany()) {
              this._values.length = this.howMany();
              if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
              } else {
                this._resolve(this._values);
              }
            }
          };
          SomePromiseArray.prototype._promiseRejected = function(reason) {
            this._addRejected(reason);
            if (this.howMany() > this._canPossiblyFulfill()) {
              var e = new AggregateError();
              for (var i = this.length(); i < this._values.length; ++i) {
                e.push(this._values[i]);
              }
              this._reject(e);
            }
          };
          SomePromiseArray.prototype._fulfilled = function() {
            return this._totalResolved;
          };
          SomePromiseArray.prototype._rejected = function() {
            return this._values.length - this.length();
          };
          SomePromiseArray.prototype._addRejected = function(reason) {
            this._values.push(reason);
          };
          SomePromiseArray.prototype._addFulfilled = function(value) {
            this._values[this._totalResolved++] = value;
          };
          SomePromiseArray.prototype._canPossiblyFulfill = function() {
            return this.length() - this._rejected();
          };
          SomePromiseArray.prototype._getRangeError = function(count) {
            var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
            return new RangeError2(message);
          };
          SomePromiseArray.prototype._resolveEmptyArray = function() {
            this._reject(this._getRangeError(0));
          };
          function some2(promises, howMany) {
            if ((howMany | 0) !== howMany || howMany < 0) {
              return apiRejection("expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n");
            }
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(howMany);
            ret2.init();
            return promise;
          }
          Promise2.some = function(promises, howMany) {
            return some2(promises, howMany);
          };
          Promise2.prototype.some = function(howMany) {
            return some2(this, howMany);
          };
          Promise2._SomePromiseArray = SomePromiseArray;
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 34: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function PromiseInspection(promise) {
            if (promise !== void 0) {
              promise = promise._target();
              this._bitField = promise._bitField;
              this._settledValue = promise._settledValue;
            } else {
              this._bitField = 0;
              this._settledValue = void 0;
            }
          }
          PromiseInspection.prototype.value = function() {
            if (!this.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n");
            }
            return this._settledValue;
          };
          PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
            if (!this.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n");
            }
            return this._settledValue;
          };
          PromiseInspection.prototype.isFulfilled = Promise2.prototype._isFulfilled = function() {
            return (this._bitField & 268435456) > 0;
          };
          PromiseInspection.prototype.isRejected = Promise2.prototype._isRejected = function() {
            return (this._bitField & 134217728) > 0;
          };
          PromiseInspection.prototype.isPending = Promise2.prototype._isPending = function() {
            return (this._bitField & 402653184) === 0;
          };
          PromiseInspection.prototype.isResolved = Promise2.prototype._isResolved = function() {
            return (this._bitField & 402653184) > 0;
          };
          Promise2.prototype.isPending = function() {
            return this._target()._isPending();
          };
          Promise2.prototype.isRejected = function() {
            return this._target()._isRejected();
          };
          Promise2.prototype.isFulfilled = function() {
            return this._target()._isFulfilled();
          };
          Promise2.prototype.isResolved = function() {
            return this._target()._isResolved();
          };
          Promise2.prototype._value = function() {
            return this._settledValue;
          };
          Promise2.prototype._reason = function() {
            this._unsetRejectionIsUnhandled();
            return this._settledValue;
          };
          Promise2.prototype.value = function() {
            var target = this._target();
            if (!target.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n");
            }
            return target._settledValue;
          };
          Promise2.prototype.reason = function() {
            var target = this._target();
            if (!target.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n");
            }
            target._unsetRejectionIsUnhandled();
            return target._settledValue;
          };
          Promise2.PromiseInspection = PromiseInspection;
        };
      }, {}], 35: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util.js");
          var errorObj2 = util.errorObj;
          var isObject3 = util.isObject;
          function tryConvertToPromise(obj2, context) {
            if (isObject3(obj2)) {
              if (obj2 instanceof Promise2) {
                return obj2;
              } else if (isAnyBluebirdPromise(obj2)) {
                var ret2 = new Promise2(INTERNAL);
                obj2._then(
                  ret2._fulfillUnchecked,
                  ret2._rejectUncheckedCheckError,
                  ret2._progressUnchecked,
                  ret2,
                  null
                );
                return ret2;
              }
              var then = util.tryCatch(getThen)(obj2);
              if (then === errorObj2) {
                if (context)
                  context._pushContext();
                var ret2 = Promise2.reject(then.e);
                if (context)
                  context._popContext();
                return ret2;
              } else if (typeof then === "function") {
                return doThenable(obj2, then, context);
              }
            }
            return obj2;
          }
          function getThen(obj2) {
            return obj2.then;
          }
          var hasProp = {}.hasOwnProperty;
          function isAnyBluebirdPromise(obj2) {
            return hasProp.call(obj2, "_promise0");
          }
          function doThenable(x, then, context) {
            var promise = new Promise2(INTERNAL);
            var ret2 = promise;
            if (context)
              context._pushContext();
            promise._captureStackTrace();
            if (context)
              context._popContext();
            var synchronous = true;
            var result2 = util.tryCatch(then).call(
              x,
              resolveFromThenable,
              rejectFromThenable,
              progressFromThenable
            );
            synchronous = false;
            if (promise && result2 === errorObj2) {
              promise._rejectCallback(result2.e, true, true);
              promise = null;
            }
            function resolveFromThenable(value) {
              if (!promise)
                return;
              promise._resolveCallback(value);
              promise = null;
            }
            function rejectFromThenable(reason) {
              if (!promise)
                return;
              promise._rejectCallback(reason, synchronous, true);
              promise = null;
            }
            function progressFromThenable(value) {
              if (!promise)
                return;
              if (typeof promise._progress === "function") {
                promise._progress(value);
              }
            }
            return ret2;
          }
          return tryConvertToPromise;
        };
      }, { "./util.js": 38 }], 36: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util.js");
          var TimeoutError = Promise2.TimeoutError;
          var afterTimeout = function(promise, message) {
            if (!promise.isPending())
              return;
            var err;
            if (!util.isPrimitive(message) && message instanceof Error) {
              err = message;
            } else {
              if (typeof message !== "string") {
                message = "operation timed out";
              }
              err = new TimeoutError(message);
            }
            util.markAsOriginatingFromRejection(err);
            promise._attachExtraTrace(err);
            promise._cancel(err);
          };
          var afterValue = function(value) {
            return delay(+this).thenReturn(value);
          };
          var delay = Promise2.delay = function(value, ms) {
            if (ms === void 0) {
              ms = value;
              value = void 0;
              var ret2 = new Promise2(INTERNAL);
              setTimeout(function() {
                ret2._fulfill();
              }, ms);
              return ret2;
            }
            ms = +ms;
            return Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          };
          Promise2.prototype.delay = function(ms) {
            return delay(this, ms);
          };
          function successClear(value) {
            var handle = this;
            if (handle instanceof Number)
              handle = +handle;
            clearTimeout(handle);
            return value;
          }
          function failureClear(reason) {
            var handle = this;
            if (handle instanceof Number)
              handle = +handle;
            clearTimeout(handle);
            throw reason;
          }
          Promise2.prototype.timeout = function(ms, message) {
            ms = +ms;
            var ret2 = this.then().cancellable();
            ret2._cancellationParent = this;
            var handle = setTimeout(function timeoutTimeout() {
              afterTimeout(ret2, message);
            }, ms);
            return ret2._then(successClear, failureClear, void 0, handle, void 0);
          };
        };
      }, { "./util.js": 38 }], 37: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext) {
          var TypeError2 = _dereq_2("./errors.js").TypeError;
          var inherits2 = _dereq_2("./util.js").inherits;
          var PromiseInspection = Promise2.PromiseInspection;
          function inspectionMapper(inspections) {
            var len = inspections.length;
            for (var i = 0; i < len; ++i) {
              var inspection = inspections[i];
              if (inspection.isRejected()) {
                return Promise2.reject(inspection.error());
              }
              inspections[i] = inspection._settledValue;
            }
            return inspections;
          }
          function thrower2(e) {
            setTimeout(function() {
              throw e;
            }, 0);
          }
          function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
              maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
          }
          function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret2 = Promise2.defer();
            function iterator() {
              if (i >= len)
                return ret2.resolve();
              var maybePromise = castPreservingDisposable(resources[i++]);
              if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
                try {
                  maybePromise = tryConvertToPromise(
                    maybePromise._getDisposer().tryDispose(inspection),
                    resources.promise
                  );
                } catch (e) {
                  return thrower2(e);
                }
                if (maybePromise instanceof Promise2) {
                  return maybePromise._then(
                    iterator,
                    thrower2,
                    null,
                    null,
                    null
                  );
                }
              }
              iterator();
            }
            iterator();
            return ret2.promise;
          }
          function disposerSuccess(value) {
            var inspection = new PromiseInspection();
            inspection._settledValue = value;
            inspection._bitField = 268435456;
            return dispose(this, inspection).thenReturn(value);
          }
          function disposerFail(reason) {
            var inspection = new PromiseInspection();
            inspection._settledValue = reason;
            inspection._bitField = 134217728;
            return dispose(this, inspection).thenThrow(reason);
          }
          function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
          }
          Disposer.prototype.data = function() {
            return this._data;
          };
          Disposer.prototype.promise = function() {
            return this._promise;
          };
          Disposer.prototype.resource = function() {
            if (this.promise().isFulfilled()) {
              return this.promise().value();
            }
            return null;
          };
          Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== void 0)
              context._pushContext();
            var ret2 = resource !== null ? this.doDispose(resource, inspection) : null;
            if (context !== void 0)
              context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret2;
          };
          Disposer.isDisposer = function(d) {
            return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
          };
          function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
          }
          inherits2(FunctionDisposer, Disposer);
          FunctionDisposer.prototype.doDispose = function(resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
          };
          function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
              this.resources[this.index]._setDisposable(value);
              return value.promise();
            }
            return value;
          }
          Promise2.using = function() {
            var len = arguments.length;
            if (len < 2)
              return apiRejection(
                "you must pass at least 2 arguments to Promise.using"
              );
            var fn = arguments[len - 1];
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var input;
            var spreadArgs = true;
            if (len === 2 && Array.isArray(arguments[0])) {
              input = arguments[0];
              len = input.length;
              spreadArgs = false;
            } else {
              input = arguments;
              len--;
            }
            var resources = new Array(len);
            for (var i = 0; i < len; ++i) {
              var resource = input[i];
              if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
              } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise2) {
                  resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                    resources,
                    index: i
                  }, void 0);
                }
              }
              resources[i] = resource;
            }
            var promise = Promise2.settle(resources).then(inspectionMapper).then(function(vals) {
              promise._pushContext();
              var ret2;
              try {
                ret2 = spreadArgs ? fn.apply(void 0, vals) : fn.call(void 0, vals);
              } finally {
                promise._popContext();
              }
              return ret2;
            })._then(
              disposerSuccess,
              disposerFail,
              void 0,
              resources,
              void 0
            );
            resources.promise = promise;
            return promise;
          };
          Promise2.prototype._setDisposable = function(disposer) {
            this._bitField = this._bitField | 262144;
            this._disposer = disposer;
          };
          Promise2.prototype._isDisposable = function() {
            return (this._bitField & 262144) > 0;
          };
          Promise2.prototype._getDisposer = function() {
            return this._disposer;
          };
          Promise2.prototype._unsetDisposable = function() {
            this._bitField = this._bitField & ~262144;
            this._disposer = void 0;
          };
          Promise2.prototype.disposer = function(fn) {
            if (typeof fn === "function") {
              return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError2();
          };
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 38: [function(_dereq_, module, exports) {
        "use strict";
        var es5 = _dereq_("./es5.js");
        var canEvaluate = typeof navigator == "undefined";
        var haveGetters = function() {
          try {
            var o = {};
            es5.defineProperty(o, "f", {
              get: function() {
                return 3;
              }
            });
            return o.f === 3;
          } catch (e) {
            return false;
          }
        }();
        var errorObj = { e: {} };
        var tryCatchTarget;
        function tryCatcher() {
          try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
          } catch (e) {
            errorObj.e = e;
            return errorObj;
          }
        }
        function tryCatch(fn) {
          tryCatchTarget = fn;
          return tryCatcher;
        }
        var inherits = function(Child, Parent) {
          var hasProp = {}.hasOwnProperty;
          function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
              if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
              }
            }
          }
          T.prototype = Parent.prototype;
          Child.prototype = new T();
          return Child.prototype;
        };
        function isPrimitive(val) {
          return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
        }
        function isObject(value) {
          return !isPrimitive(value);
        }
        function maybeWrapAsError(maybeError) {
          if (!isPrimitive(maybeError))
            return maybeError;
          return new Error(safeToString(maybeError));
        }
        function withAppended(target, appendee) {
          var len = target.length;
          var ret2 = new Array(len + 1);
          var i;
          for (i = 0; i < len; ++i) {
            ret2[i] = target[i];
          }
          ret2[i] = appendee;
          return ret2;
        }
        function getDataPropertyOrDefault(obj2, key, defaultValue) {
          if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null) {
              return desc.get == null && desc.set == null ? desc.value : defaultValue;
            }
          } else {
            return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
          }
        }
        function notEnumerableProp(obj2, name, value) {
          if (isPrimitive(obj2))
            return obj2;
          var descriptor = {
            value,
            configurable: true,
            enumerable: false,
            writable: true
          };
          es5.defineProperty(obj2, name, descriptor);
          return obj2;
        }
        function thrower(r) {
          throw r;
        }
        var inheritedDataKeys = function() {
          var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ];
          var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (excludedPrototypes[i] === val) {
                return true;
              }
            }
            return false;
          };
          if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj2) {
              var ret2 = [];
              var visitedKeys = /* @__PURE__ */ Object.create(null);
              while (obj2 != null && !isExcludedProto(obj2)) {
                var keys2;
                try {
                  keys2 = getKeys(obj2);
                } catch (e) {
                  return ret2;
                }
                for (var i = 0; i < keys2.length; ++i) {
                  var key = keys2[i];
                  if (visitedKeys[key])
                    continue;
                  visitedKeys[key] = true;
                  var desc = Object.getOwnPropertyDescriptor(obj2, key);
                  if (desc != null && desc.get == null && desc.set == null) {
                    ret2.push(key);
                  }
                }
                obj2 = es5.getPrototypeOf(obj2);
              }
              return ret2;
            };
          } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj2) {
              if (isExcludedProto(obj2))
                return [];
              var ret2 = [];
              enumeration:
                for (var key in obj2) {
                  if (hasProp.call(obj2, key)) {
                    ret2.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret2.push(key);
                  }
                }
              return ret2;
            };
          }
        }();
        var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
        function isClass(fn) {
          try {
            if (typeof fn === "function") {
              var keys2 = es5.names(fn.prototype);
              var hasMethods = es5.isES5 && keys2.length > 1;
              var hasMethodsOtherThanConstructor = keys2.length > 0 && !(keys2.length === 1 && keys2[0] === "constructor");
              var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
              if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
              }
            }
            return false;
          } catch (e) {
            return false;
          }
        }
        function toFastProperties(obj) {
          function f() {
          }
          f.prototype = obj;
          var l = 8;
          while (l--)
            new f();
          return obj;
          eval(obj);
        }
        var rident = /^[a-z$_][a-z$_0-9]*$/i;
        function isIdentifier(str) {
          return rident.test(str);
        }
        function filledRange(count, prefix, suffix) {
          var ret2 = new Array(count);
          for (var i = 0; i < count; ++i) {
            ret2[i] = prefix + i + suffix;
          }
          return ret2;
        }
        function safeToString(obj2) {
          try {
            return obj2 + "";
          } catch (e) {
            return "[no string representation]";
          }
        }
        function markAsOriginatingFromRejection(e) {
          try {
            notEnumerableProp(e, "isOperational", true);
          } catch (ignore) {
          }
        }
        function originatesFromRejection(e) {
          if (e == null)
            return false;
          return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
        }
        function canAttachTrace(obj2) {
          return obj2 instanceof Error && es5.propertyIsWritable(obj2, "stack");
        }
        var ensureErrorObject = function() {
          if (!("stack" in new Error())) {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              try {
                throw new Error(safeToString(value));
              } catch (err) {
                return err;
              }
            };
          } else {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              return new Error(safeToString(value));
            };
          }
        }();
        function classString(obj2) {
          return {}.toString.call(obj2);
        }
        function copyDescriptors(from, to, filter2) {
          var keys2 = es5.names(from);
          for (var i = 0; i < keys2.length; ++i) {
            var key = keys2[i];
            if (filter2(key)) {
              try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
              } catch (ignore) {
              }
            }
          }
        }
        var ret = {
          isClass,
          isIdentifier,
          inheritedDataKeys,
          getDataPropertyOrDefault,
          thrower,
          isArray: es5.isArray,
          haveGetters,
          notEnumerableProp,
          isPrimitive,
          isObject,
          canEvaluate,
          errorObj,
          tryCatch,
          inherits,
          withAppended,
          maybeWrapAsError,
          toFastProperties,
          filledRange,
          toString: safeToString,
          canAttachTrace,
          ensureErrorObject,
          originatesFromRejection,
          markAsOriginatingFromRejection,
          classString,
          copyDescriptors,
          hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
          isNode: typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]"
        };
        ret.isRecentNode = ret.isNode && function() {
          var version = process.versions.node.split(".").map(Number);
          return version[0] === 0 && version[1] > 10 || version[0] > 0;
        }();
        if (ret.isNode)
          ret.toFastProperties(process);
        try {
          throw new Error();
        } catch (e) {
          ret.lastLineError = e;
        }
        module.exports = ret;
      }, { "./es5.js": 14 }] }, {}, [4])(4);
    });
    if (typeof window !== "undefined" && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== "undefined" && self !== null) {
      self.P = self.Promise;
    }
  }
});

// node_modules/pkghub-render/node_modules/bluebird/js/browser/bluebird.js
var require_bluebird3 = __commonJS({
  "node_modules/pkghub-render/node_modules/bluebird/js/browser/bluebird.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f2;
        "undefined" != typeof window ? f2 = window : "undefined" != typeof global ? f2 = global : "undefined" != typeof self && (f2 = self), f2.Promise = e();
      }
    }(function() {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f2 = new Error("Cannot find module '" + o2 + "'");
              throw f2.code = "MODULE_NOT_FOUND", f2;
            }
            var l2 = n[o2] = { exports: {} };
            t[o2][0].call(l2.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l2, l2.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var SomePromiseArray = Promise2._SomePromiseArray;
          function any(promises) {
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(1);
            ret2.setUnwrap();
            ret2.init();
            return promise;
          }
          Promise2.any = function(promises) {
            return any(promises);
          };
          Promise2.prototype.any = function() {
            return any(this);
          };
        };
      }, {}], 2: [function(_dereq_2, module2, exports2) {
        "use strict";
        var firstLineError;
        try {
          throw new Error();
        } catch (e) {
          firstLineError = e;
        }
        var schedule = _dereq_2("./schedule.js");
        var Queue = _dereq_2("./queue.js");
        var util = _dereq_2("./util.js");
        function Async() {
          this._isTickUsed = false;
          this._lateQueue = new Queue(16);
          this._normalQueue = new Queue(16);
          this._trampolineEnabled = true;
          var self2 = this;
          this.drainQueues = function() {
            self2._drainQueues();
          };
          this._schedule = schedule.isStatic ? schedule(this.drainQueues) : schedule;
        }
        Async.prototype.disableTrampolineIfNecessary = function() {
          if (util.hasDevTools) {
            this._trampolineEnabled = false;
          }
        };
        Async.prototype.enableTrampoline = function() {
          if (!this._trampolineEnabled) {
            this._trampolineEnabled = true;
            this._schedule = function(fn) {
              setTimeout(fn, 0);
            };
          }
        };
        Async.prototype.haveItemsQueued = function() {
          return this._normalQueue.length() > 0;
        };
        Async.prototype.throwLater = function(fn, arg) {
          if (arguments.length === 1) {
            arg = fn;
            fn = function() {
              throw arg;
            };
          }
          if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
              fn(arg);
            }, 0);
          } else
            try {
              this._schedule(function() {
                fn(arg);
              });
            } catch (e) {
              throw new Error("No async scheduler available\n\n    See http://goo.gl/m3OTXk\n");
            }
        };
        function AsyncInvokeLater(fn, receiver, arg) {
          this._lateQueue.push(fn, receiver, arg);
          this._queueTick();
        }
        function AsyncInvoke(fn, receiver, arg) {
          this._normalQueue.push(fn, receiver, arg);
          this._queueTick();
        }
        function AsyncSettlePromises(promise) {
          this._normalQueue._pushOne(promise);
          this._queueTick();
        }
        if (!util.hasDevTools) {
          Async.prototype.invokeLater = AsyncInvokeLater;
          Async.prototype.invoke = AsyncInvoke;
          Async.prototype.settlePromises = AsyncSettlePromises;
        } else {
          if (schedule.isStatic) {
            schedule = function(fn) {
              setTimeout(fn, 0);
            };
          }
          Async.prototype.invokeLater = function(fn, receiver, arg) {
            if (this._trampolineEnabled) {
              AsyncInvokeLater.call(this, fn, receiver, arg);
            } else {
              this._schedule(function() {
                setTimeout(function() {
                  fn.call(receiver, arg);
                }, 100);
              });
            }
          };
          Async.prototype.invoke = function(fn, receiver, arg) {
            if (this._trampolineEnabled) {
              AsyncInvoke.call(this, fn, receiver, arg);
            } else {
              this._schedule(function() {
                fn.call(receiver, arg);
              });
            }
          };
          Async.prototype.settlePromises = function(promise) {
            if (this._trampolineEnabled) {
              AsyncSettlePromises.call(this, promise);
            } else {
              this._schedule(function() {
                promise._settlePromises();
              });
            }
          };
        }
        Async.prototype.invokeFirst = function(fn, receiver, arg) {
          this._normalQueue.unshift(fn, receiver, arg);
          this._queueTick();
        };
        Async.prototype._drainQueue = function(queue) {
          while (queue.length() > 0) {
            var fn = queue.shift();
            if (typeof fn !== "function") {
              fn._settlePromises();
              continue;
            }
            var receiver = queue.shift();
            var arg = queue.shift();
            fn.call(receiver, arg);
          }
        };
        Async.prototype._drainQueues = function() {
          this._drainQueue(this._normalQueue);
          this._reset();
          this._drainQueue(this._lateQueue);
        };
        Async.prototype._queueTick = function() {
          if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
          }
        };
        Async.prototype._reset = function() {
          this._isTickUsed = false;
        };
        module2.exports = new Async();
        module2.exports.firstLineError = firstLineError;
      }, { "./queue.js": 28, "./schedule.js": 31, "./util.js": 38 }], 3: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise) {
          var rejectThis = function(_3, e) {
            this._reject(e);
          };
          var targetRejected = function(e, context) {
            context.promiseRejectionQueued = true;
            context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
          };
          var bindingResolved = function(thisArg, context) {
            if (this._isPending()) {
              this._resolveCallback(context.target);
            }
          };
          var bindingRejected = function(e, context) {
            if (!context.promiseRejectionQueued)
              this._reject(e);
          };
          Promise2.prototype.bind = function(thisArg) {
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._propagateFrom(this, 1);
            var target = this._target();
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              var context = {
                promiseRejectionQueued: false,
                promise: ret2,
                target,
                bindingPromise: maybePromise
              };
              target._then(INTERNAL, targetRejected, ret2._progress, ret2, context);
              maybePromise._then(
                bindingResolved,
                bindingRejected,
                ret2._progress,
                ret2,
                context
              );
            } else {
              ret2._resolveCallback(target);
            }
            return ret2;
          };
          Promise2.prototype._setBoundTo = function(obj2) {
            if (obj2 !== void 0) {
              this._bitField = this._bitField | 131072;
              this._boundTo = obj2;
            } else {
              this._bitField = this._bitField & ~131072;
            }
          };
          Promise2.prototype._isBound = function() {
            return (this._bitField & 131072) === 131072;
          };
          Promise2.bind = function(thisArg, value) {
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              maybePromise._then(function() {
                ret2._resolveCallback(value);
              }, ret2._reject, ret2._progress, ret2, null);
            } else {
              ret2._resolveCallback(value);
            }
            return ret2;
          };
        };
      }, {}], 4: [function(_dereq_2, module2, exports2) {
        "use strict";
        var old;
        if (typeof Promise !== "undefined")
          old = Promise;
        function noConflict() {
          try {
            if (Promise === bluebird)
              Promise = old;
          } catch (e) {
          }
          return bluebird;
        }
        var bluebird = _dereq_2("./promise.js")();
        bluebird.noConflict = noConflict;
        module2.exports = bluebird;
      }, { "./promise.js": 23 }], 5: [function(_dereq_2, module2, exports2) {
        "use strict";
        var cr = Object.create;
        if (cr) {
          var callerCache = cr(null);
          var getterCache = cr(null);
          callerCache[" size"] = getterCache[" size"] = 0;
        }
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util.js");
          var canEvaluate2 = util.canEvaluate;
          var isIdentifier2 = util.isIdentifier;
          var getMethodCaller;
          var getGetter;
          if (false) {
            var makeMethodCaller = function(methodName) {
              return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
            };
            var makeGetter = function(propertyName) {
              return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
            };
            var getCompiled = function(name, compiler, cache) {
              var ret2 = cache[name];
              if (typeof ret2 !== "function") {
                if (!isIdentifier2(name)) {
                  return null;
                }
                ret2 = compiler(name);
                cache[name] = ret2;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                  var keys2 = Object.keys(cache);
                  for (var i = 0; i < 256; ++i)
                    delete cache[keys2[i]];
                  cache[" size"] = keys2.length - 256;
                }
              }
              return ret2;
            };
            getMethodCaller = function(name) {
              return getCompiled(name, makeMethodCaller, callerCache);
            };
            getGetter = function(name) {
              return getCompiled(name, makeGetter, getterCache);
            };
          }
          function ensureMethod(obj2, methodName) {
            var fn;
            if (obj2 != null)
              fn = obj2[methodName];
            if (typeof fn !== "function") {
              var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
              throw new Promise2.TypeError(message);
            }
            return fn;
          }
          function caller(obj2) {
            var methodName = this.pop();
            var fn = ensureMethod(obj2, methodName);
            return fn.apply(obj2, this);
          }
          Promise2.prototype.call = function(methodName) {
            var $_len = arguments.length;
            var args = new Array($_len - 1);
            for (var $_i = 1; $_i < $_len; ++$_i) {
              args[$_i - 1] = arguments[$_i];
            }
            if (false) {
              if (canEvaluate2) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                  return this._then(
                    maybeCaller,
                    void 0,
                    void 0,
                    args,
                    void 0
                  );
                }
              }
            }
            args.push(methodName);
            return this._then(caller, void 0, void 0, args, void 0);
          };
          function namedGetter(obj2) {
            return obj2[this];
          }
          function indexedGetter(obj2) {
            var index = +this;
            if (index < 0)
              index = Math.max(0, index + obj2.length);
            return obj2[index];
          }
          Promise2.prototype.get = function(propertyName) {
            var isIndex = typeof propertyName === "number";
            var getter;
            if (!isIndex) {
              if (canEvaluate2) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
              } else {
                getter = namedGetter;
              }
            } else {
              getter = indexedGetter;
            }
            return this._then(getter, void 0, void 0, propertyName, void 0);
          };
        };
      }, { "./util.js": 38 }], 6: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var errors = _dereq_2("./errors.js");
          var async = _dereq_2("./async.js");
          var CancellationError = errors.CancellationError;
          Promise2.prototype._cancel = function(reason) {
            if (!this.isCancellable())
              return this;
            var parent;
            var promiseToReject = this;
            while ((parent = promiseToReject._cancellationParent) !== void 0 && parent.isCancellable()) {
              promiseToReject = parent;
            }
            this._unsetCancellable();
            promiseToReject._target()._rejectCallback(reason, false, true);
          };
          Promise2.prototype.cancel = function(reason) {
            if (!this.isCancellable())
              return this;
            if (reason === void 0)
              reason = new CancellationError();
            async.invokeLater(this._cancel, this, reason);
            return this;
          };
          Promise2.prototype.cancellable = function() {
            if (this._cancellable())
              return this;
            async.enableTrampoline();
            this._setCancellable();
            this._cancellationParent = void 0;
            return this;
          };
          Promise2.prototype.uncancellable = function() {
            var ret2 = this.then();
            ret2._unsetCancellable();
            return ret2;
          };
          Promise2.prototype.fork = function(didFulfill, didReject, didProgress) {
            var ret2 = this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
            ret2._setCancellable();
            ret2._cancellationParent = void 0;
            return ret2;
          };
        };
      }, { "./async.js": 2, "./errors.js": 13 }], 7: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
          var stackFramePattern = null;
          var formatStack = null;
          var indentStackFrames = false;
          var warn;
          function CapturedTrace(parent) {
            this._parent = parent;
            var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
            captureStackTrace(this, CapturedTrace);
            if (length > 32)
              this.uncycle();
          }
          util.inherits(CapturedTrace, Error);
          CapturedTrace.prototype.uncycle = function() {
            var length = this._length;
            if (length < 2)
              return;
            var nodes = [];
            var stackToIndex = {};
            for (var i = 0, node = this; node !== void 0; ++i) {
              nodes.push(node);
              node = node._parent;
            }
            length = this._length = i;
            for (var i = length - 1; i >= 0; --i) {
              var stack = nodes[i].stack;
              if (stackToIndex[stack] === void 0) {
                stackToIndex[stack] = i;
              }
            }
            for (var i = 0; i < length; ++i) {
              var currentStack = nodes[i].stack;
              var index = stackToIndex[currentStack];
              if (index !== void 0 && index !== i) {
                if (index > 0) {
                  nodes[index - 1]._parent = void 0;
                  nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = void 0;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                if (index < length - 1) {
                  cycleEdgeNode._parent = nodes[index + 1];
                  cycleEdgeNode._parent.uncycle();
                  cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                  cycleEdgeNode._parent = void 0;
                  cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                  nodes[j]._length = currentChildLength;
                  currentChildLength++;
                }
                return;
              }
            }
          };
          CapturedTrace.prototype.parent = function() {
            return this._parent;
          };
          CapturedTrace.prototype.hasParent = function() {
            return this._parent !== void 0;
          };
          CapturedTrace.prototype.attachExtraTrace = function(error) {
            if (error.__stackCleaned__)
              return;
            this.uncycle();
            var parsed = CapturedTrace.parseStackAndMessage(error);
            var message = parsed.message;
            var stacks = [parsed.stack];
            var trace = this;
            while (trace !== void 0) {
              stacks.push(cleanStack(trace.stack.split("\n")));
              trace = trace._parent;
            }
            removeCommonRoots(stacks);
            removeDuplicateOrEmptyJumps(stacks);
            util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
            util.notEnumerableProp(error, "__stackCleaned__", true);
          };
          function reconstructStack(message, stacks) {
            for (var i = 0; i < stacks.length - 1; ++i) {
              stacks[i].push("From previous event:");
              stacks[i] = stacks[i].join("\n");
            }
            if (i < stacks.length) {
              stacks[i] = stacks[i].join("\n");
            }
            return message + "\n" + stacks.join("\n");
          }
          function removeDuplicateOrEmptyJumps(stacks) {
            for (var i = 0; i < stacks.length; ++i) {
              if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
              }
            }
          }
          function removeCommonRoots(stacks) {
            var current = stacks[0];
            for (var i = 1; i < stacks.length; ++i) {
              var prev = stacks[i];
              var currentLastIndex = current.length - 1;
              var currentLastLine = current[currentLastIndex];
              var commonRootMeetPoint = -1;
              for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                  commonRootMeetPoint = j;
                  break;
                }
              }
              for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                  current.pop();
                  currentLastIndex--;
                } else {
                  break;
                }
              }
              current = prev;
            }
          }
          function cleanStack(stack) {
            var ret2 = [];
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              var isTraceLine = stackFramePattern.test(line) || "    (No stack trace)" === line;
              var isInternalFrame = isTraceLine && shouldIgnore(line);
              if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                  line = "    " + line;
                }
                ret2.push(line);
              }
            }
            return ret2;
          }
          function stackFramesAsArray(error) {
            var stack = error.stack.replace(/\s+$/g, "").split("\n");
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
              }
            }
            if (i > 0) {
              stack = stack.slice(i);
            }
            return stack;
          }
          CapturedTrace.parseStackAndMessage = function(error) {
            var stack = error.stack;
            var message = error.toString();
            stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
            return {
              message,
              stack: cleanStack(stack)
            };
          };
          CapturedTrace.formatAndLogError = function(error, title) {
            if (typeof console !== "undefined") {
              var message;
              if (typeof error === "object" || typeof error === "function") {
                var stack = error.stack;
                message = title + formatStack(stack, error);
              } else {
                message = title + String(error);
              }
              if (typeof warn === "function") {
                warn(message);
              } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
              }
            }
          };
          CapturedTrace.unhandledRejection = function(reason) {
            CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
          };
          CapturedTrace.isSupported = function() {
            return typeof captureStackTrace === "function";
          };
          CapturedTrace.fireRejectionEvent = function(name, localHandler, reason, promise) {
            var localEventFired = false;
            try {
              if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                  localHandler(promise);
                } else {
                  localHandler(reason, promise);
                }
              }
            } catch (e) {
              async.throwLater(e);
            }
            var globalEventFired = false;
            try {
              globalEventFired = fireGlobalEvent(name, reason, promise);
            } catch (e) {
              globalEventFired = true;
              async.throwLater(e);
            }
            var domEventFired = false;
            if (fireDomEvent) {
              try {
                domEventFired = fireDomEvent(name.toLowerCase(), {
                  reason,
                  promise
                });
              } catch (e) {
                domEventFired = true;
                async.throwLater(e);
              }
            }
            if (!globalEventFired && !localEventFired && !domEventFired && name === "unhandledRejection") {
              CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
            }
          };
          function formatNonError(obj2) {
            var str;
            if (typeof obj2 === "function") {
              str = "[function " + (obj2.name || "anonymous") + "]";
            } else {
              str = obj2.toString();
              var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
              if (ruselessToString.test(str)) {
                try {
                  var newStr = JSON.stringify(obj2);
                  str = newStr;
                } catch (e) {
                }
              }
              if (str.length === 0) {
                str = "(empty array)";
              }
            }
            return "(<" + snip(str) + ">, no stack trace)";
          }
          function snip(str) {
            var maxChars = 41;
            if (str.length < maxChars) {
              return str;
            }
            return str.substr(0, maxChars - 3) + "...";
          }
          var shouldIgnore = function() {
            return false;
          };
          var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function parseLineInfo(line) {
            var matches = line.match(parseLineInfoRegex);
            if (matches) {
              return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
              };
            }
          }
          CapturedTrace.setBounds = function(firstLineError, lastLineError) {
            if (!CapturedTrace.isSupported())
              return;
            var firstStackLines = firstLineError.stack.split("\n");
            var lastStackLines = lastLineError.stack.split("\n");
            var firstIndex = -1;
            var lastIndex = -1;
            var firstFileName;
            var lastFileName;
            for (var i = 0; i < firstStackLines.length; ++i) {
              var result2 = parseLineInfo(firstStackLines[i]);
              if (result2) {
                firstFileName = result2.fileName;
                firstIndex = result2.line;
                break;
              }
            }
            for (var i = 0; i < lastStackLines.length; ++i) {
              var result2 = parseLineInfo(lastStackLines[i]);
              if (result2) {
                lastFileName = result2.fileName;
                lastIndex = result2.line;
                break;
              }
            }
            if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
              return;
            }
            shouldIgnore = function(line) {
              if (bluebirdFramePattern.test(line))
                return true;
              var info = parseLineInfo(line);
              if (info) {
                if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                  return true;
                }
              }
              return false;
            };
          };
          var captureStackTrace = function stackDetection() {
            var v8stackFramePattern = /^\s*at\s*/;
            var v8stackFormatter = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if (error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
              Error.stackTraceLimit = Error.stackTraceLimit + 6;
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              var captureStackTrace2 = Error.captureStackTrace;
              shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
              };
              return function(receiver, ignoreUntil) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                captureStackTrace2(receiver, ignoreUntil);
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
              };
            }
            var err = new Error();
            if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
              stackFramePattern = /@/;
              formatStack = v8stackFormatter;
              indentStackFrames = true;
              return function captureStackTrace3(o) {
                o.stack = new Error().stack;
              };
            }
            var hasStackAfterThrow;
            try {
              throw new Error();
            } catch (e) {
              hasStackAfterThrow = "stack" in e;
            }
            if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              return function captureStackTrace3(o) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                try {
                  throw new Error();
                } catch (e) {
                  o.stack = e.stack;
                }
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
              };
            }
            formatStack = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            return null;
          }([]);
          var fireDomEvent;
          var fireGlobalEvent = function() {
            if (util.isNode) {
              return function(name, reason, promise) {
                if (name === "rejectionHandled") {
                  return process.emit(name, promise);
                } else {
                  return process.emit(name, reason, promise);
                }
              };
            } else {
              var customEventWorks = false;
              var anyEventWorks = true;
              try {
                var ev = new self.CustomEvent("test");
                customEventWorks = ev instanceof CustomEvent;
              } catch (e) {
              }
              if (!customEventWorks) {
                try {
                  var event = document.createEvent("CustomEvent");
                  event.initCustomEvent("testingtheevent", false, true, {});
                  self.dispatchEvent(event);
                } catch (e) {
                  anyEventWorks = false;
                }
              }
              if (anyEventWorks) {
                fireDomEvent = function(type, detail) {
                  var event2;
                  if (customEventWorks) {
                    event2 = new self.CustomEvent(type, {
                      detail,
                      bubbles: false,
                      cancelable: true
                    });
                  } else if (self.dispatchEvent) {
                    event2 = document.createEvent("CustomEvent");
                    event2.initCustomEvent(type, false, true, detail);
                  }
                  return event2 ? !self.dispatchEvent(event2) : false;
                };
              }
              var toWindowMethodNameMap = {};
              toWindowMethodNameMap["unhandledRejection"] = "onunhandledRejection".toLowerCase();
              toWindowMethodNameMap["rejectionHandled"] = "onrejectionHandled".toLowerCase();
              return function(name, reason, promise) {
                var methodName = toWindowMethodNameMap[name];
                var method = self[methodName];
                if (!method)
                  return false;
                if (name === "rejectionHandled") {
                  method.call(self, promise);
                } else {
                  method.call(self, reason, promise);
                }
                return true;
              };
            }
          }();
          if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
            warn = function(message) {
              console.warn(message);
            };
            if (util.isNode && process.stderr.isTTY) {
              warn = function(message) {
                process.stderr.write("\x1B[31m" + message + "\x1B[39m\n");
              };
            } else if (!util.isNode && typeof new Error().stack === "string") {
              warn = function(message) {
                console.warn("%c" + message, "color: red");
              };
            }
          }
          return CapturedTrace;
        };
      }, { "./async.js": 2, "./util.js": 38 }], 8: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(NEXT_FILTER) {
          var util = _dereq_2("./util.js");
          var errors = _dereq_2("./errors.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var keys2 = _dereq_2("./es5.js").keys;
          var TypeError2 = errors.TypeError;
          function CatchFilter(instances, callback, promise) {
            this._instances = instances;
            this._callback = callback;
            this._promise = promise;
          }
          function safePredicate(predicate, e) {
            var safeObject = {};
            var retfilter = tryCatch2(predicate).call(safeObject, e);
            if (retfilter === errorObj2)
              return retfilter;
            var safeKeys = keys2(safeObject);
            if (safeKeys.length) {
              errorObj2.e = new TypeError2("Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n");
              return errorObj2;
            }
            return retfilter;
          }
          CatchFilter.prototype.doFilter = function(e) {
            var cb2 = this._callback;
            var promise = this._promise;
            var boundTo = promise._boundValue();
            for (var i = 0, len = this._instances.length; i < len; ++i) {
              var item = this._instances[i];
              var itemIsErrorType = item === Error || item != null && item.prototype instanceof Error;
              if (itemIsErrorType && e instanceof item) {
                var ret2 = tryCatch2(cb2).call(boundTo, e);
                if (ret2 === errorObj2) {
                  NEXT_FILTER.e = ret2.e;
                  return NEXT_FILTER;
                }
                return ret2;
              } else if (typeof item === "function" && !itemIsErrorType) {
                var shouldHandle = safePredicate(item, e);
                if (shouldHandle === errorObj2) {
                  e = errorObj2.e;
                  break;
                } else if (shouldHandle) {
                  var ret2 = tryCatch2(cb2).call(boundTo, e);
                  if (ret2 === errorObj2) {
                    NEXT_FILTER.e = ret2.e;
                    return NEXT_FILTER;
                  }
                  return ret2;
                }
              }
            }
            NEXT_FILTER.e = e;
            return NEXT_FILTER;
          };
          return CatchFilter;
        };
      }, { "./errors.js": 13, "./es5.js": 14, "./util.js": 38 }], 9: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, CapturedTrace, isDebugging) {
          var contextStack = [];
          function Context() {
            this._trace = new CapturedTrace(peekContext());
          }
          Context.prototype._pushContext = function() {
            if (!isDebugging())
              return;
            if (this._trace !== void 0) {
              contextStack.push(this._trace);
            }
          };
          Context.prototype._popContext = function() {
            if (!isDebugging())
              return;
            if (this._trace !== void 0) {
              contextStack.pop();
            }
          };
          function createContext() {
            if (isDebugging())
              return new Context();
          }
          function peekContext() {
            var lastIndex = contextStack.length - 1;
            if (lastIndex >= 0) {
              return contextStack[lastIndex];
            }
            return void 0;
          }
          Promise2.prototype._peekContext = peekContext;
          Promise2.prototype._pushContext = Context.prototype._pushContext;
          Promise2.prototype._popContext = Context.prototype._popContext;
          return createContext;
        };
      }, {}], 10: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, CapturedTrace) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var Warning = _dereq_2("./errors.js").Warning;
          var util = _dereq_2("./util.js");
          var canAttachTrace2 = util.canAttachTrace;
          var unhandledRejectionHandled;
          var possiblyUnhandledRejection;
          var debugging = util.isNode && (!!process.env["BLUEBIRD_DEBUG"] || true);
          if (debugging) {
            async.disableTrampolineIfNecessary();
          }
          Promise2.prototype._ignoreRejections = function() {
            this._unsetRejectionIsUnhandled();
            this._bitField = this._bitField | 16777216;
          };
          Promise2.prototype._ensurePossibleRejectionHandled = function() {
            if ((this._bitField & 16777216) !== 0)
              return;
            this._setRejectionIsUnhandled();
            async.invokeLater(this._notifyUnhandledRejection, this, void 0);
          };
          Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
            CapturedTrace.fireRejectionEvent(
              "rejectionHandled",
              unhandledRejectionHandled,
              void 0,
              this
            );
          };
          Promise2.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var reason = this._getCarriedStackTrace() || this._settledValue;
              this._setUnhandledRejectionIsNotified();
              CapturedTrace.fireRejectionEvent(
                "unhandledRejection",
                possiblyUnhandledRejection,
                reason,
                this
              );
            }
          };
          Promise2.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 524288;
          };
          Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & ~524288;
          };
          Promise2.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 524288) > 0;
          };
          Promise2.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 2097152;
          };
          Promise2.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & ~2097152;
            if (this._isUnhandledRejectionNotified()) {
              this._unsetUnhandledRejectionIsNotified();
              this._notifyUnhandledRejectionIsHandled();
            }
          };
          Promise2.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 2097152) > 0;
          };
          Promise2.prototype._setCarriedStackTrace = function(capturedTrace) {
            this._bitField = this._bitField | 1048576;
            this._fulfillmentHandler0 = capturedTrace;
          };
          Promise2.prototype._isCarryingStackTrace = function() {
            return (this._bitField & 1048576) > 0;
          };
          Promise2.prototype._getCarriedStackTrace = function() {
            return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : void 0;
          };
          Promise2.prototype._captureStackTrace = function() {
            if (debugging) {
              this._trace = new CapturedTrace(this._peekContext());
            }
            return this;
          };
          Promise2.prototype._attachExtraTrace = function(error, ignoreSelf) {
            if (debugging && canAttachTrace2(error)) {
              var trace = this._trace;
              if (trace !== void 0) {
                if (ignoreSelf)
                  trace = trace._parent;
              }
              if (trace !== void 0) {
                trace.attachExtraTrace(error);
              } else if (!error.__stackCleaned__) {
                var parsed = CapturedTrace.parseStackAndMessage(error);
                util.notEnumerableProp(
                  error,
                  "stack",
                  parsed.message + "\n" + parsed.stack.join("\n")
                );
                util.notEnumerableProp(error, "__stackCleaned__", true);
              }
            }
          };
          Promise2.prototype._warn = function(message) {
            var warning = new Warning(message);
            var ctx = this._peekContext();
            if (ctx) {
              ctx.attachExtraTrace(warning);
            } else {
              var parsed = CapturedTrace.parseStackAndMessage(warning);
              warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
            }
            CapturedTrace.formatAndLogError(warning, "");
          };
          Promise2.onPossiblyUnhandledRejection = function(fn) {
            var domain = getDomain();
            possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : void 0;
          };
          Promise2.onUnhandledRejectionHandled = function(fn) {
            var domain = getDomain();
            unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : void 0;
          };
          Promise2.longStackTraces = function() {
            if (async.haveItemsQueued() && debugging === false) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n");
            }
            debugging = CapturedTrace.isSupported();
            if (debugging) {
              async.disableTrampolineIfNecessary();
            }
          };
          Promise2.hasLongStackTraces = function() {
            return debugging && CapturedTrace.isSupported();
          };
          if (!CapturedTrace.isSupported()) {
            Promise2.longStackTraces = function() {
            };
            debugging = false;
          }
          return function() {
            return debugging;
          };
        };
      }, { "./async.js": 2, "./errors.js": 13, "./util.js": 38 }], 11: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util.js");
        var isPrimitive2 = util.isPrimitive;
        module2.exports = function(Promise2) {
          var returner = function() {
            return this;
          };
          var thrower2 = function() {
            throw this;
          };
          var returnUndefined = function() {
          };
          var throwUndefined = function() {
            throw void 0;
          };
          var wrapper = function(value, action) {
            if (action === 1) {
              return function() {
                throw value;
              };
            } else if (action === 2) {
              return function() {
                return value;
              };
            }
          };
          Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
            if (value === void 0)
              return this.then(returnUndefined);
            if (isPrimitive2(value)) {
              return this._then(
                wrapper(value, 2),
                void 0,
                void 0,
                void 0,
                void 0
              );
            }
            return this._then(returner, void 0, void 0, value, void 0);
          };
          Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
            if (reason === void 0)
              return this.then(throwUndefined);
            if (isPrimitive2(reason)) {
              return this._then(
                wrapper(reason, 1),
                void 0,
                void 0,
                void 0,
                void 0
              );
            }
            return this._then(thrower2, void 0, void 0, reason, void 0);
          };
        };
      }, { "./util.js": 38 }], 12: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseReduce = Promise2.reduce;
          Promise2.prototype.each = function(fn) {
            return PromiseReduce(this, fn, null, INTERNAL);
          };
          Promise2.each = function(promises, fn) {
            return PromiseReduce(promises, fn, null, INTERNAL);
          };
        };
      }, {}], 13: [function(_dereq_2, module2, exports2) {
        "use strict";
        var es52 = _dereq_2("./es5.js");
        var Objectfreeze = es52.freeze;
        var util = _dereq_2("./util.js");
        var inherits2 = util.inherits;
        var notEnumerableProp2 = util.notEnumerableProp;
        function subError(nameProperty, defaultMessage) {
          function SubError(message) {
            if (!(this instanceof SubError))
              return new SubError(message);
            notEnumerableProp2(
              this,
              "message",
              typeof message === "string" ? message : defaultMessage
            );
            notEnumerableProp2(this, "name", nameProperty);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            } else {
              Error.call(this);
            }
          }
          inherits2(SubError, Error);
          return SubError;
        }
        var _TypeError, _RangeError;
        var Warning = subError("Warning", "warning");
        var CancellationError = subError("CancellationError", "cancellation error");
        var TimeoutError = subError("TimeoutError", "timeout error");
        var AggregateError = subError("AggregateError", "aggregate error");
        try {
          _TypeError = TypeError;
          _RangeError = RangeError;
        } catch (e) {
          _TypeError = subError("TypeError", "type error");
          _RangeError = subError("RangeError", "range error");
        }
        var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
        for (var i = 0; i < methods.length; ++i) {
          if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
          }
        }
        es52.defineProperty(AggregateError.prototype, "length", {
          value: 0,
          configurable: false,
          writable: true,
          enumerable: true
        });
        AggregateError.prototype["isOperational"] = true;
        var level = 0;
        AggregateError.prototype.toString = function() {
          var indent = Array(level * 4 + 1).join(" ");
          var ret2 = "\n" + indent + "AggregateError of:\n";
          level++;
          indent = Array(level * 4 + 1).join(" ");
          for (var i2 = 0; i2 < this.length; ++i2) {
            var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
              lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret2 += str + "\n";
          }
          level--;
          return ret2;
        };
        function OperationalError(message) {
          if (!(this instanceof OperationalError))
            return new OperationalError(message);
          notEnumerableProp2(this, "name", "OperationalError");
          notEnumerableProp2(this, "message", message);
          this.cause = message;
          this["isOperational"] = true;
          if (message instanceof Error) {
            notEnumerableProp2(this, "message", message.message);
            notEnumerableProp2(this, "stack", message.stack);
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        inherits2(OperationalError, Error);
        var errorTypes = Error["__BluebirdErrorTypes__"];
        if (!errorTypes) {
          errorTypes = Objectfreeze({
            CancellationError,
            TimeoutError,
            OperationalError,
            RejectionError: OperationalError,
            AggregateError
          });
          notEnumerableProp2(Error, "__BluebirdErrorTypes__", errorTypes);
        }
        module2.exports = {
          Error,
          TypeError: _TypeError,
          RangeError: _RangeError,
          CancellationError: errorTypes.CancellationError,
          OperationalError: errorTypes.OperationalError,
          TimeoutError: errorTypes.TimeoutError,
          AggregateError: errorTypes.AggregateError,
          Warning
        };
      }, { "./es5.js": 14, "./util.js": 38 }], 14: [function(_dereq_2, module2, exports2) {
        var isES5 = function() {
          "use strict";
          return this === void 0;
        }();
        if (isES5) {
          module2.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5,
            propertyIsWritable: function(obj2, prop) {
              var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
              return !!(!descriptor || descriptor.writable || descriptor.set);
            }
          };
        } else {
          var has3 = {}.hasOwnProperty;
          var str = {}.toString;
          var proto = {}.constructor.prototype;
          var ObjectKeys = function(o) {
            var ret2 = [];
            for (var key in o) {
              if (has3.call(o, key)) {
                ret2.push(key);
              }
            }
            return ret2;
          };
          var ObjectGetDescriptor = function(o, key) {
            return { value: o[key] };
          };
          var ObjectDefineProperty = function(o, key, desc) {
            o[key] = desc.value;
            return o;
          };
          var ObjectFreeze = function(obj2) {
            return obj2;
          };
          var ObjectGetPrototypeOf = function(obj2) {
            try {
              return Object(obj2).constructor.prototype;
            } catch (e) {
              return proto;
            }
          };
          var ArrayIsArray = function(obj2) {
            try {
              return str.call(obj2) === "[object Array]";
            } catch (e) {
              return false;
            }
          };
          module2.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5,
            propertyIsWritable: function() {
              return true;
            }
          };
        }
      }, {}], 15: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseMap = Promise2.map;
          Promise2.prototype.filter = function(fn, options) {
            return PromiseMap(this, fn, options, INTERNAL);
          };
          Promise2.filter = function(promises, fn, options) {
            return PromiseMap(promises, fn, options, INTERNAL);
          };
        };
      }, {}], 16: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, NEXT_FILTER, tryConvertToPromise) {
          var util = _dereq_2("./util.js");
          var isPrimitive2 = util.isPrimitive;
          var thrower2 = util.thrower;
          function returnThis() {
            return this;
          }
          function throwThis() {
            throw this;
          }
          function return$(r) {
            return function() {
              return r;
            };
          }
          function throw$(r) {
            return function() {
              throw r;
            };
          }
          function promisedFinally(ret2, reasonOrValue, isFulfilled) {
            var then;
            if (isPrimitive2(reasonOrValue)) {
              then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
            } else {
              then = isFulfilled ? returnThis : throwThis;
            }
            return ret2._then(then, thrower2, void 0, reasonOrValue, void 0);
          }
          function finallyHandler(reasonOrValue) {
            var promise = this.promise;
            var handler = this.handler;
            var ret2 = promise._isBound() ? handler.call(promise._boundValue()) : handler();
            if (ret2 !== void 0) {
              var maybePromise = tryConvertToPromise(ret2, promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                return promisedFinally(
                  maybePromise,
                  reasonOrValue,
                  promise.isFulfilled()
                );
              }
            }
            if (promise.isRejected()) {
              NEXT_FILTER.e = reasonOrValue;
              return NEXT_FILTER;
            } else {
              return reasonOrValue;
            }
          }
          function tapHandler(value) {
            var promise = this.promise;
            var handler = this.handler;
            var ret2 = promise._isBound() ? handler.call(promise._boundValue(), value) : handler(value);
            if (ret2 !== void 0) {
              var maybePromise = tryConvertToPromise(ret2, promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, value, true);
              }
            }
            return value;
          }
          Promise2.prototype._passThroughHandler = function(handler, isFinally) {
            if (typeof handler !== "function")
              return this.then();
            var promiseAndHandler = {
              promise: this,
              handler
            };
            return this._then(
              isFinally ? finallyHandler : tapHandler,
              isFinally ? finallyHandler : void 0,
              void 0,
              promiseAndHandler,
              void 0
            );
          };
          Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
            return this._passThroughHandler(handler, true);
          };
          Promise2.prototype.tap = function(handler) {
            return this._passThroughHandler(handler, false);
          };
        };
      }, { "./util.js": 38 }], 17: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise) {
          var errors = _dereq_2("./errors.js");
          var TypeError2 = errors.TypeError;
          var util = _dereq_2("./util.js");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var yieldHandlers = [];
          function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
            for (var i = 0; i < yieldHandlers2.length; ++i) {
              traceParent._pushContext();
              var result2 = tryCatch2(yieldHandlers2[i])(value);
              traceParent._popContext();
              if (result2 === errorObj2) {
                traceParent._pushContext();
                var ret2 = Promise2.reject(errorObj2.e);
                traceParent._popContext();
                return ret2;
              }
              var maybePromise = tryConvertToPromise(result2, traceParent);
              if (maybePromise instanceof Promise2)
                return maybePromise;
            }
            return null;
          }
          function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
            var promise = this._promise = new Promise2(INTERNAL);
            promise._captureStackTrace();
            this._stack = stack;
            this._generatorFunction = generatorFunction;
            this._receiver = receiver;
            this._generator = void 0;
            this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
          }
          PromiseSpawn.prototype.promise = function() {
            return this._promise;
          };
          PromiseSpawn.prototype._run = function() {
            this._generator = this._generatorFunction.call(this._receiver);
            this._receiver = this._generatorFunction = void 0;
            this._next(void 0);
          };
          PromiseSpawn.prototype._continue = function(result2) {
            if (result2 === errorObj2) {
              return this._promise._rejectCallback(result2.e, false, true);
            }
            var value = result2.value;
            if (result2.done === true) {
              this._promise._resolveCallback(value);
            } else {
              var maybePromise = tryConvertToPromise(value, this._promise);
              if (!(maybePromise instanceof Promise2)) {
                maybePromise = promiseFromYieldHandler(
                  maybePromise,
                  this._yieldHandlers,
                  this._promise
                );
                if (maybePromise === null) {
                  this._throw(
                    new TypeError2(
                      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                    )
                  );
                  return;
                }
              }
              maybePromise._then(
                this._next,
                this._throw,
                void 0,
                this,
                null
              );
            }
          };
          PromiseSpawn.prototype._throw = function(reason) {
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            var result2 = tryCatch2(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
            this._continue(result2);
          };
          PromiseSpawn.prototype._next = function(value) {
            this._promise._pushContext();
            var result2 = tryCatch2(this._generator.next).call(this._generator, value);
            this._promise._popContext();
            this._continue(result2);
          };
          Promise2.coroutine = function(generatorFunction, options) {
            if (typeof generatorFunction !== "function") {
              throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n");
            }
            var yieldHandler = Object(options).yieldHandler;
            var PromiseSpawn$ = PromiseSpawn;
            var stack = new Error().stack;
            return function() {
              var generator = generatorFunction.apply(this, arguments);
              var spawn = new PromiseSpawn$(
                void 0,
                void 0,
                yieldHandler,
                stack
              );
              spawn._generator = generator;
              spawn._next(void 0);
              return spawn.promise();
            };
          };
          Promise2.coroutine.addYieldHandler = function(fn) {
            if (typeof fn !== "function")
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            yieldHandlers.push(fn);
          };
          Promise2.spawn = function(generatorFunction) {
            if (typeof generatorFunction !== "function") {
              return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n");
            }
            var spawn = new PromiseSpawn(generatorFunction, this);
            var ret2 = spawn.promise();
            spawn._run(Promise2.spawn);
            return ret2;
          };
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 18: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL) {
          var util = _dereq_2("./util.js");
          var canEvaluate2 = util.canEvaluate;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var reject2;
          if (false) {
            if (canEvaluate2) {
              var thenCallback = function(i2) {
                return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
              };
              var caller = function(count) {
                var values2 = [];
                for (var i2 = 1; i2 <= count; ++i2)
                  values2.push("holder.p" + i2);
                return new Function("holder", "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ".replace(/values/g, values2.join(", ")));
              };
              var thenCallbacks = [];
              var callers = [void 0];
              for (var i = 1; i <= 5; ++i) {
                thenCallbacks.push(thenCallback(i));
                callers.push(caller(i));
              }
              var Holder = function(total, fn) {
                this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                this.fn = fn;
                this.total = total;
                this.now = 0;
              };
              Holder.prototype.callers = callers;
              Holder.prototype.checkFulfillment = function(promise) {
                var now = this.now;
                now++;
                var total = this.total;
                if (now >= total) {
                  var handler = this.callers[total];
                  promise._pushContext();
                  var ret2 = tryCatch2(handler)(this);
                  promise._popContext();
                  if (ret2 === errorObj2) {
                    promise._rejectCallback(ret2.e, false, true);
                  } else {
                    promise._resolveCallback(ret2);
                  }
                } else {
                  this.now = now;
                }
              };
              var reject2 = function(reason) {
                this._reject(reason);
              };
            }
          }
          Promise2.join = function() {
            var last2 = arguments.length - 1;
            var fn;
            if (last2 > 0 && typeof arguments[last2] === "function") {
              fn = arguments[last2];
              if (false) {
                if (last2 < 6 && canEvaluate2) {
                  var ret2 = new Promise2(INTERNAL);
                  ret2._captureStackTrace();
                  var holder = new Holder(last2, fn);
                  var callbacks = thenCallbacks;
                  for (var i2 = 0; i2 < last2; ++i2) {
                    var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                    if (maybePromise instanceof Promise2) {
                      maybePromise = maybePromise._target();
                      if (maybePromise._isPending()) {
                        maybePromise._then(
                          callbacks[i2],
                          reject2,
                          void 0,
                          ret2,
                          holder
                        );
                      } else if (maybePromise._isFulfilled()) {
                        callbacks[i2].call(
                          ret2,
                          maybePromise._value(),
                          holder
                        );
                      } else {
                        ret2._reject(maybePromise._reason());
                      }
                    } else {
                      callbacks[i2].call(ret2, maybePromise, holder);
                    }
                  }
                  return ret2;
                }
              }
            }
            var $_len = arguments.length;
            var args = new Array($_len);
            for (var $_i = 0; $_i < $_len; ++$_i) {
              args[$_i] = arguments[$_i];
            }
            if (fn)
              args.pop();
            var ret2 = new PromiseArray(args).promise();
            return fn !== void 0 ? ret2.spread(fn) : ret2;
          };
        };
      }, { "./util.js": 38 }], 19: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var PENDING = {};
          var EMPTY_ARRAY = [];
          function MappingPromiseArray(promises, fn, limit, _filter) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            var domain = getDomain();
            this._callback = domain === null ? fn : domain.bind(fn);
            this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
            this._limit = limit;
            this._inFlight = 0;
            this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
            async.invoke(init, this, void 0);
          }
          util.inherits(MappingPromiseArray, PromiseArray);
          function init() {
            this._init$(void 0, -2);
          }
          MappingPromiseArray.prototype._init = function() {
          };
          MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values2 = this._values;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var limit = this._limit;
            if (values2[index] === PENDING) {
              values2[index] = value;
              if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved())
                  return;
              }
            } else {
              if (limit >= 1 && this._inFlight >= limit) {
                values2[index] = value;
                this._queue.push(index);
                return;
              }
              if (preservedValues !== null)
                preservedValues[index] = value;
              var callback = this._callback;
              var receiver = this._promise._boundValue();
              this._promise._pushContext();
              var ret2 = tryCatch2(callback).call(receiver, value, index, length);
              this._promise._popContext();
              if (ret2 === errorObj2)
                return this._reject(ret2.e);
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  if (limit >= 1)
                    this._inFlight++;
                  values2[index] = PENDING;
                  return maybePromise._proxyPromiseArray(this, index);
                } else if (maybePromise._isFulfilled()) {
                  ret2 = maybePromise._value();
                } else {
                  return this._reject(maybePromise._reason());
                }
              }
              values2[index] = ret2;
            }
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= length) {
              if (preservedValues !== null) {
                this._filter(values2, preservedValues);
              } else {
                this._resolve(values2);
              }
            }
          };
          MappingPromiseArray.prototype._drainQueue = function() {
            var queue = this._queue;
            var limit = this._limit;
            var values2 = this._values;
            while (queue.length > 0 && this._inFlight < limit) {
              if (this._isResolved())
                return;
              var index = queue.pop();
              this._promiseFulfilled(values2[index], index);
            }
          };
          MappingPromiseArray.prototype._filter = function(booleans, values2) {
            var len = values2.length;
            var ret2 = new Array(len);
            var j = 0;
            for (var i = 0; i < len; ++i) {
              if (booleans[i])
                ret2[j++] = values2[i];
            }
            ret2.length = j;
            this._resolve(ret2);
          };
          MappingPromiseArray.prototype.preservedValues = function() {
            return this._preservedValues;
          };
          function map2(promises, fn, options, _filter) {
            var limit = typeof options === "object" && options !== null ? options.concurrency : 0;
            limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
            return new MappingPromiseArray(promises, fn, limit, _filter);
          }
          Promise2.prototype.map = function(fn, options) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            return map2(this, fn, options, null).promise();
          };
          Promise2.map = function(promises, fn, options, _filter) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            return map2(promises, fn, options, _filter).promise();
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 20: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          Promise2.method = function(fn) {
            if (typeof fn !== "function") {
              throw new Promise2.TypeError("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            return function() {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._pushContext();
              var value = tryCatch2(fn).apply(this, arguments);
              ret2._popContext();
              ret2._resolveFromSyncValue(value);
              return ret2;
            };
          };
          Promise2.attempt = Promise2["try"] = function(fn, args, ctx) {
            if (typeof fn !== "function") {
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._pushContext();
            var value = util.isArray(args) ? tryCatch2(fn).apply(ctx, args) : tryCatch2(fn).call(ctx, args);
            ret2._popContext();
            ret2._resolveFromSyncValue(value);
            return ret2;
          };
          Promise2.prototype._resolveFromSyncValue = function(value) {
            if (value === util.errorObj) {
              this._rejectCallback(value.e, false, true);
            } else {
              this._resolveCallback(value, true);
            }
          };
        };
      }, { "./util.js": 38 }], 21: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util.js");
          var async = _dereq_2("./async.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function spreadAdapter(val, nodeback) {
            var promise = this;
            if (!util.isArray(val))
              return successAdapter.call(promise, val, nodeback);
            var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function successAdapter(val, nodeback) {
            var promise = this;
            var receiver = promise._boundValue();
            var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function errorAdapter(reason, nodeback) {
            var promise = this;
            if (!reason) {
              var target = promise._target();
              var newReason = target._getCarriedStackTrace();
              newReason.cause = reason;
              reason = newReason;
            }
            var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
            if (typeof nodeback == "function") {
              var adapter = successAdapter;
              if (options !== void 0 && Object(options).spread) {
                adapter = spreadAdapter;
              }
              this._then(
                adapter,
                errorAdapter,
                void 0,
                this,
                nodeback
              );
            }
            return this;
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 22: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray) {
          var util = _dereq_2("./util.js");
          var async = _dereq_2("./async.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          Promise2.prototype.progressed = function(handler) {
            return this._then(void 0, void 0, handler, void 0, void 0);
          };
          Promise2.prototype._progress = function(progressValue) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._target()._progressUnchecked(progressValue);
          };
          Promise2.prototype._progressHandlerAt = function(index) {
            return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2];
          };
          Promise2.prototype._doProgressWith = function(progression) {
            var progressValue = progression.value;
            var handler = progression.handler;
            var promise = progression.promise;
            var receiver = progression.receiver;
            var ret2 = tryCatch2(handler).call(receiver, progressValue);
            if (ret2 === errorObj2) {
              if (ret2.e != null && ret2.e.name !== "StopProgressPropagation") {
                var trace = util.canAttachTrace(ret2.e) ? ret2.e : new Error(util.toString(ret2.e));
                promise._attachExtraTrace(trace);
                promise._progress(ret2.e);
              }
            } else if (ret2 instanceof Promise2) {
              ret2._then(promise._progress, null, null, promise, void 0);
            } else {
              promise._progress(ret2);
            }
          };
          Promise2.prototype._progressUnchecked = function(progressValue) {
            var len = this._length();
            var progress = this._progress;
            for (var i = 0; i < len; i++) {
              var handler = this._progressHandlerAt(i);
              var promise = this._promiseAt(i);
              if (!(promise instanceof Promise2)) {
                var receiver = this._receiverAt(i);
                if (typeof handler === "function") {
                  handler.call(receiver, progressValue, promise);
                } else if (receiver instanceof PromiseArray && !receiver._isResolved()) {
                  receiver._promiseProgressed(progressValue, promise);
                }
                continue;
              }
              if (typeof handler === "function") {
                async.invoke(this._doProgressWith, this, {
                  handler,
                  promise,
                  receiver: this._receiverAt(i),
                  value: progressValue
                });
              } else {
                async.invoke(progress, promise, progressValue);
              }
            }
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 23: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var makeSelfResolutionError = function() {
            return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n");
          };
          var reflect = function() {
            return new Promise2.PromiseInspection(this._target());
          };
          var apiRejection = function(msg) {
            return Promise2.reject(new TypeError2(msg));
          };
          var util = _dereq_2("./util.js");
          var getDomain;
          if (util.isNode) {
            getDomain = function() {
              var ret2 = process.domain;
              if (ret2 === void 0)
                ret2 = null;
              return ret2;
            };
          } else {
            getDomain = function() {
              return null;
            };
          }
          util.notEnumerableProp(Promise2, "_getDomain", getDomain);
          var async = _dereq_2("./async.js");
          var errors = _dereq_2("./errors.js");
          var TypeError2 = Promise2.TypeError = errors.TypeError;
          Promise2.RangeError = errors.RangeError;
          Promise2.CancellationError = errors.CancellationError;
          Promise2.TimeoutError = errors.TimeoutError;
          Promise2.OperationalError = errors.OperationalError;
          Promise2.RejectionError = errors.OperationalError;
          Promise2.AggregateError = errors.AggregateError;
          var INTERNAL = function() {
          };
          var APPLY = {};
          var NEXT_FILTER = { e: null };
          var tryConvertToPromise = _dereq_2("./thenables.js")(Promise2, INTERNAL);
          var PromiseArray = _dereq_2("./promise_array.js")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection
          );
          var CapturedTrace = _dereq_2("./captured_trace.js")();
          var isDebugging = _dereq_2("./debuggability.js")(Promise2, CapturedTrace);
          var createContext = _dereq_2("./context.js")(Promise2, CapturedTrace, isDebugging);
          var CatchFilter = _dereq_2("./catch_filter.js")(NEXT_FILTER);
          var PromiseResolver = _dereq_2("./promise_resolver.js");
          var nodebackForPromise = PromiseResolver._nodebackForPromise;
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          function Promise2(resolver) {
            if (typeof resolver !== "function") {
              throw new TypeError2("the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n");
            }
            if (this.constructor !== Promise2) {
              throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n");
            }
            this._bitField = 0;
            this._fulfillmentHandler0 = void 0;
            this._rejectionHandler0 = void 0;
            this._progressHandler0 = void 0;
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._settledValue = void 0;
            if (resolver !== INTERNAL)
              this._resolveFromResolver(resolver);
          }
          Promise2.prototype.toString = function() {
            return "[object Promise]";
          };
          Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
            var len = arguments.length;
            if (len > 1) {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (typeof item === "function") {
                  catchInstances[j++] = item;
                } else {
                  return Promise2.reject(
                    new TypeError2("Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n")
                  );
                }
              }
              catchInstances.length = j;
              fn = arguments[i];
              var catchFilter = new CatchFilter(catchInstances, fn, this);
              return this._then(
                void 0,
                catchFilter.doFilter,
                void 0,
                catchFilter,
                void 0
              );
            }
            return this._then(void 0, fn, void 0, void 0, void 0);
          };
          Promise2.prototype.reflect = function() {
            return this._then(reflect, reflect, void 0, this, void 0);
          };
          Promise2.prototype.then = function(didFulfill, didReject, didProgress) {
            if (isDebugging() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
              var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
              if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
              }
              this._warn(msg);
            }
            return this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
          };
          Promise2.prototype.done = function(didFulfill, didReject, didProgress) {
            var promise = this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
            promise._setIsFinal();
          };
          Promise2.prototype.spread = function(didFulfill, didReject) {
            return this.all()._then(didFulfill, didReject, void 0, APPLY, void 0);
          };
          Promise2.prototype.isCancellable = function() {
            return !this.isResolved() && this._cancellable();
          };
          Promise2.prototype.toJSON = function() {
            var ret2 = {
              isFulfilled: false,
              isRejected: false,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            if (this.isFulfilled()) {
              ret2.fulfillmentValue = this.value();
              ret2.isFulfilled = true;
            } else if (this.isRejected()) {
              ret2.rejectionReason = this.reason();
              ret2.isRejected = true;
            }
            return ret2;
          };
          Promise2.prototype.all = function() {
            return new PromiseArray(this).promise();
          };
          Promise2.prototype.error = function(fn) {
            return this.caught(util.originatesFromRejection, fn);
          };
          Promise2.is = function(val) {
            return val instanceof Promise2;
          };
          Promise2.fromNode = function(fn) {
            var ret2 = new Promise2(INTERNAL);
            var result2 = tryCatch2(fn)(nodebackForPromise(ret2));
            if (result2 === errorObj2) {
              ret2._rejectCallback(result2.e, true, true);
            }
            return ret2;
          };
          Promise2.all = function(promises) {
            return new PromiseArray(promises).promise();
          };
          Promise2.defer = Promise2.pending = function() {
            var promise = new Promise2(INTERNAL);
            return new PromiseResolver(promise);
          };
          Promise2.cast = function(obj2) {
            var ret2 = tryConvertToPromise(obj2);
            if (!(ret2 instanceof Promise2)) {
              var val = ret2;
              ret2 = new Promise2(INTERNAL);
              ret2._fulfillUnchecked(val);
            }
            return ret2;
          };
          Promise2.resolve = Promise2.fulfilled = Promise2.cast;
          Promise2.reject = Promise2.rejected = function(reason) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._rejectCallback(reason, true);
            return ret2;
          };
          Promise2.setScheduler = function(fn) {
            if (typeof fn !== "function")
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var prev = async._schedule;
            async._schedule = fn;
            return prev;
          };
          Promise2.prototype._then = function(didFulfill, didReject, didProgress, receiver, internalData) {
            var haveInternalData = internalData !== void 0;
            var ret2 = haveInternalData ? internalData : new Promise2(INTERNAL);
            if (!haveInternalData) {
              ret2._propagateFrom(this, 4 | 1);
              ret2._captureStackTrace();
            }
            var target = this._target();
            if (target !== this) {
              if (receiver === void 0)
                receiver = this._boundTo;
              if (!haveInternalData)
                ret2._setIsMigrated();
            }
            var callbackIndex = target._addCallbacks(
              didFulfill,
              didReject,
              didProgress,
              ret2,
              receiver,
              getDomain()
            );
            if (target._isResolved() && !target._isSettlePromisesQueued()) {
              async.invoke(
                target._settlePromiseAtPostResolution,
                target,
                callbackIndex
              );
            }
            return ret2;
          };
          Promise2.prototype._settlePromiseAtPostResolution = function(index) {
            if (this._isRejectionUnhandled())
              this._unsetRejectionIsUnhandled();
            this._settlePromiseAt(index);
          };
          Promise2.prototype._length = function() {
            return this._bitField & 131071;
          };
          Promise2.prototype._isFollowingOrFulfilledOrRejected = function() {
            return (this._bitField & 939524096) > 0;
          };
          Promise2.prototype._isFollowing = function() {
            return (this._bitField & 536870912) === 536870912;
          };
          Promise2.prototype._setLength = function(len) {
            this._bitField = this._bitField & -131072 | len & 131071;
          };
          Promise2.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 268435456;
          };
          Promise2.prototype._setRejected = function() {
            this._bitField = this._bitField | 134217728;
          };
          Promise2.prototype._setFollowing = function() {
            this._bitField = this._bitField | 536870912;
          };
          Promise2.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 33554432;
          };
          Promise2.prototype._isFinal = function() {
            return (this._bitField & 33554432) > 0;
          };
          Promise2.prototype._cancellable = function() {
            return (this._bitField & 67108864) > 0;
          };
          Promise2.prototype._setCancellable = function() {
            this._bitField = this._bitField | 67108864;
          };
          Promise2.prototype._unsetCancellable = function() {
            this._bitField = this._bitField & ~67108864;
          };
          Promise2.prototype._setIsMigrated = function() {
            this._bitField = this._bitField | 4194304;
          };
          Promise2.prototype._unsetIsMigrated = function() {
            this._bitField = this._bitField & ~4194304;
          };
          Promise2.prototype._isMigrated = function() {
            return (this._bitField & 4194304) > 0;
          };
          Promise2.prototype._receiverAt = function(index) {
            var ret2 = index === 0 ? this._receiver0 : this[index * 5 - 5 + 4];
            if (ret2 === void 0 && this._isBound()) {
              return this._boundValue();
            }
            return ret2;
          };
          Promise2.prototype._promiseAt = function(index) {
            return index === 0 ? this._promise0 : this[index * 5 - 5 + 3];
          };
          Promise2.prototype._fulfillmentHandlerAt = function(index) {
            return index === 0 ? this._fulfillmentHandler0 : this[index * 5 - 5 + 0];
          };
          Promise2.prototype._rejectionHandlerAt = function(index) {
            return index === 0 ? this._rejectionHandler0 : this[index * 5 - 5 + 1];
          };
          Promise2.prototype._boundValue = function() {
            var ret2 = this._boundTo;
            if (ret2 !== void 0) {
              if (ret2 instanceof Promise2) {
                if (ret2.isFulfilled()) {
                  return ret2.value();
                } else {
                  return void 0;
                }
              }
            }
            return ret2;
          };
          Promise2.prototype._migrateCallbacks = function(follower, index) {
            var fulfill = follower._fulfillmentHandlerAt(index);
            var reject2 = follower._rejectionHandlerAt(index);
            var progress = follower._progressHandlerAt(index);
            var promise = follower._promiseAt(index);
            var receiver = follower._receiverAt(index);
            if (promise instanceof Promise2)
              promise._setIsMigrated();
            this._addCallbacks(fulfill, reject2, progress, promise, receiver, null);
          };
          Promise2.prototype._addCallbacks = function(fulfill, reject2, progress, promise, receiver, domain) {
            var index = this._length();
            if (index >= 131071 - 5) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promise;
              if (receiver !== void 0)
                this._receiver0 = receiver;
              if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill);
              }
              if (typeof reject2 === "function") {
                this._rejectionHandler0 = domain === null ? reject2 : domain.bind(reject2);
              }
              if (typeof progress === "function") {
                this._progressHandler0 = domain === null ? progress : domain.bind(progress);
              }
            } else {
              var base = index * 5 - 5;
              this[base + 3] = promise;
              this[base + 4] = receiver;
              if (typeof fulfill === "function") {
                this[base + 0] = domain === null ? fulfill : domain.bind(fulfill);
              }
              if (typeof reject2 === "function") {
                this[base + 1] = domain === null ? reject2 : domain.bind(reject2);
              }
              if (typeof progress === "function") {
                this[base + 2] = domain === null ? progress : domain.bind(progress);
              }
            }
            this._setLength(index + 1);
            return index;
          };
          Promise2.prototype._setProxyHandlers = function(receiver, promiseSlotValue) {
            var index = this._length();
            if (index >= 131071 - 5) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promiseSlotValue;
              this._receiver0 = receiver;
            } else {
              var base = index * 5 - 5;
              this[base + 3] = promiseSlotValue;
              this[base + 4] = receiver;
            }
            this._setLength(index + 1);
          };
          Promise2.prototype._proxyPromiseArray = function(promiseArray, index) {
            this._setProxyHandlers(promiseArray, index);
          };
          Promise2.prototype._resolveCallback = function(value, shouldBind) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            if (value === this)
              return this._rejectCallback(makeSelfResolutionError(), false, true);
            var maybePromise = tryConvertToPromise(value, this);
            if (!(maybePromise instanceof Promise2))
              return this._fulfill(value);
            var propagationFlags = 1 | (shouldBind ? 4 : 0);
            this._propagateFrom(maybePromise, propagationFlags);
            var promise = maybePromise._target();
            if (promise._isPending()) {
              var len = this._length();
              for (var i = 0; i < len; ++i) {
                promise._migrateCallbacks(this, i);
              }
              this._setFollowing();
              this._setLength(0);
              this._setFollowee(promise);
            } else if (promise._isFulfilled()) {
              this._fulfillUnchecked(promise._value());
            } else {
              this._rejectUnchecked(
                promise._reason(),
                promise._getCarriedStackTrace()
              );
            }
          };
          Promise2.prototype._rejectCallback = function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
            if (!shouldNotMarkOriginatingFromRejection) {
              util.markAsOriginatingFromRejection(reason);
            }
            var trace = util.ensureErrorObject(reason);
            var hasStack = trace === reason;
            this._attachExtraTrace(trace, synchronous ? hasStack : false);
            this._reject(reason, hasStack ? void 0 : trace);
          };
          Promise2.prototype._resolveFromResolver = function(resolver) {
            var promise = this;
            this._captureStackTrace();
            this._pushContext();
            var synchronous = true;
            var r = tryCatch2(resolver)(function(value) {
              if (promise === null)
                return;
              promise._resolveCallback(value);
              promise = null;
            }, function(reason) {
              if (promise === null)
                return;
              promise._rejectCallback(reason, synchronous);
              promise = null;
            });
            synchronous = false;
            this._popContext();
            if (r !== void 0 && r === errorObj2 && promise !== null) {
              promise._rejectCallback(r.e, true, true);
              promise = null;
            }
          };
          Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
            if (promise._isRejected())
              return;
            promise._pushContext();
            var x;
            if (receiver === APPLY && !this._isRejected()) {
              x = tryCatch2(handler).apply(this._boundValue(), value);
            } else {
              x = tryCatch2(handler).call(receiver, value);
            }
            promise._popContext();
            if (x === errorObj2 || x === promise || x === NEXT_FILTER) {
              var err = x === promise ? makeSelfResolutionError() : x.e;
              promise._rejectCallback(err, false, true);
            } else {
              promise._resolveCallback(x);
            }
          };
          Promise2.prototype._target = function() {
            var ret2 = this;
            while (ret2._isFollowing())
              ret2 = ret2._followee();
            return ret2;
          };
          Promise2.prototype._followee = function() {
            return this._rejectionHandler0;
          };
          Promise2.prototype._setFollowee = function(promise) {
            this._rejectionHandler0 = promise;
          };
          Promise2.prototype._cleanValues = function() {
            if (this._cancellable()) {
              this._cancellationParent = void 0;
            }
          };
          Promise2.prototype._propagateFrom = function(parent, flags) {
            if ((flags & 1) > 0 && parent._cancellable()) {
              this._setCancellable();
              this._cancellationParent = parent;
            }
            if ((flags & 4) > 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          };
          Promise2.prototype._fulfill = function(value) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._fulfillUnchecked(value);
          };
          Promise2.prototype._reject = function(reason, carriedStackTrace) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._rejectUnchecked(reason, carriedStackTrace);
          };
          Promise2.prototype._settlePromiseAt = function(index) {
            var promise = this._promiseAt(index);
            var isPromise = promise instanceof Promise2;
            if (isPromise && promise._isMigrated()) {
              promise._unsetIsMigrated();
              return async.invoke(this._settlePromiseAt, this, index);
            }
            var handler = this._isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
            var carriedStackTrace = this._isCarryingStackTrace() ? this._getCarriedStackTrace() : void 0;
            var value = this._settledValue;
            var receiver = this._receiverAt(index);
            this._clearCallbackDataAtIndex(index);
            if (typeof handler === "function") {
              if (!isPromise) {
                handler.call(receiver, value, promise);
              } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
              }
            } else if (receiver instanceof PromiseArray) {
              if (!receiver._isResolved()) {
                if (this._isFulfilled()) {
                  receiver._promiseFulfilled(value, promise);
                } else {
                  receiver._promiseRejected(value, promise);
                }
              }
            } else if (isPromise) {
              if (this._isFulfilled()) {
                promise._fulfill(value);
              } else {
                promise._reject(value, carriedStackTrace);
              }
            }
            if (index >= 4 && (index & 31) === 4)
              async.invokeLater(this._setLength, this, 0);
          };
          Promise2.prototype._clearCallbackDataAtIndex = function(index) {
            if (index === 0) {
              if (!this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = void 0;
              }
              this._rejectionHandler0 = this._progressHandler0 = this._receiver0 = this._promise0 = void 0;
            } else {
              var base = index * 5 - 5;
              this[base + 3] = this[base + 4] = this[base + 0] = this[base + 1] = this[base + 2] = void 0;
            }
          };
          Promise2.prototype._isSettlePromisesQueued = function() {
            return (this._bitField & -1073741824) === -1073741824;
          };
          Promise2.prototype._setSettlePromisesQueued = function() {
            this._bitField = this._bitField | -1073741824;
          };
          Promise2.prototype._unsetSettlePromisesQueued = function() {
            this._bitField = this._bitField & ~-1073741824;
          };
          Promise2.prototype._queueSettlePromises = function() {
            async.settlePromises(this);
            this._setSettlePromisesQueued();
          };
          Promise2.prototype._fulfillUnchecked = function(value) {
            if (value === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._rejectUnchecked(err, void 0);
            }
            this._setFulfilled();
            this._settledValue = value;
            this._cleanValues();
            if (this._length() > 0) {
              this._queueSettlePromises();
            }
          };
          Promise2.prototype._rejectUncheckedCheckError = function(reason) {
            var trace = util.ensureErrorObject(reason);
            this._rejectUnchecked(reason, trace === reason ? void 0 : trace);
          };
          Promise2.prototype._rejectUnchecked = function(reason, trace) {
            if (reason === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._rejectUnchecked(err);
            }
            this._setRejected();
            this._settledValue = reason;
            this._cleanValues();
            if (this._isFinal()) {
              async.throwLater(function(e) {
                if ("stack" in e) {
                  async.invokeFirst(
                    CapturedTrace.unhandledRejection,
                    void 0,
                    e
                  );
                }
                throw e;
              }, trace === void 0 ? reason : trace);
              return;
            }
            if (trace !== void 0 && trace !== reason) {
              this._setCarriedStackTrace(trace);
            }
            if (this._length() > 0) {
              this._queueSettlePromises();
            } else {
              this._ensurePossibleRejectionHandled();
            }
          };
          Promise2.prototype._settlePromises = function() {
            this._unsetSettlePromisesQueued();
            var len = this._length();
            for (var i = 0; i < len; i++) {
              this._settlePromiseAt(i);
            }
          };
          util.notEnumerableProp(
            Promise2,
            "_makeSelfResolutionError",
            makeSelfResolutionError
          );
          _dereq_2("./progress.js")(Promise2, PromiseArray);
          _dereq_2("./method.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./bind.js")(Promise2, INTERNAL, tryConvertToPromise);
          _dereq_2("./finally.js")(Promise2, NEXT_FILTER, tryConvertToPromise);
          _dereq_2("./direct_resolve.js")(Promise2);
          _dereq_2("./synchronous_inspection.js")(Promise2);
          _dereq_2("./join.js")(Promise2, PromiseArray, tryConvertToPromise, INTERNAL);
          Promise2.Promise = Promise2;
          _dereq_2("./map.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
          _dereq_2("./cancel.js")(Promise2);
          _dereq_2("./using.js")(Promise2, apiRejection, tryConvertToPromise, createContext);
          _dereq_2("./generators.js")(Promise2, apiRejection, INTERNAL, tryConvertToPromise);
          _dereq_2("./nodeify.js")(Promise2);
          _dereq_2("./call_get.js")(Promise2);
          _dereq_2("./props.js")(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
          _dereq_2("./race.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./reduce.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
          _dereq_2("./settle.js")(Promise2, PromiseArray);
          _dereq_2("./some.js")(Promise2, PromiseArray, apiRejection);
          _dereq_2("./promisify.js")(Promise2, INTERNAL);
          _dereq_2("./any.js")(Promise2);
          _dereq_2("./each.js")(Promise2, INTERNAL);
          _dereq_2("./timers.js")(Promise2, INTERNAL);
          _dereq_2("./filter.js")(Promise2, INTERNAL);
          util.toFastProperties(Promise2);
          util.toFastProperties(Promise2.prototype);
          function fillTypes(value) {
            var p = new Promise2(INTERNAL);
            p._fulfillmentHandler0 = value;
            p._rejectionHandler0 = value;
            p._progressHandler0 = value;
            p._promise0 = value;
            p._receiver0 = value;
            p._settledValue = value;
          }
          fillTypes({ a: 1 });
          fillTypes({ b: 2 });
          fillTypes({ c: 3 });
          fillTypes(1);
          fillTypes(function() {
          });
          fillTypes(void 0);
          fillTypes(false);
          fillTypes(new Promise2(INTERNAL));
          CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
          return Promise2;
        };
      }, { "./any.js": 1, "./async.js": 2, "./bind.js": 3, "./call_get.js": 5, "./cancel.js": 6, "./captured_trace.js": 7, "./catch_filter.js": 8, "./context.js": 9, "./debuggability.js": 10, "./direct_resolve.js": 11, "./each.js": 12, "./errors.js": 13, "./filter.js": 15, "./finally.js": 16, "./generators.js": 17, "./join.js": 18, "./map.js": 19, "./method.js": 20, "./nodeify.js": 21, "./progress.js": 22, "./promise_array.js": 24, "./promise_resolver.js": 25, "./promisify.js": 26, "./props.js": 27, "./race.js": 29, "./reduce.js": 30, "./settle.js": 32, "./some.js": 33, "./synchronous_inspection.js": 34, "./thenables.js": 35, "./timers.js": 36, "./using.js": 37, "./util.js": 38 }], 24: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var isArray = util.isArray;
          function toResolutionValue(val) {
            switch (val) {
              case -2:
                return [];
              case -3:
                return {};
            }
          }
          function PromiseArray(values2) {
            var promise = this._promise = new Promise2(INTERNAL);
            var parent;
            if (values2 instanceof Promise2) {
              parent = values2;
              promise._propagateFrom(parent, 1 | 4);
            }
            this._values = values2;
            this._length = 0;
            this._totalResolved = 0;
            this._init(void 0, -2);
          }
          PromiseArray.prototype.length = function() {
            return this._length;
          };
          PromiseArray.prototype.promise = function() {
            return this._promise;
          };
          PromiseArray.prototype._init = function init(_3, resolveValueIfEmpty) {
            var values2 = tryConvertToPromise(this._values, this._promise);
            if (values2 instanceof Promise2) {
              values2 = values2._target();
              this._values = values2;
              if (values2._isFulfilled()) {
                values2 = values2._value();
                if (!isArray(values2)) {
                  var err = new Promise2.TypeError("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n");
                  this.__hardReject__(err);
                  return;
                }
              } else if (values2._isPending()) {
                values2._then(
                  init,
                  this._reject,
                  void 0,
                  this,
                  resolveValueIfEmpty
                );
                return;
              } else {
                this._reject(values2._reason());
                return;
              }
            } else if (!isArray(values2)) {
              this._promise._reject(apiRejection("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n")._reason());
              return;
            }
            if (values2.length === 0) {
              if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
              } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
              }
              return;
            }
            var len = this.getActualLength(values2.length);
            this._length = len;
            this._values = this.shouldCopyValues() ? new Array(len) : this._values;
            var promise = this._promise;
            for (var i = 0; i < len; ++i) {
              var isResolved = this._isResolved();
              var maybePromise = tryConvertToPromise(values2[i], promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (isResolved) {
                  maybePromise._ignoreRejections();
                } else if (maybePromise._isPending()) {
                  maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                  this._promiseFulfilled(maybePromise._value(), i);
                } else {
                  this._promiseRejected(maybePromise._reason(), i);
                }
              } else if (!isResolved) {
                this._promiseFulfilled(maybePromise, i);
              }
            }
          };
          PromiseArray.prototype._isResolved = function() {
            return this._values === null;
          };
          PromiseArray.prototype._resolve = function(value) {
            this._values = null;
            this._promise._fulfill(value);
          };
          PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function(reason) {
            this._values = null;
            this._promise._rejectCallback(reason, false, true);
          };
          PromiseArray.prototype._promiseProgressed = function(progressValue, index) {
            this._promise._progress({
              index,
              value: progressValue
            });
          };
          PromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
            }
          };
          PromiseArray.prototype._promiseRejected = function(reason, index) {
            this._totalResolved++;
            this._reject(reason);
          };
          PromiseArray.prototype.shouldCopyValues = function() {
            return true;
          };
          PromiseArray.prototype.getActualLength = function(len) {
            return len;
          };
          return PromiseArray;
        };
      }, { "./util.js": 38 }], 25: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util.js");
        var maybeWrapAsError2 = util.maybeWrapAsError;
        var errors = _dereq_2("./errors.js");
        var TimeoutError = errors.TimeoutError;
        var OperationalError = errors.OperationalError;
        var haveGetters2 = util.haveGetters;
        var es52 = _dereq_2("./es5.js");
        function isUntypedError(obj2) {
          return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
        }
        var rErrorKey = /^(?:name|message|stack|cause)$/;
        function wrapAsOperationalError(obj2) {
          var ret2;
          if (isUntypedError(obj2)) {
            ret2 = new OperationalError(obj2);
            ret2.name = obj2.name;
            ret2.message = obj2.message;
            ret2.stack = obj2.stack;
            var keys2 = es52.keys(obj2);
            for (var i = 0; i < keys2.length; ++i) {
              var key = keys2[i];
              if (!rErrorKey.test(key)) {
                ret2[key] = obj2[key];
              }
            }
            return ret2;
          }
          util.markAsOriginatingFromRejection(obj2);
          return obj2;
        }
        function nodebackForPromise(promise) {
          return function(err, value) {
            if (promise === null)
              return;
            if (err) {
              var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
              promise._attachExtraTrace(wrapped);
              promise._reject(wrapped);
            } else if (arguments.length > 2) {
              var $_len = arguments.length;
              var args = new Array($_len - 1);
              for (var $_i = 1; $_i < $_len; ++$_i) {
                args[$_i - 1] = arguments[$_i];
              }
              promise._fulfill(args);
            } else {
              promise._fulfill(value);
            }
            promise = null;
          };
        }
        var PromiseResolver;
        if (!haveGetters2) {
          PromiseResolver = function(promise) {
            this.promise = promise;
            this.asCallback = nodebackForPromise(promise);
            this.callback = this.asCallback;
          };
        } else {
          PromiseResolver = function(promise) {
            this.promise = promise;
          };
        }
        if (haveGetters2) {
          var prop = {
            get: function() {
              return nodebackForPromise(this.promise);
            }
          };
          es52.defineProperty(PromiseResolver.prototype, "asCallback", prop);
          es52.defineProperty(PromiseResolver.prototype, "callback", prop);
        }
        PromiseResolver._nodebackForPromise = nodebackForPromise;
        PromiseResolver.prototype.toString = function() {
          return "[object PromiseResolver]";
        };
        PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function(value) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._resolveCallback(value);
        };
        PromiseResolver.prototype.reject = function(reason) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._rejectCallback(reason);
        };
        PromiseResolver.prototype.progress = function(value) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._progress(value);
        };
        PromiseResolver.prototype.cancel = function(err) {
          this.promise.cancel(err);
        };
        PromiseResolver.prototype.timeout = function() {
          this.reject(new TimeoutError("timeout"));
        };
        PromiseResolver.prototype.isResolved = function() {
          return this.promise.isResolved();
        };
        PromiseResolver.prototype.toJSON = function() {
          return this.promise.toJSON();
        };
        module2.exports = PromiseResolver;
      }, { "./errors.js": 13, "./es5.js": 14, "./util.js": 38 }], 26: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var THIS = {};
          var util = _dereq_2("./util.js");
          var nodebackForPromise = _dereq_2("./promise_resolver.js")._nodebackForPromise;
          var withAppended2 = util.withAppended;
          var maybeWrapAsError2 = util.maybeWrapAsError;
          var canEvaluate2 = util.canEvaluate;
          var TypeError2 = _dereq_2("./errors").TypeError;
          var defaultSuffix = "Async";
          var defaultPromisified = { __isPromisified__: true };
          var noCopyProps = [
            "arity",
            "length",
            "name",
            "arguments",
            "caller",
            "callee",
            "prototype",
            "__isPromisified__"
          ];
          var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
          var defaultFilter = function(name) {
            return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
          };
          function propsFilter(key) {
            return !noCopyPropsPattern.test(key);
          }
          function isPromisified(fn) {
            try {
              return fn.__isPromisified__ === true;
            } catch (e) {
              return false;
            }
          }
          function hasPromisified(obj2, key, suffix) {
            var val = util.getDataPropertyOrDefault(
              obj2,
              key + suffix,
              defaultPromisified
            );
            return val ? isPromisified(val) : false;
          }
          function checkValid(ret2, suffix, suffixRegexp) {
            for (var i = 0; i < ret2.length; i += 2) {
              var key = ret2[i];
              if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret2.length; j += 2) {
                  if (ret2[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n".replace("%s", suffix));
                  }
                }
              }
            }
          }
          function promisifiableMethods(obj2, suffix, suffixRegexp, filter2) {
            var keys2 = util.inheritedDataKeys(obj2);
            var ret2 = [];
            for (var i = 0; i < keys2.length; ++i) {
              var key = keys2[i];
              var value = obj2[key];
              var passesDefaultFilter = filter2 === defaultFilter ? true : defaultFilter(key, value, obj2);
              if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter2(key, value, obj2, passesDefaultFilter)) {
                ret2.push(key, value);
              }
            }
            checkValid(ret2, suffix, suffixRegexp);
            return ret2;
          }
          var escapeIdentRegex = function(str) {
            return str.replace(/([$])/, "\\$");
          };
          var makeNodePromisifiedEval;
          if (false) {
            var switchCaseArgumentOrder = function(likelyArgumentCount) {
              var ret2 = [likelyArgumentCount];
              var min2 = Math.max(0, likelyArgumentCount - 1 - 3);
              for (var i = likelyArgumentCount - 1; i >= min2; --i) {
                ret2.push(i);
              }
              for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret2.push(i);
              }
              return ret2;
            };
            var argumentSequence = function(argumentCount) {
              return util.filledRange(argumentCount, "_arg", "");
            };
            var parameterDeclaration = function(parameterCount2) {
              return util.filledRange(
                Math.max(parameterCount2, 3),
                "_arg",
                ""
              );
            };
            var parameterCount = function(fn) {
              if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
              }
              return 0;
            };
            makeNodePromisifiedEval = function(callback, receiver, originalName, fn) {
              var newParameterCount = Math.max(0, parameterCount(fn) - 1);
              var argumentOrder = switchCaseArgumentOrder(newParameterCount);
              var shouldProxyThis = typeof callback === "string" || receiver === THIS;
              function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret2;
                if (shouldProxyThis) {
                  ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                  ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret2.replace("{{args}}", args).replace(", ", comma);
              }
              function generateArgumentSwitchCase() {
                var ret2 = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                  ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }
                ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret2;
              }
              var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
              return new Function(
                "Promise",
                "fn",
                "receiver",
                "withAppended",
                "maybeWrapAsError",
                "nodebackForPromise",
                "tryCatch",
                "errorObj",
                "notEnumerableProp",
                "INTERNAL",
                "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ".replace("Parameters", parameterDeclaration(newParameterCount)).replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode)
              )(
                Promise2,
                fn,
                receiver,
                withAppended2,
                maybeWrapAsError2,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
              );
            };
          }
          function makeNodePromisifiedClosure(callback, receiver, _3, fn) {
            var defaultThis = /* @__PURE__ */ function() {
              return this;
            }();
            var method = callback;
            if (typeof method === "string") {
              callback = fn;
            }
            function promisified() {
              var _receiver = receiver;
              if (receiver === THIS)
                _receiver = this;
              var promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
              var cb2 = typeof method === "string" && this !== defaultThis ? this[method] : callback;
              var fn2 = nodebackForPromise(promise);
              try {
                cb2.apply(_receiver, withAppended2(arguments, fn2));
              } catch (e) {
                promise._rejectCallback(maybeWrapAsError2(e), true, true);
              }
              return promise;
            }
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            return promisified;
          }
          var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
          function promisifyAll(obj2, suffix, filter2, promisifier) {
            var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
            var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter2);
            for (var i = 0, len = methods.length; i < len; i += 2) {
              var key = methods[i];
              var fn = methods[i + 1];
              var promisifiedKey = key + suffix;
              obj2[promisifiedKey] = promisifier === makeNodePromisified ? makeNodePromisified(key, THIS, key, fn, suffix) : promisifier(fn, function() {
                return makeNodePromisified(key, THIS, key, fn, suffix);
              });
            }
            util.toFastProperties(obj2);
            return obj2;
          }
          function promisify(callback, receiver) {
            return makeNodePromisified(callback, receiver, void 0, callback);
          }
          Promise2.promisify = function(fn, receiver) {
            if (typeof fn !== "function") {
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            if (isPromisified(fn)) {
              return fn;
            }
            var ret2 = promisify(fn, arguments.length < 2 ? THIS : receiver);
            util.copyDescriptors(fn, ret2, propsFilter);
            return ret2;
          };
          Promise2.promisifyAll = function(target, options) {
            if (typeof target !== "function" && typeof target !== "object") {
              throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n");
            }
            options = Object(options);
            var suffix = options.suffix;
            if (typeof suffix !== "string")
              suffix = defaultSuffix;
            var filter2 = options.filter;
            if (typeof filter2 !== "function")
              filter2 = defaultFilter;
            var promisifier = options.promisifier;
            if (typeof promisifier !== "function")
              promisifier = makeNodePromisified;
            if (!util.isIdentifier(suffix)) {
              throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n");
            }
            var keys2 = util.inheritedDataKeys(target);
            for (var i = 0; i < keys2.length; ++i) {
              var value = target[keys2[i]];
              if (keys2[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter2, promisifier);
                promisifyAll(value, suffix, filter2, promisifier);
              }
            }
            return promisifyAll(target, suffix, filter2, promisifier);
          };
        };
      }, { "./errors": 13, "./promise_resolver.js": 25, "./util.js": 38 }], 27: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var isObject3 = util.isObject;
          var es52 = _dereq_2("./es5.js");
          function PropertiesPromiseArray(obj2) {
            var keys2 = es52.keys(obj2);
            var len = keys2.length;
            var values2 = new Array(len * 2);
            for (var i = 0; i < len; ++i) {
              var key = keys2[i];
              values2[i] = obj2[key];
              values2[i + len] = key;
            }
            this.constructor$(values2);
          }
          util.inherits(PropertiesPromiseArray, PromiseArray);
          PropertiesPromiseArray.prototype._init = function() {
            this._init$(void 0, -3);
          };
          PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              var val = {};
              var keyOffset = this.length();
              for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
              }
              this._resolve(val);
            }
          };
          PropertiesPromiseArray.prototype._promiseProgressed = function(value, index) {
            this._promise._progress({
              key: this._values[index + this.length()],
              value
            });
          };
          PropertiesPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          PropertiesPromiseArray.prototype.getActualLength = function(len) {
            return len >> 1;
          };
          function props(promises) {
            var ret2;
            var castValue = tryConvertToPromise(promises);
            if (!isObject3(castValue)) {
              return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n");
            } else if (castValue instanceof Promise2) {
              ret2 = castValue._then(
                Promise2.props,
                void 0,
                void 0,
                void 0,
                void 0
              );
            } else {
              ret2 = new PropertiesPromiseArray(castValue).promise();
            }
            if (castValue instanceof Promise2) {
              ret2._propagateFrom(castValue, 4);
            }
            return ret2;
          }
          Promise2.prototype.props = function() {
            return props(this);
          };
          Promise2.props = function(promises) {
            return props(promises);
          };
        };
      }, { "./es5.js": 14, "./util.js": 38 }], 28: [function(_dereq_2, module2, exports2) {
        "use strict";
        function arrayMove(src, srcIndex, dst, dstIndex, len) {
          for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
          }
        }
        function Queue(capacity) {
          this._capacity = capacity;
          this._length = 0;
          this._front = 0;
        }
        Queue.prototype._willBeOverCapacity = function(size2) {
          return this._capacity < size2;
        };
        Queue.prototype._pushOne = function(arg) {
          var length = this.length();
          this._checkCapacity(length + 1);
          var i = this._front + length & this._capacity - 1;
          this[i] = arg;
          this._length = length + 1;
        };
        Queue.prototype._unshiftOne = function(value) {
          var capacity = this._capacity;
          this._checkCapacity(this.length() + 1);
          var front = this._front;
          var i = (front - 1 & capacity - 1 ^ capacity) - capacity;
          this[i] = value;
          this._front = i;
          this._length = this.length() + 1;
        };
        Queue.prototype.unshift = function(fn, receiver, arg) {
          this._unshiftOne(arg);
          this._unshiftOne(receiver);
          this._unshiftOne(fn);
        };
        Queue.prototype.push = function(fn, receiver, arg) {
          var length = this.length() + 3;
          if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver);
            this._pushOne(arg);
            return;
          }
          var j = this._front + length - 3;
          this._checkCapacity(length);
          var wrapMask = this._capacity - 1;
          this[j + 0 & wrapMask] = fn;
          this[j + 1 & wrapMask] = receiver;
          this[j + 2 & wrapMask] = arg;
          this._length = length;
        };
        Queue.prototype.shift = function() {
          var front = this._front, ret2 = this[front];
          this[front] = void 0;
          this._front = front + 1 & this._capacity - 1;
          this._length--;
          return ret2;
        };
        Queue.prototype.length = function() {
          return this._length;
        };
        Queue.prototype._checkCapacity = function(size2) {
          if (this._capacity < size2) {
            this._resizeTo(this._capacity << 1);
          }
        };
        Queue.prototype._resizeTo = function(capacity) {
          var oldCapacity = this._capacity;
          this._capacity = capacity;
          var front = this._front;
          var length = this._length;
          var moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this, 0, this, oldCapacity, moveItemsCount);
        };
        module2.exports = Queue;
      }, {}], 29: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var isArray = _dereq_2("./util.js").isArray;
          var raceLater = function(promise) {
            return promise.then(function(array) {
              return race(array, promise);
            });
          };
          function race(promises, parent) {
            var maybePromise = tryConvertToPromise(promises);
            if (maybePromise instanceof Promise2) {
              return raceLater(maybePromise);
            } else if (!isArray(promises)) {
              return apiRejection("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n");
            }
            var ret2 = new Promise2(INTERNAL);
            if (parent !== void 0) {
              ret2._propagateFrom(parent, 4 | 1);
            }
            var fulfill = ret2._fulfill;
            var reject2 = ret2._reject;
            for (var i = 0, len = promises.length; i < len; ++i) {
              var val = promises[i];
              if (val === void 0 && !(i in promises)) {
                continue;
              }
              Promise2.cast(val)._then(fulfill, reject2, void 0, ret2, null);
            }
            return ret2;
          }
          Promise2.race = function(promises) {
            return race(promises, void 0);
          };
          Promise2.prototype.race = function() {
            return race(this, void 0);
          };
        };
      }, { "./util.js": 38 }], 30: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function ReductionPromiseArray(promises, fn, accum, _each) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            this._preservedValues = _each === INTERNAL ? [] : null;
            this._zerothIsAccum = accum === void 0;
            this._gotAccum = false;
            this._reducingIndex = this._zerothIsAccum ? 1 : 0;
            this._valuesPhase = void 0;
            var maybePromise = tryConvertToPromise(accum, this._promise);
            var rejected = false;
            var isPromise = maybePromise instanceof Promise2;
            if (isPromise) {
              maybePromise = maybePromise._target();
              if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, -1);
              } else if (maybePromise._isFulfilled()) {
                accum = maybePromise._value();
                this._gotAccum = true;
              } else {
                this._reject(maybePromise._reason());
                rejected = true;
              }
            }
            if (!(isPromise || this._zerothIsAccum))
              this._gotAccum = true;
            var domain = getDomain();
            this._callback = domain === null ? fn : domain.bind(fn);
            this._accum = accum;
            if (!rejected)
              async.invoke(init, this, void 0);
          }
          function init() {
            this._init$(void 0, -5);
          }
          util.inherits(ReductionPromiseArray, PromiseArray);
          ReductionPromiseArray.prototype._init = function() {
          };
          ReductionPromiseArray.prototype._resolveEmptyArray = function() {
            if (this._gotAccum || this._zerothIsAccum) {
              this._resolve(this._preservedValues !== null ? [] : this._accum);
            }
          };
          ReductionPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values2 = this._values;
            values2[index] = value;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var isEach = preservedValues !== null;
            var gotAccum = this._gotAccum;
            var valuesPhase = this._valuesPhase;
            var valuesPhaseIndex;
            if (!valuesPhase) {
              valuesPhase = this._valuesPhase = new Array(length);
              for (valuesPhaseIndex = 0; valuesPhaseIndex < length; ++valuesPhaseIndex) {
                valuesPhase[valuesPhaseIndex] = 0;
              }
            }
            valuesPhaseIndex = valuesPhase[index];
            if (index === 0 && this._zerothIsAccum) {
              this._accum = value;
              this._gotAccum = gotAccum = true;
              valuesPhase[index] = valuesPhaseIndex === 0 ? 1 : 2;
            } else if (index === -1) {
              this._accum = value;
              this._gotAccum = gotAccum = true;
            } else {
              if (valuesPhaseIndex === 0) {
                valuesPhase[index] = 1;
              } else {
                valuesPhase[index] = 2;
                this._accum = value;
              }
            }
            if (!gotAccum)
              return;
            var callback = this._callback;
            var receiver = this._promise._boundValue();
            var ret2;
            for (var i = this._reducingIndex; i < length; ++i) {
              valuesPhaseIndex = valuesPhase[i];
              if (valuesPhaseIndex === 2) {
                this._reducingIndex = i + 1;
                continue;
              }
              if (valuesPhaseIndex !== 1)
                return;
              value = values2[i];
              this._promise._pushContext();
              if (isEach) {
                preservedValues.push(value);
                ret2 = tryCatch2(callback).call(receiver, value, i, length);
              } else {
                ret2 = tryCatch2(callback).call(receiver, this._accum, value, i, length);
              }
              this._promise._popContext();
              if (ret2 === errorObj2)
                return this._reject(ret2.e);
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  valuesPhase[i] = 4;
                  return maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                  ret2 = maybePromise._value();
                } else {
                  return this._reject(maybePromise._reason());
                }
              }
              this._reducingIndex = i + 1;
              this._accum = ret2;
            }
            this._resolve(isEach ? preservedValues : this._accum);
          };
          function reduce(promises, fn, initialValue, _each) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
            return array.promise();
          }
          Promise2.prototype.reduce = function(fn, initialValue) {
            return reduce(this, fn, initialValue, null);
          };
          Promise2.reduce = function(promises, fn, initialValue, _each) {
            return reduce(promises, fn, initialValue, _each);
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 31: [function(_dereq_2, module2, exports2) {
        "use strict";
        var schedule;
        var util = _dereq_2("./util");
        var noAsyncScheduler = function() {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/m3OTXk\n");
        };
        if (util.isNode && typeof MutationObserver === "undefined") {
          var GlobalSetImmediate = global.setImmediate;
          var ProcessNextTick = process.nextTick;
          schedule = util.isRecentNode ? function(fn) {
            GlobalSetImmediate.call(global, fn);
          } : function(fn) {
            ProcessNextTick.call(process, fn);
          };
        } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && window.navigator.standalone)) {
          schedule = function(fn) {
            var div = document.createElement("div");
            var observer = new MutationObserver(fn);
            observer.observe(div, { attributes: true });
            return function() {
              div.classList.toggle("foo");
            };
          };
          schedule.isStatic = true;
        } else if (typeof setImmediate !== "undefined") {
          schedule = function(fn) {
            setImmediate(fn);
          };
        } else if (typeof setTimeout !== "undefined") {
          schedule = function(fn) {
            setTimeout(fn, 0);
          };
        } else {
          schedule = noAsyncScheduler;
        }
        module2.exports = schedule;
      }, { "./util": 38 }], 32: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray) {
          var PromiseInspection = Promise2.PromiseInspection;
          var util = _dereq_2("./util.js");
          function SettledPromiseArray(values2) {
            this.constructor$(values2);
          }
          util.inherits(SettledPromiseArray, PromiseArray);
          SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
            this._values[index] = inspection;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
            }
          };
          SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 268435456;
            ret2._settledValue = value;
            this._promiseResolved(index, ret2);
          };
          SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 134217728;
            ret2._settledValue = reason;
            this._promiseResolved(index, ret2);
          };
          Promise2.settle = function(promises) {
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.prototype.settle = function() {
            return new SettledPromiseArray(this).promise();
          };
        };
      }, { "./util.js": 38 }], 33: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection) {
          var util = _dereq_2("./util.js");
          var RangeError2 = _dereq_2("./errors.js").RangeError;
          var AggregateError = _dereq_2("./errors.js").AggregateError;
          var isArray = util.isArray;
          function SomePromiseArray(values2) {
            this.constructor$(values2);
            this._howMany = 0;
            this._unwrap = false;
            this._initialized = false;
          }
          util.inherits(SomePromiseArray, PromiseArray);
          SomePromiseArray.prototype._init = function() {
            if (!this._initialized) {
              return;
            }
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var isArrayResolved = isArray(this._values);
            if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
              this._reject(this._getRangeError(this.length()));
            }
          };
          SomePromiseArray.prototype.init = function() {
            this._initialized = true;
            this._init();
          };
          SomePromiseArray.prototype.setUnwrap = function() {
            this._unwrap = true;
          };
          SomePromiseArray.prototype.howMany = function() {
            return this._howMany;
          };
          SomePromiseArray.prototype.setHowMany = function(count) {
            this._howMany = count;
          };
          SomePromiseArray.prototype._promiseFulfilled = function(value) {
            this._addFulfilled(value);
            if (this._fulfilled() === this.howMany()) {
              this._values.length = this.howMany();
              if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
              } else {
                this._resolve(this._values);
              }
            }
          };
          SomePromiseArray.prototype._promiseRejected = function(reason) {
            this._addRejected(reason);
            if (this.howMany() > this._canPossiblyFulfill()) {
              var e = new AggregateError();
              for (var i = this.length(); i < this._values.length; ++i) {
                e.push(this._values[i]);
              }
              this._reject(e);
            }
          };
          SomePromiseArray.prototype._fulfilled = function() {
            return this._totalResolved;
          };
          SomePromiseArray.prototype._rejected = function() {
            return this._values.length - this.length();
          };
          SomePromiseArray.prototype._addRejected = function(reason) {
            this._values.push(reason);
          };
          SomePromiseArray.prototype._addFulfilled = function(value) {
            this._values[this._totalResolved++] = value;
          };
          SomePromiseArray.prototype._canPossiblyFulfill = function() {
            return this.length() - this._rejected();
          };
          SomePromiseArray.prototype._getRangeError = function(count) {
            var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
            return new RangeError2(message);
          };
          SomePromiseArray.prototype._resolveEmptyArray = function() {
            this._reject(this._getRangeError(0));
          };
          function some2(promises, howMany) {
            if ((howMany | 0) !== howMany || howMany < 0) {
              return apiRejection("expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n");
            }
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(howMany);
            ret2.init();
            return promise;
          }
          Promise2.some = function(promises, howMany) {
            return some2(promises, howMany);
          };
          Promise2.prototype.some = function(howMany) {
            return some2(this, howMany);
          };
          Promise2._SomePromiseArray = SomePromiseArray;
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 34: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function PromiseInspection(promise) {
            if (promise !== void 0) {
              promise = promise._target();
              this._bitField = promise._bitField;
              this._settledValue = promise._settledValue;
            } else {
              this._bitField = 0;
              this._settledValue = void 0;
            }
          }
          PromiseInspection.prototype.value = function() {
            if (!this.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n");
            }
            return this._settledValue;
          };
          PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
            if (!this.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n");
            }
            return this._settledValue;
          };
          PromiseInspection.prototype.isFulfilled = Promise2.prototype._isFulfilled = function() {
            return (this._bitField & 268435456) > 0;
          };
          PromiseInspection.prototype.isRejected = Promise2.prototype._isRejected = function() {
            return (this._bitField & 134217728) > 0;
          };
          PromiseInspection.prototype.isPending = Promise2.prototype._isPending = function() {
            return (this._bitField & 402653184) === 0;
          };
          PromiseInspection.prototype.isResolved = Promise2.prototype._isResolved = function() {
            return (this._bitField & 402653184) > 0;
          };
          Promise2.prototype.isPending = function() {
            return this._target()._isPending();
          };
          Promise2.prototype.isRejected = function() {
            return this._target()._isRejected();
          };
          Promise2.prototype.isFulfilled = function() {
            return this._target()._isFulfilled();
          };
          Promise2.prototype.isResolved = function() {
            return this._target()._isResolved();
          };
          Promise2.prototype._value = function() {
            return this._settledValue;
          };
          Promise2.prototype._reason = function() {
            this._unsetRejectionIsUnhandled();
            return this._settledValue;
          };
          Promise2.prototype.value = function() {
            var target = this._target();
            if (!target.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n");
            }
            return target._settledValue;
          };
          Promise2.prototype.reason = function() {
            var target = this._target();
            if (!target.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n");
            }
            target._unsetRejectionIsUnhandled();
            return target._settledValue;
          };
          Promise2.PromiseInspection = PromiseInspection;
        };
      }, {}], 35: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util.js");
          var errorObj2 = util.errorObj;
          var isObject3 = util.isObject;
          function tryConvertToPromise(obj2, context) {
            if (isObject3(obj2)) {
              if (obj2 instanceof Promise2) {
                return obj2;
              } else if (isAnyBluebirdPromise(obj2)) {
                var ret2 = new Promise2(INTERNAL);
                obj2._then(
                  ret2._fulfillUnchecked,
                  ret2._rejectUncheckedCheckError,
                  ret2._progressUnchecked,
                  ret2,
                  null
                );
                return ret2;
              }
              var then = util.tryCatch(getThen)(obj2);
              if (then === errorObj2) {
                if (context)
                  context._pushContext();
                var ret2 = Promise2.reject(then.e);
                if (context)
                  context._popContext();
                return ret2;
              } else if (typeof then === "function") {
                return doThenable(obj2, then, context);
              }
            }
            return obj2;
          }
          function getThen(obj2) {
            return obj2.then;
          }
          var hasProp = {}.hasOwnProperty;
          function isAnyBluebirdPromise(obj2) {
            return hasProp.call(obj2, "_promise0");
          }
          function doThenable(x, then, context) {
            var promise = new Promise2(INTERNAL);
            var ret2 = promise;
            if (context)
              context._pushContext();
            promise._captureStackTrace();
            if (context)
              context._popContext();
            var synchronous = true;
            var result2 = util.tryCatch(then).call(
              x,
              resolveFromThenable,
              rejectFromThenable,
              progressFromThenable
            );
            synchronous = false;
            if (promise && result2 === errorObj2) {
              promise._rejectCallback(result2.e, true, true);
              promise = null;
            }
            function resolveFromThenable(value) {
              if (!promise)
                return;
              promise._resolveCallback(value);
              promise = null;
            }
            function rejectFromThenable(reason) {
              if (!promise)
                return;
              promise._rejectCallback(reason, synchronous, true);
              promise = null;
            }
            function progressFromThenable(value) {
              if (!promise)
                return;
              if (typeof promise._progress === "function") {
                promise._progress(value);
              }
            }
            return ret2;
          }
          return tryConvertToPromise;
        };
      }, { "./util.js": 38 }], 36: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util.js");
          var TimeoutError = Promise2.TimeoutError;
          var afterTimeout = function(promise, message) {
            if (!promise.isPending())
              return;
            if (typeof message !== "string") {
              message = "operation timed out";
            }
            var err = new TimeoutError(message);
            util.markAsOriginatingFromRejection(err);
            promise._attachExtraTrace(err);
            promise._cancel(err);
          };
          var afterValue = function(value) {
            return delay(+this).thenReturn(value);
          };
          var delay = Promise2.delay = function(value, ms) {
            if (ms === void 0) {
              ms = value;
              value = void 0;
              var ret2 = new Promise2(INTERNAL);
              setTimeout(function() {
                ret2._fulfill();
              }, ms);
              return ret2;
            }
            ms = +ms;
            return Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          };
          Promise2.prototype.delay = function(ms) {
            return delay(this, ms);
          };
          function successClear(value) {
            var handle = this;
            if (handle instanceof Number)
              handle = +handle;
            clearTimeout(handle);
            return value;
          }
          function failureClear(reason) {
            var handle = this;
            if (handle instanceof Number)
              handle = +handle;
            clearTimeout(handle);
            throw reason;
          }
          Promise2.prototype.timeout = function(ms, message) {
            ms = +ms;
            var ret2 = this.then().cancellable();
            ret2._cancellationParent = this;
            var handle = setTimeout(function timeoutTimeout() {
              afterTimeout(ret2, message);
            }, ms);
            return ret2._then(successClear, failureClear, void 0, handle, void 0);
          };
        };
      }, { "./util.js": 38 }], 37: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext) {
          var TypeError2 = _dereq_2("./errors.js").TypeError;
          var inherits2 = _dereq_2("./util.js").inherits;
          var PromiseInspection = Promise2.PromiseInspection;
          function inspectionMapper(inspections) {
            var len = inspections.length;
            for (var i = 0; i < len; ++i) {
              var inspection = inspections[i];
              if (inspection.isRejected()) {
                return Promise2.reject(inspection.error());
              }
              inspections[i] = inspection._settledValue;
            }
            return inspections;
          }
          function thrower2(e) {
            setTimeout(function() {
              throw e;
            }, 0);
          }
          function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
              maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
          }
          function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret2 = Promise2.defer();
            function iterator() {
              if (i >= len)
                return ret2.resolve();
              var maybePromise = castPreservingDisposable(resources[i++]);
              if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
                try {
                  maybePromise = tryConvertToPromise(
                    maybePromise._getDisposer().tryDispose(inspection),
                    resources.promise
                  );
                } catch (e) {
                  return thrower2(e);
                }
                if (maybePromise instanceof Promise2) {
                  return maybePromise._then(
                    iterator,
                    thrower2,
                    null,
                    null,
                    null
                  );
                }
              }
              iterator();
            }
            iterator();
            return ret2.promise;
          }
          function disposerSuccess(value) {
            var inspection = new PromiseInspection();
            inspection._settledValue = value;
            inspection._bitField = 268435456;
            return dispose(this, inspection).thenReturn(value);
          }
          function disposerFail(reason) {
            var inspection = new PromiseInspection();
            inspection._settledValue = reason;
            inspection._bitField = 134217728;
            return dispose(this, inspection).thenThrow(reason);
          }
          function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
          }
          Disposer.prototype.data = function() {
            return this._data;
          };
          Disposer.prototype.promise = function() {
            return this._promise;
          };
          Disposer.prototype.resource = function() {
            if (this.promise().isFulfilled()) {
              return this.promise().value();
            }
            return null;
          };
          Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== void 0)
              context._pushContext();
            var ret2 = resource !== null ? this.doDispose(resource, inspection) : null;
            if (context !== void 0)
              context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret2;
          };
          Disposer.isDisposer = function(d) {
            return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
          };
          function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
          }
          inherits2(FunctionDisposer, Disposer);
          FunctionDisposer.prototype.doDispose = function(resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
          };
          function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
              this.resources[this.index]._setDisposable(value);
              return value.promise();
            }
            return value;
          }
          Promise2.using = function() {
            var len = arguments.length;
            if (len < 2)
              return apiRejection(
                "you must pass at least 2 arguments to Promise.using"
              );
            var fn = arguments[len - 1];
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            len--;
            var resources = new Array(len);
            for (var i = 0; i < len; ++i) {
              var resource = arguments[i];
              if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
              } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise2) {
                  resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                    resources,
                    index: i
                  }, void 0);
                }
              }
              resources[i] = resource;
            }
            var promise = Promise2.settle(resources).then(inspectionMapper).then(function(vals) {
              promise._pushContext();
              var ret2;
              try {
                ret2 = fn.apply(void 0, vals);
              } finally {
                promise._popContext();
              }
              return ret2;
            })._then(
              disposerSuccess,
              disposerFail,
              void 0,
              resources,
              void 0
            );
            resources.promise = promise;
            return promise;
          };
          Promise2.prototype._setDisposable = function(disposer) {
            this._bitField = this._bitField | 262144;
            this._disposer = disposer;
          };
          Promise2.prototype._isDisposable = function() {
            return (this._bitField & 262144) > 0;
          };
          Promise2.prototype._getDisposer = function() {
            return this._disposer;
          };
          Promise2.prototype._unsetDisposable = function() {
            this._bitField = this._bitField & ~262144;
            this._disposer = void 0;
          };
          Promise2.prototype.disposer = function(fn) {
            if (typeof fn === "function") {
              return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError2();
          };
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 38: [function(_dereq_, module, exports) {
        "use strict";
        var es5 = _dereq_("./es5.js");
        var canEvaluate = typeof navigator == "undefined";
        var haveGetters = function() {
          try {
            var o = {};
            es5.defineProperty(o, "f", {
              get: function() {
                return 3;
              }
            });
            return o.f === 3;
          } catch (e) {
            return false;
          }
        }();
        var errorObj = { e: {} };
        var tryCatchTarget;
        function tryCatcher() {
          try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
          } catch (e) {
            errorObj.e = e;
            return errorObj;
          }
        }
        function tryCatch(fn) {
          tryCatchTarget = fn;
          return tryCatcher;
        }
        var inherits = function(Child, Parent) {
          var hasProp = {}.hasOwnProperty;
          function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
              if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
              }
            }
          }
          T.prototype = Parent.prototype;
          Child.prototype = new T();
          return Child.prototype;
        };
        function isPrimitive(val) {
          return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
        }
        function isObject(value) {
          return !isPrimitive(value);
        }
        function maybeWrapAsError(maybeError) {
          if (!isPrimitive(maybeError))
            return maybeError;
          return new Error(safeToString(maybeError));
        }
        function withAppended(target, appendee) {
          var len = target.length;
          var ret2 = new Array(len + 1);
          var i;
          for (i = 0; i < len; ++i) {
            ret2[i] = target[i];
          }
          ret2[i] = appendee;
          return ret2;
        }
        function getDataPropertyOrDefault(obj2, key, defaultValue) {
          if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null) {
              return desc.get == null && desc.set == null ? desc.value : defaultValue;
            }
          } else {
            return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
          }
        }
        function notEnumerableProp(obj2, name, value) {
          if (isPrimitive(obj2))
            return obj2;
          var descriptor = {
            value,
            configurable: true,
            enumerable: false,
            writable: true
          };
          es5.defineProperty(obj2, name, descriptor);
          return obj2;
        }
        function thrower(r) {
          throw r;
        }
        var inheritedDataKeys = function() {
          var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ];
          var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (excludedPrototypes[i] === val) {
                return true;
              }
            }
            return false;
          };
          if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj2) {
              var ret2 = [];
              var visitedKeys = /* @__PURE__ */ Object.create(null);
              while (obj2 != null && !isExcludedProto(obj2)) {
                var keys2;
                try {
                  keys2 = getKeys(obj2);
                } catch (e) {
                  return ret2;
                }
                for (var i = 0; i < keys2.length; ++i) {
                  var key = keys2[i];
                  if (visitedKeys[key])
                    continue;
                  visitedKeys[key] = true;
                  var desc = Object.getOwnPropertyDescriptor(obj2, key);
                  if (desc != null && desc.get == null && desc.set == null) {
                    ret2.push(key);
                  }
                }
                obj2 = es5.getPrototypeOf(obj2);
              }
              return ret2;
            };
          } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj2) {
              if (isExcludedProto(obj2))
                return [];
              var ret2 = [];
              enumeration:
                for (var key in obj2) {
                  if (hasProp.call(obj2, key)) {
                    ret2.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret2.push(key);
                  }
                }
              return ret2;
            };
          }
        }();
        var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
        function isClass(fn) {
          try {
            if (typeof fn === "function") {
              var keys2 = es5.names(fn.prototype);
              var hasMethods = es5.isES5 && keys2.length > 1;
              var hasMethodsOtherThanConstructor = keys2.length > 0 && !(keys2.length === 1 && keys2[0] === "constructor");
              var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
              if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
              }
            }
            return false;
          } catch (e) {
            return false;
          }
        }
        function toFastProperties(obj) {
          function f() {
          }
          f.prototype = obj;
          var l = 8;
          while (l--)
            new f();
          return obj;
          eval(obj);
        }
        var rident = /^[a-z$_][a-z$_0-9]*$/i;
        function isIdentifier(str) {
          return rident.test(str);
        }
        function filledRange(count, prefix, suffix) {
          var ret2 = new Array(count);
          for (var i = 0; i < count; ++i) {
            ret2[i] = prefix + i + suffix;
          }
          return ret2;
        }
        function safeToString(obj2) {
          try {
            return obj2 + "";
          } catch (e) {
            return "[no string representation]";
          }
        }
        function markAsOriginatingFromRejection(e) {
          try {
            notEnumerableProp(e, "isOperational", true);
          } catch (ignore) {
          }
        }
        function originatesFromRejection(e) {
          if (e == null)
            return false;
          return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
        }
        function canAttachTrace(obj2) {
          return obj2 instanceof Error && es5.propertyIsWritable(obj2, "stack");
        }
        var ensureErrorObject = function() {
          if (!("stack" in new Error())) {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              try {
                throw new Error(safeToString(value));
              } catch (err) {
                return err;
              }
            };
          } else {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              return new Error(safeToString(value));
            };
          }
        }();
        function classString(obj2) {
          return {}.toString.call(obj2);
        }
        function copyDescriptors(from, to, filter2) {
          var keys2 = es5.names(from);
          for (var i = 0; i < keys2.length; ++i) {
            var key = keys2[i];
            if (filter2(key)) {
              try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
              } catch (ignore) {
              }
            }
          }
        }
        var ret = {
          isClass,
          isIdentifier,
          inheritedDataKeys,
          getDataPropertyOrDefault,
          thrower,
          isArray: es5.isArray,
          haveGetters,
          notEnumerableProp,
          isPrimitive,
          isObject,
          canEvaluate,
          errorObj,
          tryCatch,
          inherits,
          withAppended,
          maybeWrapAsError,
          toFastProperties,
          filledRange,
          toString: safeToString,
          canAttachTrace,
          ensureErrorObject,
          originatesFromRejection,
          markAsOriginatingFromRejection,
          classString,
          copyDescriptors,
          hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
          isNode: typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]"
        };
        ret.isRecentNode = ret.isNode && function() {
          var version = process.versions.node.split(".").map(Number);
          return version[0] === 0 && version[1] > 10 || version[0] > 0;
        }();
        if (ret.isNode)
          ret.toFastProperties(process);
        try {
          throw new Error();
        } catch (e) {
          ret.lastLineError = e;
        }
        module.exports = ret;
      }, { "./es5.js": 14 }] }, {}, [4])(4);
    });
    if (typeof window !== "undefined" && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== "undefined" && self !== null) {
      self.P = self.Promise;
    }
  }
});

// node_modules/pkghub-render/node_modules/pkghub/dist/npm.js
var require_npm3 = __commonJS({
  "node_modules/pkghub-render/node_modules/pkghub/dist/npm.js"(exports2) {
    "use strict";
    var _interopRequireWildcard = function(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.load = load;
    exports2.ls = ls;
    exports2.install = install;
    var _npm = require_npm();
    var _npm2 = _interopRequireWildcard(_npm);
    var _import = (init_index_all(), __toCommonJS(index_all_exports));
    var _import2 = _interopRequireWildcard(_import);
    var _Promise = require_bluebird3();
    var _Promise2 = _interopRequireWildcard(_Promise);
    var config = {
      loglevel: "silent",
      parseable: true
    };
    function load() {
      return new _Promise2["default"](function(res, rej) {
        _npm2["default"].load(config, function(err, n) {
          if (err)
            return rej(err);
          return res(n);
        });
      });
    }
    function ls() {
      return load().then(function(npmInstance) {
        return new _Promise2["default"](function(res, rej) {
          npmInstance.commands.ls([], true, function(err, modules) {
            if (err)
              return rej(err);
            return res(modules);
          });
        });
      });
    }
    function install(modules, dir) {
      return load().then(function(n) {
        return new _Promise2["default"](function(res, rej) {
          if (!_import2["default"].isArray(modules))
            return rej(new Error("Modules name must be array"));
          var params = dir ? [dir, modules, callback] : [modules, callback];
          return n.commands.install.apply(n, params);
          function callback(err, result2) {
            if (err) {
              return rej(err);
            }
            return res(result2);
          }
        });
      });
    }
  }
});

// node_modules/pkghub-render/node_modules/minimatch/minimatch.js
var require_minimatch3 = __commonJS({
  "node_modules/pkghub-render/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = { sep: "/" };
    try {
      path = require_path();
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion2();
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter2;
    function filter2(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate2 = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l2 = pattern.length; i < l2 && pattern.charAt(i) === "!"; i++) {
        negate2 = !negate2;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate2;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new Error("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var plType;
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            plType = stateChar;
            patternListStack.push({
              type: plType,
              start: i - 1,
              reStart: re.length
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            re += ")";
            var pl = patternListStack.pop();
            plType = pl.type;
            switch (plType) {
              case "!":
                negativeLists.push(pl);
                re += ")[^/]*?)";
                pl.reEnd = re.length;
                break;
              case "?":
              case "+":
              case "*":
                re += plType;
                break;
              case "@":
                break;
            }
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + 3);
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function(_3, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      var regExp = new RegExp("^" + re + "$", flags);
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f2) {
        return mm.match(f2);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f2, partial2) {
      this.debug("match", f2, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f2 === "";
      if (f2 === "/" && partial2)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f2 = f2.split(path.sep).join("/");
      }
      f2 = f2.split(slashSplit);
      this.debug(this.pattern, "split", f2);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f2.length - 1; i >= 0; i--) {
        filename = f2[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f2;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial2);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial2) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f2 = file[fi];
        this.debug(pattern, p, f2);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f2]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial2)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial2) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f2.toLowerCase() === p.toLowerCase();
          } else {
            hit = f2 === p;
          }
          this.debug("string match", p, f2, hit);
        } else {
          hit = f2.match(p);
          this.debug("pattern match", p, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial2;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/pkghub-render/node_modules/glob/common.js
var require_common3 = __commonJS({
  "node_modules/pkghub-render/node_modules/glob/common.js"(exports2) {
    exports2.alphasort = alphasort;
    exports2.alphasorti = alphasorti;
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj2, field) {
      return Object.prototype.hasOwnProperty.call(obj2, field);
    }
    var path = require_path();
    var minimatch = require_minimatch3();
    var isAbsolute = require_path_is_absolute2();
    var Minimatch = minimatch.Minimatch;
    function alphasorti(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    }
    function alphasort(a, b) {
      return a.localeCompare(b);
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern);
      }
      return {
        matcher: new Minimatch(pattern),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = options.cwd;
        self2.changedCwd = path.resolve(options.cwd) !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = options.nonegate === false ? false : true;
      options.nocomment = options.nocomment === false ? false : true;
      deprecationWarning(options);
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    exports2.deprecationWarned;
    function deprecationWarning(options) {
      if (!options.nonegate || !options.nocomment) {
        if (process.noDeprecation !== true && !exports2.deprecationWarned) {
          var msg = "glob WARNING: comments and negation will be disabled in v6";
          if (process.throwDeprecation)
            throw new Error(msg);
          else if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
          exports2.deprecationWarned = true;
        }
      }
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l2 = self2.matches.length; i < l2; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(self2.nocase ? alphasorti : alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            return !/\/$/.test(e);
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f2) {
      var abs = f2;
      if (f2.charAt(0) === "/") {
        abs = path.join(self2.root, f2);
      } else if (isAbsolute(f2) || f2 === "") {
        abs = f2;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f2);
      } else {
        abs = path.resolve(f2);
      }
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/pkghub-render/node_modules/glob/sync.js
var require_sync3 = __commonJS({
  "node_modules/pkghub-render/node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs = require_fs();
    var minimatch = require_minimatch3();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob3().Glob;
    var util = require_util();
    var path = require_path();
    var assert = require_assert();
    var isAbsolute = require_path_is_absolute2();
    var common = require_common3();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = fs.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate2 = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate2 && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this.matches[index][e] = true;
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[this._makeAbs(e)];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = fs.lstatSync(abs);
      } catch (er) {
        return null;
      }
      var isSym = lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f2, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          this.cache[this._makeAbs(f2)] = "FILE";
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this.matches[index][prefix] = true;
    };
    GlobSync.prototype._stat = function(f2) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = fs.lstatSync(abs);
        } catch (er) {
          return false;
        }
        if (lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c !== "DIR")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f2) {
      return common.makeAbs(this, f2);
    };
  }
});

// node_modules/pkghub-render/node_modules/glob/glob.js
var require_glob3 = __commonJS({
  "node_modules/pkghub-render/node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var fs = require_fs();
    var minimatch = require_minimatch3();
    var Minimatch = minimatch.Minimatch;
    var inherits2 = require_inherits_browser2();
    var EE = require_events().EventEmitter;
    var path = require_path();
    var assert = require_assert();
    var isAbsolute = require_path_is_absolute2();
    var globSync = require_sync3();
    var common = require_common3();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight2();
    var util = require_util();
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once2();
    function glob(pattern, options, cb2) {
      if (typeof options === "function")
        cb2 = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb2)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb2);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    glob.hasMagic = function(pattern, options_) {
      var options = util._extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits2(Glob, EE);
    function Glob(pattern, options, cb2) {
      if (typeof options === "function") {
        cb2 = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb2)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb2);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb2 === "function") {
        cb2 = once(cb2);
        this.on("error", cb2);
        this.on("end", function(matches) {
          cb2(null, matches);
        });
      }
      var self2 = this;
      var n = this.minimatch.set.length;
      this._processing = 0;
      this.matches = new Array(n);
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      function done() {
        --self2._processing;
        if (self2._processing <= 0)
          self2._finish();
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb2) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb2();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb2();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        fs.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb2();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f2) {
      return common.makeAbs(this, f2);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq2 = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq2.length; i++) {
            var e = eq2[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb2) {
      assert(this instanceof Glob);
      assert(typeof cb2 === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb2]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb2);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb2();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb2);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb2);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb2) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb2);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb2) {
      if (!entries)
        return cb2();
      var pn = remain[0];
      var negate2 = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate2 && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb2();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb2();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb2);
      }
      cb2();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (this.matches[index][e])
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = this._makeAbs(e);
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      if (this.mark)
        e = this._mark(e);
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb2) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb2);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er)
          return cb2();
        var isSym = lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb2();
        } else
          self2._readdir(abs, false, cb2);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb2) {
      if (this.aborted)
        return;
      cb2 = inflight("readdir\0" + abs + "\0" + inGlobStar, cb2);
      if (!cb2)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb2);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb2();
        if (Array.isArray(c))
          return cb2(null, c);
      }
      var self2 = this;
      fs.readdir(abs, readdirCb(this, abs, cb2));
    };
    function readdirCb(self2, abs, cb2) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb2);
        else
          self2._readdirEntries(abs, entries, cb2);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb2) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb2(null, entries);
    };
    Glob.prototype._readdirError = function(f2, er, cb2) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          this.cache[this._makeAbs(f2)] = "FILE";
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb2();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb2) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb2);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb2) {
      if (!entries)
        return cb2();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb2);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb2();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb2);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb2);
      }
      cb2();
    };
    Glob.prototype._processSimple = function(prefix, index, cb2) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb2);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb2) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb2();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb2();
    };
    Glob.prototype._stat = function(f2, cb2) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return cb2();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb2(null, c);
        if (needDir && c === "FILE")
          return cb2();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb2(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb2();
          else
            return cb2(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f2, abs, null, lstat, cb2);
            else
              self2._stat2(f2, abs, er2, stat2, cb2);
          });
        } else {
          self2._stat2(f2, abs, er, lstat, cb2);
        }
      }
    };
    Glob.prototype._stat2 = function(f2, abs, er, stat, cb2) {
      if (er) {
        this.statCache[abs] = false;
        return cb2();
      }
      var needDir = f2.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && !stat.isDirectory())
        return cb2(null, false, stat);
      var c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c !== "DIR")
        return cb2();
      return cb2(null, c, stat);
    };
  }
});

// node_modules/pkghub-render/node_modules/pkghub/dist/finder.js
var require_finder2 = __commonJS({
  "node_modules/pkghub-render/node_modules/pkghub/dist/finder.js"(exports2) {
    "use strict";
    var _interopRequireWildcard = function(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.split = split;
    exports2.read = read;
    var _fs = require_fs();
    var _fs2 = _interopRequireWildcard(_fs);
    var _path = require_path();
    var _path2 = _interopRequireWildcard(_path);
    var _glob = require_glob3();
    var _glob2 = _interopRequireWildcard(_glob);
    function split(name, isFilename) {
      if (!name || name.indexOf("/") === -1) {
        return;
      }
      if (!isFilename) {
        return name.substr(0, name.indexOf("/"));
      }
      return name.substr(name.indexOf("/") + 1);
    }
    function read(abs, name) {
      if (!abs) {
        return null;
      }
      var dir = _path2["default"].join(abs, name);
      var file = {
        name,
        dir,
        exist: _fs2["default"].existsSync(dir)
      };
      if (file.exist) {
        return file;
      }
      try {
        file.availables = _glob2["default"].sync(file.dir + "*");
      } catch (err) {
        file.err = err;
      }
      return file;
    }
  }
});

// node_modules/pkghub-render/node_modules/pkghub/dist/pkghub.js
var require_pkghub2 = __commonJS({
  "node_modules/pkghub-render/node_modules/pkghub/dist/pkghub.js"(exports2, module2) {
    "use strict";
    var _interopRequireWildcard = function(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    };
    var _classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _import = (init_index_all(), __toCommonJS(index_all_exports));
    var _import2 = _interopRequireWildcard(_import);
    var _Promise = require_bluebird3();
    var _Promise2 = _interopRequireWildcard(_Promise);
    var _import3 = require_npm3();
    var npm = _interopRequireWildcard(_import3);
    var _import4 = require_finder2();
    var finder = _interopRequireWildcard(_import4);
    var defaults = {
      devider: "-",
      includes: ["name", "version", "logo", "styles", "fonts", "javascripts", "static", "screenshot", "description", "main", "repository", "keywords", "author", "license", "bugs", "readme", "path", "depth", "realPath", "view engine"]
    };
    var pkgHub = function() {
      function pkgHub2() {
        var devider = arguments[0] === void 0 ? "-" : arguments[0];
        _classCallCheck(this, pkgHub2);
        this.module = {};
        this.module.dependencies = {};
        this.settings = _import2["default"].clone(defaults);
        this.settings.devider = devider;
      }
      _createClass(pkgHub2, [{
        key: "config",
        value: function config() {
          var params = arguments[0] === void 0 ? {} : arguments[0];
          this.settings = _import2["default"].extend(defaults, params);
          return this.settings;
        }
      }, {
        key: "list",
        // 列出所有依赖模块
        value: function list() {
          var _this = this;
          return npm.ls().then(function(packages) {
            var modules = _import2["default"].clone(packages);
            var dependencies = modules.dependencies;
            if (dependencies) {
              delete modules.dependencies;
              _import2["default"].each(dependencies, function(module3, name) {
                dependencies[name] = wash(module3);
              });
            }
            modules = wash(modules);
            modules.dependencies = dependencies;
            _this.module = modules;
            _this.cached = /* @__PURE__ */ new Date();
            return _Promise2["default"].resolve(modules);
          });
        }
      }, {
        key: "keywords",
        value: function keywords(shortcut, name) {
          var devider = this.settings.devider;
          var shortcuts = {
            __pkghub_addons: name + devider,
            __pkghub_plugins: name + devider + "plugin" + devider,
            __pkghub_themes: name + devider + "theme" + devider
          };
          return shortcuts[shortcut];
        }
      }, {
        key: "find",
        // 这里要加一层缓存，不要每次都去 list 一遍模块
        // 因为 npm 有个问题同时调用两次 load list 会报错。
        // 这样的话如果在路由里使用基本不现实
        value: function find2(name, modules) {
          var _this2 = this;
          return new _Promise2["default"](function(resolve, reject2) {
            var pkg = modules.dependencies[name];
            if (pkg)
              return resolve(pkg);
            var pkgname = finder.split(name);
            var filename = finder.split(name, "filename");
            if (pkgname && filename) {
              var m = modules.dependencies[pkgname] || null;
              if (!m || !m.realPath)
                return reject2(new Error("No module " + pkgname + " was found"));
              return resolve({
                module: m,
                file: finder.read(m.realPath, filename)
              });
            }
            var result2 = {};
            var keyword = _this2.keywords(name, modules.name) || name;
            Object.keys(modules.dependencies).forEach(function(name2) {
              if (name2.indexOf(keyword) > -1)
                result2[name2] = modules.dependencies[name2];
            });
            if (_import2["default"].isEmpty(result2))
              return reject2("No module " + name + " was found");
            var availables = Object.keys(result2);
            if (availables.length === 1)
              return resolve(result2[availables[0]]);
            return resolve(result2);
          });
        }
      }, {
        key: "load",
        // 加载某一个模块
        // 模块名称可以是全名，也可以是部分名
        // 模块名称可以包涵名称和子文件，比如 candy 或 candy/template.html
        // e.g: name = 'candy/tpl.html', file === tpl.html;
        value: function load(name, force) {
          var _this3 = this;
          var cache = this.module;
          if (this.cached && !force) {
            return this.find(name, cache);
          }
          return this.list().then(function(modules) {
            if (!modules.dependencies)
              return _Promise2["default"].reject(new Error("No module " + name + " was found"));
            return _this3.find(name, modules);
          });
        }
      }, {
        key: "addons",
        // 返回一个模块的相关模块，包括插件和主题
        // e.g: candy-editor 是 candy 的插件，此例中，插件包涵 `candy-` 字符串
        value: function addons() {
          return this.load("__pkghub_addons");
        }
      }, {
        key: "plugins",
        // 返回一个模块的插件列表
        // 某个包的插件是以 devider 分割的模块名字
        // e.g: candy-editor 是 candy 的插件，此例中，插件包涵 `candy-plugin` 字符串
        value: function plugins() {
          return this.load("__pkghub_plugins");
        }
      }, {
        key: "themes",
        // 返回一个模块的主题列表
        // e.g:  candy-theme-balbala 会被返回
        value: function themes() {
          return this.load("__pkghub_themes");
        }
      }, {
        key: "install",
        // 安装一个包，并返回所有依赖
        value: function install(modules, dir) {
          var _this4 = this;
          if (_import2["default"].isString(modules))
            modules = [modules];
          return npm.install(modules, dir).then(function(logs) {
            return _this4.list();
          });
        }
      }]);
      return pkgHub2;
    }();
    exports2["default"] = pkgHub;
    function wash(obj2) {
      var washed = {};
      defaults.includes.forEach(function(key) {
        if (obj2[key])
          washed[key] = obj2[key];
      });
      return washed;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/pkghub-render/dist/compile.js
var require_compile = __commonJS({
  "node_modules/pkghub-render/dist/compile.js"(exports2, module2) {
    "use strict";
    var _interopRequireWildcard = function(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _Promise = require_bluebird3();
    var _Promise2 = _interopRequireWildcard(_Promise);
    exports2["default"] = function(template2) {
      var data = arguments[1] === void 0 ? {} : arguments[1];
      var opts = arguments[2] === void 0 ? { engine: "swig" } : arguments[2];
      return new _Promise2["default"](function(res, rej) {
        var engine = opts.engine;
        try {
          var _engine = __require(engine);
          var html;
          if (engine === "jade")
            html = _engine.renderFile(template2, data);
          if (engine === "swig")
            html = _engine.compileFile(template2)(data);
          if (engine === "ejs")
            html = _engine.render(require_fs().readFileSync(template2), data);
          if (!html)
            return rej(new Error("Template engine is not supported yet"));
          if (typeof html === "object")
            return rej(html);
          res(html);
        } catch (err) {
          return rej(err);
        }
      });
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/pkghub-render/dist/render.js
var require_render = __commonJS({
  "node_modules/pkghub-render/dist/render.js"(exports2, module2) {
    "use strict";
    var _interopRequireWildcard = function(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = renderer;
    var _pkghub = require_pkghub2();
    var _pkghub2 = _interopRequireWildcard(_pkghub);
    var _Promise = require_bluebird3();
    var _Promise2 = _interopRequireWildcard(_Promise);
    var _compile = require_compile();
    var _compile2 = _interopRequireWildcard(_compile);
    function renderer(template2, data) {
      var hub = new _pkghub2["default"]();
      return hub.load(template2).then(function(_ref) {
        var module3 = _ref.module;
        var file = _ref.file;
        if (!module3)
          return _Promise2["default"].reject(new Error("Target theme module was not found"));
        if (!module3["view engine"])
          return _Promise2["default"].reject(new Error("Template engine in `package.json` was required"));
        if (!file)
          return _Promise2["default"].reject(new Error("Template file was not found"));
        var dest = file.exist ? file.dir : file.availables[0];
        data.THEME = module3;
        data["static"] = isURI(module3["static"]) ? module3["static"] : "/" + module3.name;
        return _compile2["default"](dest, data, {
          engine: module3["view engine"]
        });
      });
    }
    function isURI(dir) {
      return dir && (dir.indexOf("http") === 0 || dir.indexOf("https") === 0);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/theme/dist/finder.js
var require_finder3 = __commonJS({
  "node_modules/theme/dist/finder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.shadow = shadow;
    exports2.shadows = shadows;
    exports2.split = split;
    exports2.pkg = pkg;
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    var _fs = require_fs();
    var _fs2 = _interopRequireDefault(_fs);
    var _path = require_path();
    var _path2 = _interopRequireDefault(_path);
    var _underscore = (init_index_all(), __toCommonJS(index_all_exports));
    var _underscore2 = _interopRequireDefault(_underscore);
    var _bluebird = require_bluebird2();
    var _bluebird2 = _interopRequireDefault(_bluebird);
    function shadow(theme, publicPath) {
      if (!theme || !theme.realPath || !publicPath)
        return _bluebird2["default"].reject(new Error("shadow() invalid arguments"));
      if (isRemote(theme["static"]))
        return _bluebird2["default"].resolve();
      var statics = _path2["default"].join(theme.realPath, theme["static"] || "./static");
      var shadow2 = _path2["default"].join(publicPath, theme.name);
      try {
        if (!_fs2["default"].existsSync(publicPath))
          _fs2["default"].mkdirSync(publicPath);
      } catch (err) {
        return _bluebird2["default"].reject(err);
      }
      try {
        if (_fs2["default"].readlinkSync(shadow2) === statics)
          return _bluebird2["default"].resolve();
      } catch (err) {
        try {
          _fs2["default"].symlinkSync(statics, shadow2, "dir");
        } catch (err2) {
          return _bluebird2["default"].reject(err2);
        }
        return _bluebird2["default"].resolve();
      }
      try {
        _fs2["default"].unlinkSync(shadow2);
        _fs2["default"].symlinkSync(statics, shadow2, "dir");
        return _bluebird2["default"].resolve();
      } catch (err) {
        return _bluebird2["default"].reject(err);
      }
    }
    function shadows(self2) {
      var node_modules = _path2["default"].join(self2.path.home, "./node_modules");
      if (!_fs2["default"].existsSync(node_modules))
        return;
      var files = _fs2["default"].readdirSync(node_modules);
      if (!files || files.length === 0)
        return;
      var modules = files.filter(function(folder) {
        var modulePath = _path2["default"].join(node_modules, folder);
        var isDir = _fs2["default"].statSync(modulePath).isDirectory();
        var packagePath = _path2["default"].join(modulePath, "./package.json");
        if (!isDir)
          return;
        if (folder.indexOf(self2.pattern) === -1)
          return;
        if (_fs2["default"].existsSync(_path2["default"].join(self2.path["public"], folder)))
          return;
        var pkg2 = {};
        if (_fs2["default"].existsSync(packagePath))
          pkg2 = readPkg(packagePath);
        var staticPath = pkg2["static"] || "./static";
        if (!_fs2["default"].existsSync(_path2["default"].join(modulePath, staticPath)))
          return;
        var theme = {
          name: folder,
          realPath: modulePath,
          "static": staticPath
        };
        shadow(theme, self2.path["public"]);
        return true;
      });
      return modules;
    }
    function split(name, isFilename) {
      if (!name || name.indexOf("/") === -1)
        return;
      if (!isFilename)
        return name.substr(0, name.indexOf("/"));
      return name.substr(name.indexOf("/") + 1);
    }
    function pkg(home) {
      return readPkg(_path2["default"].join(home, "./package.json"));
    }
    function readPkg(filepath) {
      try {
        return __require(filepath);
      } catch (err) {
        return {};
      }
    }
    function isRemote(dir) {
      return dir && (dir.indexOf("http") === 0 || dir.indexOf("https") === 0);
    }
  }
});

// node_modules/theme/dist/theme.js
var require_theme = __commonJS({
  "node_modules/theme/dist/theme.js"(exports2, module2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _interopRequireWildcard(obj2) {
      if (obj2 && obj2.__esModule) {
        return obj2;
      } else {
        var newObj = {};
        if (obj2 != null) {
          for (var key in obj2) {
            if (Object.prototype.hasOwnProperty.call(obj2, key))
              newObj[key] = obj2[key];
          }
        }
        newObj["default"] = obj2;
        return newObj;
      }
    }
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _defineProperty(obj2, key, value) {
      if (key in obj2) {
        Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj2[key] = value;
      }
      return obj2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var _fs = require_fs();
    var _fs2 = _interopRequireDefault(_fs);
    var _path = require_path();
    var _path2 = _interopRequireDefault(_path);
    var _pkghub = require_pkghub();
    var _pkghub2 = _interopRequireDefault(_pkghub);
    var _underscore = (init_index_all(), __toCommonJS(index_all_exports));
    var _underscore2 = _interopRequireDefault(_underscore);
    var _bluebird = require_bluebird2();
    var _bluebird2 = _interopRequireDefault(_bluebird);
    var _pkghubRender = require_render();
    var _pkghubRender2 = _interopRequireDefault(_pkghubRender);
    var _finder = require_finder3();
    var finder = _interopRequireWildcard(_finder);
    var hub = new _pkghub2["default"]();
    var defaultHome = _path2["default"].resolve(__dirname, "../", "../", "../");
    var Theme = function() {
      function Theme2() {
        var home = arguments.length <= 0 || arguments[0] === void 0 ? defaultHome : arguments[0];
        _classCallCheck(this, Theme2);
        this.path = {};
        this.locals = {};
        this.pattern = "-theme-";
        this.path.home = home;
        this["package"] = finder.pkg(this.path.home);
        this.path["public"] = _path2["default"].join(this.path.home, this["package"]["public"] || "./public");
        finder.shadows(this);
      }
      _createClass(Theme2, [{
        key: "set",
        value: function set(key, value) {
          if (!(key && value))
            return this;
          this[key] = value;
          return this;
        }
        /**
        *
        * Inject locals to theme instance in res.locals.
        * @param {[String]} [key] [the keyname of this local in res.locals]
        *
        **/
      }, {
        key: "local",
        value: function local(key) {
          var _this = this;
          return function(req, res, next) {
            if (!key)
              return next();
            _this.locals[key] = res.locals[key];
            return next();
          };
        }
        /**
        *
        * List all theme module in the seleced home dir
        * e.g: a vaild theme module'name is started with `<parentModuleName>-theme-<themeName>`,
        * 
        * @param {[Function]} [callback] [the callback function triggered when all module listed]
        *
        **/
      }, {
        key: "list",
        value: function list() {
          return hub.themes().then(function(themes) {
            if (themes && themes.name) {
              return _bluebird2["default"].resolve(_defineProperty({}, themes.name, themes));
            }
            return _bluebird2["default"].resolve(themes);
          });
        }
        /**
        *
        * Install new theme module from npm
        * @param {[String | Array]} [name] [the module name or modules array]
        * @param {[Function]} [callback] [the callback function triggerd when installed]
        *
        **/
      }, {
        key: "install",
        value: function install(name) {
          var _this2 = this;
          if (!name)
            return _bluebird2["default"].reject(new Error("Theme name required"));
          return hub.install(name).then(function(modules) {
            return finder.shadow(modules.dependencies[name], _this2.path["public"]).then(function() {
              return _bluebird2["default"].resolve(modules);
            });
          });
        }
        /**
        *
        * Render html using selected target theme and template name
        * e.g: theme.render('myParent-theme-default/index', {a:1}, function(html){});
        *
        * Shortname is also supported:
        * e.g: theme.render(default/index, {a:a}, function(html){});
        *
        **/
      }, {
        key: "render",
        value: function render(template2, data) {
          var pkgname = finder.split(template2);
          var filename = finder.split(template2, "filename");
          if (!filename)
            return _bluebird2["default"].reject(new Error("Theme.render(); target template not found"));
          if (!pkgname && filename)
            pkgname = this["default"];
          if (!pkgname)
            return _bluebird2["default"].reject(new Error("Theme.render(); target theme not found"));
          if (pkgname.indexOf("-") === -1 && this["package"].name)
            pkgname = this["package"].name + this.pattern + pkgname;
          if (!_underscore2["default"].isEmpty(this.locals))
            data = _underscore2["default"].extend(this.locals, data);
          return (0, _pkghubRender2["default"])([pkgname, filename].join("/"), data);
        }
      }]);
      return Theme2;
    }();
    exports2["default"] = Theme;
    module2.exports = exports2["default"];
  }
});
export default require_theme();
/*! Bundled license information:

bluebird/js/browser/bluebird.js:
  (* @preserve
   * The MIT License (MIT)
   * 
   * Copyright (c) 2014 Petka Antonov
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   * 
   *)

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)

bluebird/js/browser/bluebird.js:
  (* @preserve
   * The MIT License (MIT)
   * 
   * Copyright (c) 2013-2015 Petka Antonov
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   * 
   *)

bluebird/js/browser/bluebird.js:
  (* @preserve
   * The MIT License (MIT)
   * 
   * Copyright (c) 2014 Petka Antonov
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   * 
   *)
*/
//# sourceMappingURL=theme.js.map
